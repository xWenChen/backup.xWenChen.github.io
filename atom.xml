<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>做人做事做学问，尽心尽力尽责任。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="xWenChen.github.io/"/>
  <updated>2023-01-27T15:10:22.403Z</updated>
  <id>xWenChen.github.io/</id>
  
  <author>
    <name>WellCherish</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 模版设计模式实战</title>
    <link href="xWenChen.github.io/Android/Android%20%E6%A8%A1%E7%89%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/"/>
    <id>xWenChen.github.io/Android/Android 模版设计模式实战/</id>
    <published>2020-03-28T10:57:00.000Z</published>
    <updated>2023-01-27T15:10:22.403Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文主要讲解如何在实际项目中使用模版设计模式优化代码结构</strong></p><hr><a id="more"></a><h1 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h1><p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。</p><p>模版设计模式的本质便是固定算法框架。</p><p>上面的概念中有三个要点：</p><ul><li>父类定义方法模版</li><li>子类实现方法的某一个部分</li><li>调用以父类的方式调用</li></ul><h1 id="优点"><a class="header-anchor" href="#优点">¶</a>优点</h1><ul><li>在开发时，只需要考虑方法的实现。不需要考虑方法在何种情况下被调用。实现代码复用。</li><li>一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li></ul><h1 id="核心思想"><a class="header-anchor" href="#核心思想">¶</a>核心思想</h1><p>代码复用，避免重复</p><h1 id="使用"><a class="header-anchor" href="#使用">¶</a>使用</h1><p>下面，让我们来介绍一个例子。假设我们需要设计一个即时聊天工具，这个工具可以显示图片、语音、文本、表情等等类型的消息。并且可以显示消息发送的状态，显示消息的时间，显示成员头像，显示成员名称。显示有哪些人读了你的消息。相信使用过 QQ 或者微信的人对这些一定都不陌生。我们暂且将这些功能称为：消息内容、消息时间、消息回执、消息状态、成员头像、成员名称。以发送端的消息显示为例，其可以长这个样子。</p><p><img src="/images/%E6%A8%A1%E7%89%88%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E5%AE%9E%E6%88%98%E6%A0%B7%E4%BE%8B%E5%9B%BE.png" alt="聊天消息布局"></p><p>根据我们对 QQ 和微信的使用，可以很明显的看出，以下的部分是公有布局：</p><ul><li>消息时间</li><li>消息回执</li><li>消息状态</li><li>成员头像</li><li>成员名称</li><li>公共操作，如点击事件、长按事件等等。</li></ul><p>除开上面的公共部分，其实每种消息类型的不同之处便是消息内容部分，对应上图中的主布局区域。</p><p>理清了这些思路，我们可以很轻松的根据模版模式构建出一个消息的显示流程。</p><p>首先，我们应该确定在哪个类里面进行消息的绑定操作。对于 Android，现在已经开始流行使用 RecyclerView，使用 RecyclerView，我们应该在 ViewHolder 中，进行数据的绑定。通过定义一个基类 ViewHolder，实现公共的逻辑。然后定义子类，实现不同消息类型的消息内容的绑定，便可以定义出一套消息绑定的流程。</p><p>下面，我们来一一讲解。首先是流程。</p><ol><li>定义公共布局：将上面我们列举到的时间、头像、名字、已读回执、消息状态这些，定义为公共布局。</li><li>在基类 ViewHolder 中，定义绑定这些公共方法的逻辑。</li><li>在子类 ViewHolder 中，对私有数据进行绑定。</li></ol><p>布局就不详讲了。主要是采用 include 标签，将公共的布局包含到对应的消息类型中。我们重点讲解第2、3步。</p><h2 id="定义基类"><a class="header-anchor" href="#定义基类">¶</a>定义基类</h2><p>基类的定义属于第二步，又可以具体细分为三步。其定义方式如下（注：以下所有的代码，只讲解流程，不会涉及具体的代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseChatItemHolder</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">ViewHolder</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.1 定义外部类调用入口，绑定数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(Msg msg, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 绑定消息公共的数据部分</span></span><br><span class="line">        bindCommonData(msg, position);</span><br><span class="line">        <span class="comment">// 绑定消息私有的数据部分</span></span><br><span class="line">        bindPrivateData(msg, position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 定义公共的数据绑定流程，流程不可更改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindCommonData</span><span class="params">(Msg msg, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置消息时间</span></span><br><span class="line">        setTime(msg);</span><br><span class="line">        <span class="comment">// 设置成员头像</span></span><br><span class="line">        setHead(msg);</span><br><span class="line">        <span class="comment">// 设置成员名称</span></span><br><span class="line">        setName(msg);</span><br><span class="line">        <span class="comment">// 设置消息状态</span></span><br><span class="line">        setState(msg);</span><br><span class="line">        <span class="comment">// 设置消息回执</span></span><br><span class="line">        setMsgReceipt(msg);</span><br><span class="line">        <span class="comment">// 设置公共操作</span></span><br><span class="line">        setCommonOperation(msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.3 定义公共方法，非抽象，需要父类提供实现</span></span><br><span class="line">    <span class="comment">// 设置消息时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTime</span><span class="params">(Msg msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略具体绑定过程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置成员头像</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Msg msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略具体绑定过程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置成员名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(Msg msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略具体绑定过程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置消息状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(Msg msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略具体绑定过程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置消息回执</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsgReceipt</span><span class="params">(Msg msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略具体绑定过程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置公共操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommonOperation</span><span class="params">(Msg msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 省略具体绑定过程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.4 定义消息私有内容绑定的抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">bindPrivateData</span><span class="params">(Msg msg, <span class="keyword">int</span> position)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的流程设计中，我们定义了公共方法，以表示公共消息布局的绑定过程，公共的方法不必声明为 abstract。子类特有的消息内容区域需要设置为抽象类型的，表示子类必须自己处理消息内容布局的绑定过程，并且消息内容的布局需要自己设计。但必须置于一个公共的父布局下。比如所有消息类型的内容布局，其根布局必须是 ConstraintLayout。</p><p>Msg 表示消息，是所有消息类型的父类。如图片消息 PhotoMsg、语音 VoiceMsg 等等这些消息类型都由其衍生出来。其包含了所有消息类型共有的一些属性，比如消息的 id，发送者的 id，接受者的 id，聊天框的 id 等等。当然，具体的内容视业务而定，这里只是举个例子。</p><h2 id="定义子类"><a class="header-anchor" href="#定义子类">¶</a>定义子类</h2><p>接下来，我讲讲子类如何利用父类定义的流程。这里举两个例子。以图片消息(PhotoMsg)、语音消息(VoiceMsg)为例。图片消息无需什么特殊的操作，而语音消息需要特殊的长按操作。</p><p>注：前面提到过，消息内容的布局应该包裹在 ConstraintLayout 中，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 消息内容的布局区域，可以统一命名，方便设置公共操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/chat_msg_item_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 消息内容的布局 --&gt;</span> </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>图片消息</strong></p><p>根据上面提到的原则，图片消息的布局如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 消息内容的布局区域，可以统一命名，方便设置公共操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/chat_msg_item_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 显示图片的 ImageView，布局参数省略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/iv_photo"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"40dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"40dp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhotoChatItemHolder</span> <span class="keyword">extends</span> <span class="title">BaseChatItemHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhotoChatItemHolder</span><span class="params">(ViewGroup parent, @LayoutRes <span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent, resId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindPrivateData</span><span class="params">(Msg msg, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 父类消息转成图片消息，进行私有消息内容数据部分的绑定</span></span><br><span class="line">        PhotoMsg photoMsg = (PhotoMsg) msg;</span><br><span class="line">        <span class="comment">// 省略具体绑定过程</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图片消息除了私有部分，其他无须特殊处理，便可以复用父类的绑定流程。无需重写父类中的非 abstract 类型的方法，使用父类提供的默认实现即可。</p><p><strong>语音消息</strong></p><p>语音消息的布局如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 消息内容的布局区域，可以统一命名，方便设置公共操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/chat_msg_item_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 显示图片的 ImageView，布局参数省略 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">VoiceView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">"@+id/vv_voice"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">"40dp"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">"40dp"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面我们假设了语音需要特殊的长按操作。则可以构建如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoiceChatItemHolder</span> <span class="keyword">extends</span> <span class="title">BaseChatItemHolder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoiceChatItemHolder</span><span class="params">(ViewGroup parent, @LayoutRes <span class="keyword">int</span> resId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent, resId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommonOperation</span><span class="params">(Msg msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 子类重写绑定过程，代执行到此处，会采用子类的实现，不会调用父类的方法</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 2. 如果任性一点，不要长按事件，这里的实现甚至可以返回空。做到差异化。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindPrivateData</span><span class="params">(Msg msg, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 父类消息转成语音消息，进行私有数据部分的绑定</span></span><br><span class="line">        VoiceMsg voiceMsg = (VoiceMsg) msg;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 3. 甚至你可以在这里调用公共操作方法，自定义部分加载流程，覆盖上面的长按事件调用。</span></span><br><span class="line">        setCommonOperation(msg);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子，我们重写了父类中的非抽象公共方法。但是却没有改变绑定流程，便达到了我们想要的效果。并且我们应该将私有部分消息内容的数据绑定放到最后，这样可以给予最大的自由度。另外给了三点说明，写在了注释中。</p><h2 id="使用-v2"><a class="header-anchor" href="#使用-v2">¶</a>使用</h2><p>学习 Java 的时候，我们都知道 Java 类有声明类型和实际类型。此处我们要想正确的调用，达到正确效果，便需要返回正确的实际类型。创建 ViewHolder 时，可以这么写。以图片和语音消息为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewHolderManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseChatItemHolder <span class="title">createViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> msgType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> resId = MsgLayoutManager.getInstance().getLayoutResId(msgType);</span><br><span class="line">        <span class="keyword">switch</span>(msgType) &#123;</span><br><span class="line">            <span class="keyword">case</span> MsgType.PHOTO:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PhotoChatItemHolder(parent, resId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MsgType.VOICE:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> VoiceChatItemHolder(parent, resId);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现很简单。但却能达到我们想要的效果。</p><p>讲完了构建，下面就讲下调用，很简单，在真正需要绑定布局的地方，比如消息适配器 MsgAdapter 的绑定方法中，调用 ViewHolder 的绑定方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgAdapter</span> <span class="keyword">extends</span> <span class="title">RecyclerView</span>.<span class="title">Adapter</span>&lt;<span class="title">BaseChatItemHolder</span>&gt;</span>&#123;</span><br><span class="line">    List&lt;Msg&gt; msgList;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BaseChatItemViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ViewHolderManager.getInstance().createViewHolder(parent, viewType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(BaseChatItemViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        Msg msg = getItem(position);</span><br><span class="line">        </span><br><span class="line">        holder.onBindViewHolder(msg, position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Msg <span class="title">getItem</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msgList.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的调用过程，创建和绑定数据的流程都很简单。</p><p>下面来总结一下。</p><h1 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h1><ol><li>模版模式使用的 Java 语言特性，核心有两个。1 是抽象类可以拥有抽象方法和非抽象方法。抽象方法要求子类必须实现，可以用来制定差异化。非抽象方法则可以用来定义流程。2 是 Java 的方法调用实际上，会最终调用到类的实际类型中的方法实现，而不是声明类型中的方法实现。</li><li>模版模式是以代码复用为目的。避免一个类出现海量代码。规范了流程，提高了可读性。并且给予了子类极大的自由度。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文主要讲解如何在实际项目中使用模版设计模式优化代码结构&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="xWenChen.github.io/categories/Android/"/>
    
    
      <category term="设计模式" scheme="xWenChen.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Android" scheme="xWenChen.github.io/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射</title>
    <link href="xWenChen.github.io/Java/Java%20%E5%8F%8D%E5%B0%84/"/>
    <id>xWenChen.github.io/Java/Java 反射/</id>
    <published>2020-02-11T06:07:00.000Z</published>
    <updated>2023-01-22T14:24:21.170Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文主要讲解 Java 反射相关的基本知识</strong></p><hr><a id="more"></a><h1 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h1><p>相信每个 Java 语言攻城狮都或多或少听说过反射的概念。反射可以说是Java中最强大的技术了。JAVA反射机制是指在**运行状态(运行时)**中，动态获取信息以及动态调用对象方法的功能。</p><p>在 Java 中，通过类加载器和类路径可以唯一确定一个类。通过添加数据、指定实例名等方式，我们可以唯一确定一个类实例；我们可以把这个过程叫做映射。那么反过来，我们是否可以通过类名或者类实例去获取方法、属性、类路径等信息呢？答案当然是可以了。这就是反射。从逻辑上讲，映射和反射就是对立的两个概念，映射是实例映射类的过程，反射是类映射实例的过程</p><p>反射包含以下两个关键点：</p><ul><li>对于任意一个类，都能够知道这个类的所有属性和方法；</li><li>对于任意一个对象，都能够调用它的任意方法和属性</li></ul><p>简单来说反射就是解剖一个类，然后获取这个类中的属性和方法。前提是要获取这个类的Class对象。</p><h1 id="构成基础"><a class="header-anchor" href="#构成基础">¶</a>构成基础</h1><p>Java 语言的反射机制，依赖于 Class 类和 java.lang.reflect 类库。其主要的类如下：</p><ul><li>Class：表示类或者接口</li><li>Field：表示类中的成员变量</li><li>Method：表示类中的方法</li><li>Constructor：表示类的构造方法</li><li>Array：该类提供了动态创建数组和访问数组元素的静态方法</li></ul><h1 id="class-类"><a class="header-anchor" href="#class-类">¶</a>Class 类</h1><p>Class 类是 Java 中用来表示运行时类型信息的对应类。在 Java 中，每个类都有一个 Class 对象，当我们编写并且编译一个新创建的类，相关信息就会被写到 .class 文件里。当我们 <strong>new 一个新对象</strong>或者<strong>引用静态成员变量</strong>时，JVM 中的类加载器子系统便会将对应 Class 对象加载到 JVM 中。我们可以将 Class 类称为类类型，Class 对象称为类类型对象。</p><p>Class 类有以下的特点：</p><ul><li>Class 类是类，class 则是 Java 语言保留的关键字。</li><li>Class 类只有一个私有的构造函数，只有 JVM 能够创建 Class 类的实例。</li><li>对于**同一个类(包名 + 类名相同，且由同一个类加载器加载)**的所有对象，在 JVM 中只有唯一一个对应的 Class 类实例来描述其类型信息。</li></ul><p>.class 文件存储了一个 Class 的所有信息，比如所有的方法，所有的构造函数，所有的字段（成员属性）等等。JVM 启动的时候通过 .class 文件会将相关的类加载到内存中。</p><p>在上面的描述的基础上，我们便可以得到一个类的所有信息了。首先，让我们获取类的实例对象。有三种方法：</p><p><strong>forName 方法</strong></p><p>可以通过 <code>Class.forName</code> 方法获取类的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 String 类的实例</span></span><br><span class="line">Class&lt;String&gt; clazz = Class.forName(<span class="string">"java.lang.String"</span>);</span><br></pre></td></tr></table></figure><p><strong>getClass 方法</strong></p><p>另外，我们也可以通过 <code>Object.getClass</code> 这个实例方法来获取类的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;String&gt; clazz1 = <span class="string">"a"</span>.getClass();</span><br><span class="line"><span class="comment">// 数组对象的 getClass 方法</span></span><br><span class="line">Class clazz2 = (<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]).getClass();</span><br></pre></td></tr></table></figure><p><strong>使用 class 关键字</strong></p><p>还有一种方法是使用 class 关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类</span></span><br><span class="line">Class clazz1 = Integer.class;</span><br><span class="line"><span class="comment">// 数组</span></span><br><span class="line">Class clazz2 = <span class="keyword">int</span> [][].class;</span><br></pre></td></tr></table></figure><p><strong>使用 TYPE 属性</strong></p><p>另外，对于 Java 中定义的基本类型和 void 关键字，都有对应的包装类。在包装类中有一个静态属性 TYPE，保存了该包装类的类类型。如 Integer 类中定义的 TYPE：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;Integer&gt; TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass(<span class="string">"int"</span>);</span><br></pre></td></tr></table></figure><p>我们可以使用 TYPE 属性获取类对象，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class clazz1 = Integer.TYPE;</span><br><span class="line">Class clazz2 = Void.TYPE;</span><br></pre></td></tr></table></figure><p>Java 的基本类型包括：boolean、byte、char、short、int、long、float、double。外加一个 void，可以用 TYPE 获取类对象。</p><p>在获取到了类的实例对象后，我们便可以获取其中存储的信息了。在这之前，我们先讲一下 AccessibleObject。</p><h1 id="accessibleobject"><a class="header-anchor" href="#accessibleobject">¶</a>AccessibleObject</h1><p>AccessibleObject 是 Field、Method、Constructor 三个类共同继承的父类，它提供了将反射的对象标记为，在使用时取消默认 Java 语言访问控制检查的能力。并且 AccessibleObject 实现了 AnnotatedElement 接口，提供了与获取注解相关的能力。这句话有点绕。举个例子。类 A 有一个私有成员 test(声明为 private)。类 B 是不能访问的，但是通过 AccessibleObject 提供的方法，我们却可以将 <code>A.test</code> 属性的限制范围设置为可访问，这样我们便能在 B 类中访问 <code>A.test</code> 属性了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> test = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="comment">// 获取类对象</span></span><br><span class="line">        Class clazz = a.getClass();</span><br><span class="line">        <span class="comment">// 改变修饰符</span></span><br><span class="line">        clazz.getField(<span class="string">"test"</span>).setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 获取 test 属性的值，此处 getInt 仍然需要传入 Object 实例，原因后面解释</span></span><br><span class="line">        System.out.println(clazz.getField(<span class="string">"test"</span>).getInt(a));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在讲了 AccessibleObject 类，我们来看看反射机制中我们经常用过的类。</p><h1 id="field"><a class="header-anchor" href="#field">¶</a>Field</h1><p>Field 提供了有关类或接口的单个属性的信息，以及对它的动态访问的能力。</p><p><strong>动态访问</strong></p><p>对于类的某些属性，其修饰符是使用 private，外部是无法访问的，但是通过 Field 的 setAccessible 方法，我们便可以访问到这些属性。例子在上面已经列举到了，此处就不列举了。</p><p>下面来看看我们经常用到的一些方法：</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">getFields()   </td><td style="text-align:left">获取类中public类型的属性   </td></tr><tr><td style="text-align:left">getDeclaredFields()   </td><td style="text-align:left">获取类中所有的属性，但不包括继承的属性   </td></tr><tr><td style="text-align:left">getField(String name)   </td><td style="text-align:left">获取类中名称为 name 的属性   </td></tr><tr><td style="text-align:left">getType()   </td><td style="text-align:left">返回变量的类类型，返回值是 Class   </td></tr><tr><td style="text-align:left">getGenericType()   </td><td style="text-align:left">返回变量的类型，返回值是 Type   </td></tr><tr><td style="text-align:left">isEnumConstant()   </td><td style="text-align:left">判断当前变量是否是枚举类   </td></tr><tr><td style="text-align:left">getModifiers()   </td><td style="text-align:left">以整数形式，返回此对象的 Java 语言修饰符   </td></tr><tr><td style="text-align:left">getName()   </td><td style="text-align:left">获取属性的名字   </td></tr><tr><td style="text-align:left">get(Object obj)   </td><td style="text-align:left">返回指定对象 obj 上此 Field 的值   </td></tr><tr><td style="text-align:left">set(Object obj, Object value)   </td><td style="text-align:left">将指定对象的此 Field 设置为指定的新值   </td></tr><tr><td style="text-align:left">isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)   </td><td style="text-align:left">判断是否有指定的注解   </td></tr></tbody></table><p>下面，让我们来一一举例。首先，我们定义一个类，包含一些必要的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestField</span> </span>&#123;</span><br><span class="line">    <span class="comment">// a、是 public 的，b 是 protected 的，c、d 是 private 的。其中 d 是 static 的</span></span><br><span class="line">    <span class="keyword">public</span> String a = <span class="string">"a"</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> String c = <span class="string">"c"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String d = <span class="string">"d"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestField2</span> <span class="keyword">extends</span> <span class="title">TestField</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> e = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> f = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getFields 方法和 getName 方法</strong></p><p>然后，让我们来测试下获取字段和打印名字的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TestField testField = <span class="keyword">new</span> TestField();</span><br><span class="line">    Class clazz1 = testField.getClass();</span><br><span class="line">    Field[] fields1 = clazz1.getFields();</span><br><span class="line">    <span class="comment">// 打印属性名</span></span><br><span class="line">    <span class="comment">// 结果是 a，说明 getFields 只会获取声明为 public 的属性</span></span><br><span class="line">    <span class="keyword">for</span> (Field f : fields1) &#123;</span><br><span class="line">        System.out.print(f.getName() + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们加入继承关系，将 TestField 类改为 TestField2 类，其余代码保持不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TestField2 testField = <span class="keyword">new</span> TestField2();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果是 e、a，说明** getFields 方法可以获取从父类继承来的公共属性**。</p><p><strong>getDeclaredFields 方法</strong></p><p>在上面的基础上，我们来看看 getDeclaredFields 方法，我们保持 TestField2 类不变，改变 Field 的获取方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Field[] fields1 = clazz1.getDeclaredFields();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后打印出来的结果是 <code>e f</code>，说明不管修饰符是什么，属性都可以被获取到，但是从父类继承来的变量不能被获取。</p><p><strong>getField(String name) 和 getDeclaredField(String name) 方法</strong></p><p>从上面的代码中可以看出，一个类的属性可以不只有一个，所以可以指定名称，获取到特定的变量，参数应该是类中有的属性的名称。这两个方法的作用范围和上面举例的几个方法一样。此处就不再重复举例了。</p><p><strong>Field.getType() 和 Field.getGenericType() 方法</strong></p><p>默认情况下，这两个的返回值是一样的。但是如果有签名，两者的返回值可能就不一样了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        System.out.print(clazz1.getField(<span class="string">"a"</span>).getType() + <span class="string">" "</span>);</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，执行结果会输出 a 属性的类型，为 <code>class java.lang.String</code></p><p><strong>Field.getModifiers() 方法</strong></p><p>此方法返回的是一个整型值，其代表意义可以查看 Modifier 这个类，该类在 JDK 的反射包下，定义了所有可用整型值代表的意思。此处举几个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Modifier</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 整型值这么定义是为了方便位运算，在求取修饰符的整型值时，会使用下面的值进行或运算。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被 public 修饰，会返回该整型值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PUBLIC           = <span class="number">0x00000001</span>;</span><br><span class="line">    <span class="comment">// 被 private 修饰，会返回该整型值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRIVATE          = <span class="number">0x00000002</span>;</span><br><span class="line">    <span class="comment">// 被 protected 修饰，会返回该整型值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROTECTED        = <span class="number">0x00000004</span>;</span><br><span class="line">    <span class="comment">// 被 static 修饰，会返回该整型值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STATIC           = <span class="number">0x00000008</span>;</span><br><span class="line">    <span class="comment">// 被 final 修饰，会返回该整型值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FINAL            = <span class="number">0x00000010</span>;</span><br><span class="line">    <span class="comment">// 被 synchronized 修饰，会返回该整型值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SYNCHRONIZED     = <span class="number">0x00000020</span>;</span><br><span class="line">    <span class="comment">// 被 volatile 修饰，会返回该整型值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VOLATILE         = <span class="number">0x00000040</span>;</span><br><span class="line">    <span class="comment">// 被 transient 修饰，会返回该整型值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSIENT        = <span class="number">0x00000080</span>;</span><br><span class="line">    <span class="comment">// 被 native 修饰，会返回该整型值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NATIVE           = <span class="number">0x00000100</span>;</span><br><span class="line">    <span class="comment">// 被 interface 修饰，会返回该整型值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERFACE        = <span class="number">0x00000200</span>;</span><br><span class="line">    <span class="comment">// 被 abstract 修饰，会返回该整型值    </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ABSTRACT         = <span class="number">0x00000400</span>;</span><br><span class="line">    <span class="comment">// 被 strictfp 修饰，会返回该整型值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STRICT           = <span class="number">0x00000800</span>;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例说明，在，第一段代码的基础上，获取属性 d 的修饰符。d 是使用 private static 修饰的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出结果 10</span></span><br><span class="line">    System.out.println(clazz1.getDeclaredField(<span class="string">"d"</span>).getModifiers());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的输出结果是 10，而在 Modifier 类中，private 的值是 2(二进制0010)，static 的值是 8(二进制1000)，0010 | 1000 = 1010。二进制换成10进制，刚好等于 10。</p><p><strong>Field.get(Object obj) 方法</strong></p><p>这个方法会得到某个对象的该属性的值。</p><p>在此之前，让我们看段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TestField testField1 = <span class="keyword">new</span> TestField();</span><br><span class="line">    TestField testField2 = <span class="keyword">new</span> TestField();</span><br><span class="line"></span><br><span class="line">    Class clazz1 = testField1.getClass();</span><br><span class="line">    Class clazz2 = testField2.getClass();</span><br><span class="line">    <span class="comment">// 输出的结果为：true</span></span><br><span class="line">    System.out.println(clazz1 == clazz2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码输出的最终结果为 true，说明两个对象拿到的 Class 对象是同一个。可以理解为某一个类的 Class 对象是单例。</p><p>现在，让我们讲讲 get 方法。为什么我们要传入实例对象作为参数呢？就是为了明确，是为了得到哪一个对象的此属性值。因为在更多的场景下，同一个类的相同属性可能有不同的值，比如 Student 类有一个 name 属性，张三的 name 是张三，李四的 name 是李四。这样，同样是name，值却不一样。这便是使用 Field.get(Object obj) 时需要传入 obj 的原因。</p><p>同样的，set(Object obj, Object value) 方法也是一样的逻辑。</p><h1 id="method"><a class="header-anchor" href="#method">¶</a>Method</h1><p>Method 代表了一个类所具有的方法，下面是 Method 类中用到的一些常用方法。</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">getReturnType()   </td><td style="text-align:left">获取方法的返回类型   </td></tr><tr><td style="text-align:left">getParameterTypes()   </td><td style="text-align:left">获取方法中参数的类型   </td></tr><tr><td style="text-align:left">getParameterCount()   </td><td style="text-align:left">获取方法中参数的数量  </td></tr><tr><td style="text-align:left">getExceptionTypes()   </td><td style="text-align:left">获取方法抛出的异常   </td></tr><tr><td style="text-align:left">invoke(Object obj, Object… args)   </td><td style="text-align:left">执行指定对象的该方法   </td></tr><tr><td style="text-align:left">isDefault()   </td><td style="text-align:left">判断方法是否是被 default 修饰的方法   </td></tr><tr><td style="text-align:left">getModifiers()   </td><td style="text-align:left">以整数形式，返回此对象的 Java 语言修饰符   </td></tr><tr><td style="text-align:left">getName()   </td><td style="text-align:left">获取方法的名字   </td></tr><tr><td style="text-align:left">getDefaultValue(Object obj)   </td><td style="text-align:left">获取声明的默认值   </td></tr><tr><td style="text-align:left">getDeclaredAnnotations()</td><td style="text-align:left">获取修饰方法的所有注解   </td></tr></tbody></table><p>同样的，我们根据例子来说明。</p><p>首先，我们改造一下 TestField 类，定义几个方法，其中有静态方法，有参无参方法，有无返回值的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestField</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">m2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sm3</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>getReturnType 和 getParameterTypes 方法</strong></p><p>写的测试代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    TestField testField1 = <span class="keyword">new</span> TestField();</span><br><span class="line"></span><br><span class="line">    Class clazz1 = testField1.getClass();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Method m1 = clazz1.getMethod(<span class="string">"m1"</span>, <span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class, <span class="keyword">int</span>.class&#125;);</span><br><span class="line">        <span class="comment">// 获取方法需要传入参数类型</span></span><br><span class="line">        Class[] parameterizedType1 = m1.getParameterTypes();</span><br><span class="line">        <span class="comment">// 获取返回类</span></span><br><span class="line">        System.out.println(m1.getReturnType());</span><br><span class="line">        <span class="comment">// 此处不会输出结果，因为是空数组</span></span><br><span class="line">        <span class="keyword">for</span>(Class c : parameterizedType1) &#123;</span><br><span class="line">            System.out.println(c.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        Method m2 = clazz1.getMethod(<span class="string">"m1"</span>, <span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">        Class[] parameterizedType2 = m2.getParameterTypes();</span><br><span class="line">        System.out.println(m2.getReturnType());</span><br><span class="line">        <span class="keyword">for</span>(Class c : parameterizedType2) &#123;</span><br><span class="line">            System.out.println(c.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的输出结果为：void、int int、void</p><p>上面获取 Method 实例时，需要传入参数类型。为什么呢？因为<strong>一个类中可能有许多同名方法，需要用参数来进行区分。</strong></p><p>更多的方法使用和 Field 的用法一致。此处就不细讲了。</p><h1 id="constructor"><a class="header-anchor" href="#constructor">¶</a>Constructor</h1><p>常用方法汇总：</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">isVarArgs()   </td><td style="text-align:left">判断构造器的参数是否是可变长度的。即构造器的参数一个或所有被…声明   </td></tr><tr><td style="text-align:left">getParameterTypes()   </td><td style="text-align:left">获取方法中参数的类型   </td></tr><tr><td style="text-align:left">getParameterCount()   </td><td style="text-align:left">获取方法中参数的数量  </td></tr><tr><td style="text-align:left">getExceptionTypes()   </td><td style="text-align:left">获取方法抛出的异常   </td></tr><tr><td style="text-align:left">newInstance(Object … initargs)   </td><td style="text-align:left">该方法用于构造新实例   </td></tr><tr><td style="text-align:left">getModifiers()   </td><td style="text-align:left">以整数形式，返回此对象的 Java 语言修饰符   </td></tr><tr><td style="text-align:left">getName()   </td><td style="text-align:left">获取方法的名字   </td></tr><tr><td style="text-align:left">getDeclaredAnnotations()</td><td style="text-align:left">获取修饰方法的所有注解   </td></tr></tbody></table><p>现在，让我们讲讲构造器。按照管理，先上代码。此处我们定义了两个不同参数的构造器，一个共有，一个私有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestField</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestField</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TestField</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们来进行使用。先获取无参的构造器，然后将其当作有参的构造器使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestField testField1 = <span class="keyword">new</span> TestField();</span><br><span class="line"></span><br><span class="line">        Class clazz1 = testField1.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Constructor c1 = clazz1.getConstructor(<span class="keyword">new</span> Class[<span class="number">0</span>]);</span><br><span class="line">            c1.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="number">2</span>&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面的使用便报错了，报的是参数非法错误：IllegalArgumentException。首先，我们知道，一个类可以有很多个构造器，它们以参数区分。上面的例子拿的无参的构造器，却当作有参的使用，肯定报错。这也就是说，<strong>拿到的构造器的参数列表，必须和构造新实例时的参数列表完全一致</strong>。另外，上面的 <code>newInstance</code> 方法便是构造器类的核心方法，用于创建新的实例。</p><p>另外，让我们做下实验，看能否获取到非 public 的构造器，从 private protected public 三者中测试。关键代码改成下面的代码，分别更改上面定义的类的单参构造器的访问级别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Constructor c1 = clazz1.getConstructor(<span class="keyword">new</span> Class[]&#123;<span class="keyword">int</span>.class&#125;);</span><br><span class="line">    c1.newInstance(<span class="keyword">new</span> Object[]&#123;<span class="number">2</span>&#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过测试，发现<strong>只能获取 public 级别的构造器，私有的和受保护的都不能</strong>。获取私有的和受保护的构造器会报没有此方法错误：NoSuchMethodException。</p><p>至此，反射框架中的几个主要类也讲完了。接下来便是各种应用了。</p><h1 id="动态工厂"><a class="header-anchor" href="#动态工厂">¶</a>动态工厂</h1><p>工厂模式就不详讲了。此处讲一个动态工厂模式。采用反射的方式。采用这种方式可以省去很多代码，尤其是像 if、switch 这种分支判断代码。</p><p>首先，我们定义一个基础的业务父类(也可以是接口)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们定义一个工厂类，用于获取服务类实例。获取的过程是动态的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个实例缓存</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ConcurrentHashMap&lt;String, BaseService&gt; hashMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义获取服务的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getService</span><span class="params">(Context context, Class&lt;? extends BaseService&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义服务类实例</span></span><br><span class="line">        BaseService baseService;</span><br><span class="line">            </span><br><span class="line">        baseService = hashMap.get(serviceClass.getName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (baseService == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 传入对应的参数类型列表，获取构造器，getDeclaredConstructor 可以获取私有的构造器</span></span><br><span class="line">                Constructor&lt;? extends BaseService&gt; constructor = serviceClass.getDeclaredConstructor(Context.class);</span><br><span class="line">                constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                baseService = constructor.newInstance(context);</span><br><span class="line">                putService(businessService);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"get the service failed:"</span> + serviceClass.getSimpleName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (T) baseService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存服务类实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putService</span><span class="params">(BaseService baseService)</span> </span>&#123;</span><br><span class="line">        String clsName = baseService.getClass().getName();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!hashMap.containsKey(clsName)) &#123;</span><br><span class="line">            hashMap.put(clsName, baseService);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清除缓存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        hashMap.clear();</span><br><span class="line">        System.gc();</span><br><span class="line">        Runtime.getRuntime().runFinalization();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们就可以动态创建自己业务上的服务类了。</p><p>首先需要定义构造器，然后定义获取实例的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TesterviceImpl</span> <span class="keyword">extends</span> <span class="title">BaseService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"TesterviceImpl"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只能通过此方法获取实例，构造器是私有的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TesterviceImpl <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ServiceFactory.getService(context, TesterviceImpl.class);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 私有的构造器，防止调用构造器创建新实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TesterviceImpl</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---------------------------下面便是业务方法------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">a</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后便可以通过类似 <code>TesterviceImpl getInstance(context).a()</code> 的代码获取实例并调用类里面的方法了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文主要讲解 Java 反射相关的基本知识&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Java" scheme="xWenChen.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="xWenChen.github.io/tags/Java/"/>
    
      <category term="反射" scheme="xWenChen.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Java 枚举</title>
    <link href="xWenChen.github.io/Java/Java%20%E6%9E%9A%E4%B8%BE/"/>
    <id>xWenChen.github.io/Java/Java 枚举/</id>
    <published>2020-02-07T07:49:00.000Z</published>
    <updated>2023-01-22T14:25:47.651Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文主要讲解 Java 枚举相关的基本知识</strong></p><hr><a id="more"></a><h1 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h1><p>枚举的作用是定义一个取值范围，在该取值范围内取值，取值方式有以下特点：</p><ul><li>取值只能在枚举定义的范围内进行。</li><li>范围内的所有值，彼此之间不能重复，每个值都具有唯一性。</li><li>取值可以取范围内定义的任意一个值。</li></ul><p>Java 中的枚举是在 1.5 中加入，使用关键字 enum 标记，全称是 enumeration，其对应的类是 Enum 类。创建 enum 时，编译器会为你生成一个相关的类，这个类继承自 <code>java.lang.Enum</code>。</p><h1 id="定义"><a class="header-anchor" href="#定义">¶</a>定义</h1><p>枚举的定义是使用关键字 enum 进行定义的。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Sex &#123;</span><br><span class="line">    MALE(<span class="string">"male"</span>), FEMALE(<span class="string">"female"</span>), UNKNOWN(<span class="string">"unknown"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法默认是私有的</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    Sex(String sexDescription) &#123;</span><br><span class="line">        <span class="keyword">this</span>.sexDescription = sexDescription;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Sex Array: "</span> + values();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义的枚举值，枚举值默认为从0开始的有序数值。即上面定义的枚举中，MALE == 0，FEMALE == 1，UNKNOWN == 2。</p><p>事实上，enum是一种受限制的类，并且具有自己的方法。让我们先来看看枚举有哪些常用方法：</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">返回类型</th><th style="text-align:left">方法说明</th></tr></thead><tbody><tr><td style="text-align:left">compareTo(E o)   </td><td style="text-align:left">int   </td><td style="text-align:left">比较与指定对象的顺序</td></tr><tr><td style="text-align:left">equals(Object other)   </td><td style="text-align:left">boolean   </td><td style="text-align:left">比较与指定对象是否相等</td></tr><tr><td style="text-align:left">getDeclaringClass()   </td><td style="text-align:left">Class&lt;?&gt;   </td><td style="text-align:left">获取枚举常量对应的 Class 对象</td></tr><tr><td style="text-align:left">name()   </td><td style="text-align:left">String   </td><td style="text-align:left">返回此枚举常量的名称。方法被声明为final，不可被重写</td></tr><tr><td style="text-align:left">toString()   </td><td style="text-align:left">String   </td><td style="text-align:left">返回此枚举常量的描述</td></tr><tr><td style="text-align:left">valueOf(Class enumType, String name)   </td><td style="text-align:left">T<t extends enum>   </t></td><td style="text-align:left">静态方法，返回指定类型的枚举常量。</td></tr><tr><td style="text-align:left">valus()   </td><td style="text-align:left">static T[]   </td><td style="text-align:left">静态方法，返回枚举常量中的声明</td></tr></tbody></table><p>默认情况下，<code>name</code> 和 <code>toString</code> 方法都可以用来获取枚举常量的声明名字，但是二者的使用还是有所区别，具体的使用形式如下(以下文字摘自StackOverflow)：</p><p>这实际上取决于你想要对返回值做什么：</p><ul><li>如果您需要获取用于声明枚举常量的确切名称，则应使用 <code>name()</code>，因为 <code>name</code> 方法被声明成了 final，不可被重写。二是因为 <code>toString</code> 方法可能已被覆盖。</li><li>如果您想以用户友好的方式打印枚举常量，您应该使用可以被重写的 <code>toString</code> 方法。</li></ul><p>如果觉得使用 <code>name</code> 或者 <code>toString</code> 仍然有困惑，则可以自定义一个如 <code>getXXXDescription()</code> 的带有说明性质的方法。</p><p><strong>方法</strong></p><p>让我们来看看相关方法的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Sex male = Sex.MALE;</span><br><span class="line">        <span class="comment">// 比较大小，小于目标，返回负值(不一定为 -1)；大于目标，返回正值；等于目标，返回 0</span></span><br><span class="line">        <span class="keyword">int</span> sortSubtraction = male.compareTo(Sex.UNKNOWN);</span><br><span class="line">        <span class="comment">// 返回枚举实例的值，像 valueOf、values 等是静态方法，不能用在枚举实例上</span></span><br><span class="line">        <span class="keyword">int</span> value = male.ordinal();</span><br><span class="line">        <span class="comment">// 获取枚举实例的名字，此处返回的是：male</span></span><br><span class="line">        String name = male.name();</span><br><span class="line">        <span class="comment">// 获取 Sex 中定义的所有枚举实例</span></span><br><span class="line">        Sex[] sexs = Sex.values();</span><br><span class="line">        <span class="comment">// 获取女性性别</span></span><br><span class="line">        Sex female = Sex.valueOf(<span class="string">"female"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象方法</strong></p><p>枚举可以继承自 Enum 类，但是 Enum 类中的方法除了 toString 以外，其他的都被声明为了 final。所以即使我们继承了 Enum，也只能重写 toString 方法。但是，在枚举中，我们可以定义抽象方法，自己实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumDemo &#123;</span><br><span class="line">    <span class="comment">// 实现方法后，必须加分号，故建议在 enum 中还是形成加分号的习惯</span></span><br><span class="line">    FIRST &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"first"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SECOND &#123;</span><br><span class="line">        <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">getInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"second"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法，需要被重写</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>实现接口</strong></p><p>上面定义了两个枚举实例都实现了抽象方法。另外，enum 也可以实现接口，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">I</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumDemo2 implements I&#123;</span><br><span class="line">    ONE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现接口中的方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：enum 不能继承类，因为所有的类都继承自 Enum 类，Java 不允许多重继承。</p><p><strong>使用 switch 语句</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getTrafficInstruct</span><span class="params">(Sex sex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (sex) &#123;</span><br><span class="line">        <span class="keyword">case</span> MALE:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FEMALE:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ...</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="enumset-枚举集合"><a class="header-anchor" href="#enumset-枚举集合">¶</a>EnumSet 枚举集合</h1><p>EnumSet 是一个专为枚举设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值。其有以下一些特点：</p><ul><li>EnumSet 方法是个抽象类，无暴露出来的构造器，不能通过new关键字创建，只能通过其他的方法创建。创建的结果是 EnumSet 的子类。</li><li>EnumSet 集合不允许加入 null 元素，如果试图插入 null 元素，EnumSet 将抛出 NullPointerException 异常。</li><li>EnumSet 的集合元素是有序的，EnumSet 以枚举值在 Enum 类内的定义顺序来决定集合元素的顺序。</li><li>EnumSet 在内部以位向量的形式存储，这种存储形式非常紧凑、高效。因此EnumSet对象占用内存很小，运行效率很好。</li></ul><p>EnumSet 中的常用方法介绍：</p><table><thead><tr><th style="text-align:left">方法名</th><th style="text-align:left">返回类型</th><th style="text-align:left">方法说明</th></tr></thead><tbody><tr><td style="text-align:left">allOf(Class<e> elementType)   </e></td><td style="text-align:left">EnumSet<e>   </e></td><td style="text-align:left">静态方法，将一个枚举包含的所有枚举值添加到新的集合中</td></tr><tr><td style="text-align:left">of(E e)   </td><td style="text-align:left">EnumSet<e>   </e></td><td style="text-align:left">静态方法，根据指定的枚举值创建 EnumSet，of 方法有许多同名方法，可以传入不同数量的参数</td></tr><tr><td style="text-align:left">noneOf(Class<e> elementType)   </e></td><td style="text-align:left">EnumSet<e>   </e></td><td style="text-align:left">静态方法，创建一个不包含任何枚举值的 EnumSet</td></tr><tr><td style="text-align:left">retainAll(Collection&lt;?&gt; c)   </td><td style="text-align:left">boolean   </td><td style="text-align:left">移除当前集合中所有不在 c 中的元素，即求当前 EnumSet 和 c 的交集</td></tr><tr><td style="text-align:left">containsAll(Collection&lt;?&gt; c)   </td><td style="text-align:left">boolean   </td><td style="text-align:left">判断当前 EnumSet 是否包含所有 c 中的元素</td></tr></tbody></table><p>下面，让我们实际来用用这些方法。</p><p>首先，定义一个枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一周的枚举类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Day &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作人员类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 工作人员的姓名</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="comment">// 工作人员哪几天在上班</span></span><br><span class="line">    Set&lt;Day&gt; availableDays;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name, Set&lt;Day&gt; availableDays)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.availableDays = availableDays;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想象一个场景，在一些工作中，比如医生、客服，不是每个工作人员每天都在的。每个人可工作的时间是不一样的，比如张三可能是周一和周三，李四可能是周四和周六。现在，我们有一些问题需要回答：</p><ul><li>有没有哪天一个人都不会来？</li><li>有哪些天至少会有一个人来？</li><li>有哪些天至少会有两个人来？</li><li>有哪些天所有人都会来，以便开会？</li><li>哪些人周一和周二都会来？</li></ul><p>现在，我们便来回答上面的问题：</p><ol><li>首先，我们需要构建几个工作人员：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// of 方法有不同参数数量的重载方法</span></span><br><span class="line"><span class="keyword">new</span> Worker(<span class="string">"张三"</span>, EnumSet.of(Day.MONDAY, Day.TUESDAY, Day.WEDNESDAY)),</span><br><span class="line"><span class="keyword">new</span> Worker(<span class="string">"李四"</span>, EnumSet.of(Day.TUESDAY, Day.THURSDAY, Day.SATURDAY)),</span><br><span class="line"><span class="keyword">new</span> Worker(<span class="string">"王五"</span>, EnumSet.of(Day.TUESDAY, Day.THURSDAY))</span><br></pre></td></tr></table></figure><ol start="2"><li>开始解决问题：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决问题：哪些天一个人都不会来？</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">noneOfPeopleCome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个包含所有日期的集合</span></span><br><span class="line">    Set&lt;Day&gt; days = EnumSet.allOf(Day.class);</span><br><span class="line">    <span class="comment">// 排除掉不来人的日子</span></span><br><span class="line">    <span class="keyword">for</span>(Worker w : workers)&#123;</span><br><span class="line">         days.removeAll(w.getAvailableDays());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(days);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决问题：有哪些天至少会有一个人来？这是求工作人员工作日子的并集</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">atLeastOnePeopleCome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先创建一个空集合</span></span><br><span class="line">    Set&lt;Day&gt; days = EnumSet.noneOf(Day.class);</span><br><span class="line">    <span class="comment">// 开始添加日子，集合的特性保证了不会有重复的元素被添加</span></span><br><span class="line">    <span class="keyword">for</span>(Worker w : workers)&#123;</span><br><span class="line">         days.addAll(w.getAvailableDays());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(days);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决问题：有哪些天所有人都会来？这是求工作人员工作日子的交集</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allPeopleCome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 拿到所有工作日子</span></span><br><span class="line">    Set&lt;Day&gt; days = EnumSet.allOf(Day.class);</span><br><span class="line">    <span class="keyword">for</span>(Worker w : workers)&#123;</span><br><span class="line">        <span class="comment">// 求交集，保留所有在 w 中的枚举元素，如果二者不存在交叉，则 days 变为空</span></span><br><span class="line">         days.retainAll(w.getAvailableDays());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    System.out.println(days);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决问题：哪些人周一和周二都会来？</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">specificDayPeopleCome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对象从日子变成了人</span></span><br><span class="line">    Set&lt;Worker&gt; availableWorkers = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(Worker w : workers)&#123;</span><br><span class="line">         <span class="keyword">if</span>(w.getAvailableDays().containsAll(EnumSet.of(Day.MONDAY,Day.TUESDAY)))&#123;</span><br><span class="line">             availableWorkers.add(w);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span>(Worker w : availableWorkers)&#123;</span><br><span class="line">         System.out.println(w.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我想 EnumSet 的大概用法已经讲的差不多了。</p><h1 id="enummap-枚举字典"><a class="header-anchor" href="#enummap-枚举字典">¶</a>EnumMap 枚举字典</h1><p>EnumMap 类继承自 AbstractMap 抽象类，在 EnumMap 对相应方法做了特别的实现。<strong>保证 key 为枚举类型，并且键值对按照枚举类定义的顺序有序</strong>。明白了这个区别，剩下的便是常规的 Map 操作了。下面举个例子，接着上面的内容，现在，我要回答一个问题：哪些天至少会有两个人来？</p><p>这就涉及到了每一天来的人数了，需要统计。用上 EnumMap 刚好合适。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决问题：哪些天至少会有两个人来？</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">atLeastTwoPeopleCome</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// EnumMap Key 值为枚举类型，先创建一个 Key 为 Day 类型的空的 EnumMap，单参构造器是为了告诉 EnumMap Key 的类型，不含任何元素</span></span><br><span class="line">    Map&lt;Day, Integer&gt; countMap = <span class="keyword">new</span> EnumMap&lt;&gt;(Day.class);</span><br><span class="line">    <span class="comment">// 先统计出每天的人数</span></span><br><span class="line">    <span class="keyword">for</span>(Worker w : workers)&#123;</span><br><span class="line">         <span class="keyword">for</span>(Day d : w.getAvailableDays())&#123;</span><br><span class="line">             Integer count = countMap.get(d);</span><br><span class="line">             countMap.put(d, count==<span class="keyword">null</span>?<span class="number">1</span>:count+<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再找出至少有两个人的天，注意 Map.Entry 的用法</span></span><br><span class="line">    Set&lt;Day&gt; days = EnumSet.noneOf(Day.class);</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;Day, Integer&gt; entry : countMap.entrySet())&#123;</span><br><span class="line">        <span class="keyword">if</span>(entry.getValue()&gt;=<span class="number">2</span>)&#123;</span><br><span class="line">            days.add(entry.getKey());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(days);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人说，枚举使用起来占内存，可以使用注解代替。但是我想说：</p><ol><li>枚举的使用绝不可能是程序 OOM 的罪魁祸首。与其花心思进行枚举的优化，不如多找找图片的显示、视频的播放、内存泄漏等问题。</li><li>如果你觉得枚举降低了性能，那么**<a href="https://juejin.cn/post/6844903976219967501" target="_blank" rel="noopener">这篇文章</a>**可能会让你的信念动摇。</li><li>在程序内部，可以使用注解代替枚举，因为编译器会帮你检查。但是如果需要将程序的接口暴露出去，或者是提供 Jar 包、aar 包，建议还是使用枚举。这样可以规范代码，避免使用出错。</li></ol><p>至此，枚举的使用介绍便告一段落了。基于以上情况，个人觉得使用枚举还是很 OK 的。<strong>一句话，想用就用。Enum 相比于注解，有着很多优秀的特性，可以帮助我们写出更优秀的代码。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文主要讲解 Java 枚举相关的基本知识&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Java" scheme="xWenChen.github.io/categories/Java/"/>
    
    
      <category term="枚举" scheme="xWenChen.github.io/tags/%E6%9E%9A%E4%B8%BE/"/>
    
      <category term="Java" scheme="xWenChen.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android 注解</title>
    <link href="xWenChen.github.io/Android/Android%20%E6%B3%A8%E8%A7%A3/"/>
    <id>xWenChen.github.io/Android/Android 注解/</id>
    <published>2020-01-27T13:18:00.000Z</published>
    <updated>2023-01-18T16:07:13.682Z</updated>
    
    <content type="html"><![CDATA[<p><strong>本文主要讲解 Android 开发常用的注解</strong></p><hr><a id="more"></a><h1 id="介绍"><a class="header-anchor" href="#介绍">¶</a>介绍</h1><p>注解可以理解成一个标签，是给类、方法、变量、属性等加标签。注解（Annotation） 为我们在代码中添加信息提供了一种形式化的方法，是我们可以在稍后 某个时刻方便地使用这些数据（通过 解析注解 来使用这些数据），常见的作用有以下几种：</p><ol><li>提供信息给编译器： 编译器可以利用注解来探测错误和警告信息</li><li>编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理</li><li>运行时的处理： 某些注解可以在程序运行的时候接受代码的提取</li></ol><h1 id="元注解"><a class="header-anchor" href="#元注解">¶</a>元注解</h1><p>『元注解』是用于修饰注解的注解，通常用在注解的定义上，例如：</p><p>JAVA 中有以下几个『元注解』：</p><ul><li>@Target：注解的作用目标</li><li>@Retention：注解的生命周期</li><li>@Documented：注解是否应当被包含在 JavaDoc 文档中</li><li>@Inherited：是否允许子类继承该注解</li></ul><h2 id="target"><a class="header-anchor" href="#target">¶</a>@Target</h2><p>@Target 注解指明了注解的使用范围。其包含一个 ElementType 数组类型的属性字段，属性名是 value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Target &#123;</span><br><span class="line">    ElementType[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ElementType 是一个枚举类型，其包含以下一些值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    <span class="comment">// 被修饰的注解可以作用在类、接口(包括注解类型)、或者枚举上</span></span><br><span class="line">    TYPE,</span><br><span class="line">    <span class="comment">// 被修饰的注解可以作用在属性上</span></span><br><span class="line">    FIELD,</span><br><span class="line">    <span class="comment">// 被修饰的注解可以作用在方法上</span></span><br><span class="line">    METHOD,</span><br><span class="line">    <span class="comment">// 被修饰的注解可以作用在参数上</span></span><br><span class="line">    PARAMETER,</span><br><span class="line">    <span class="comment">// 被修饰的注解可以作用在构造器上</span></span><br><span class="line">    CONSTRUCTOR,</span><br><span class="line">    <span class="comment">// 被修饰的注解可以作用在本地局部变量上</span></span><br><span class="line">    LOCAL_VARIABLE,</span><br><span class="line">    <span class="comment">// 被修饰的注解可以作用在注解上</span></span><br><span class="line">    ANNOTATION_TYPE,</span><br><span class="line">    <span class="comment">// 被修饰的注解可以作用在包上</span></span><br><span class="line">    PACKAGE,</span><br><span class="line">    <span class="comment">// 1.8新增类型，被修饰的注解可以作用在泛型上</span></span><br><span class="line">    TYPE_PARAMETER,</span><br><span class="line">    <span class="comment">// 1.8新增类型，被修饰的注解可以作用在任何类型上    </span></span><br><span class="line">    TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="retention"><a class="header-anchor" href="#retention">¶</a>@Retention</h2><p>Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。</p><p>Retention 包含一个 RetentionPolicy 数组类型的属性字段，属性名是 value。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retention &#123;</span><br><span class="line">    <span class="function">RetentionPolicy <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RetentionPolicy 意为保留策略，是一个枚举类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    <span class="comment">// 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</span></span><br><span class="line">    SOURCE,</span><br><span class="line">    <span class="comment">// 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中</span></span><br><span class="line">    CLASS,</span><br><span class="line">    <span class="comment">// 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们</span></span><br><span class="line">    RUNTIME</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="documented"><a class="header-anchor" href="#documented">¶</a>@Documented</h2><p>顾名思义，@Documented 是和文档有关。被它标记的元素会被 Javadoc 工具处理，作用是能够将注解中的元素包含到 Javadoc 中去。</p><h2 id="inherited"><a class="header-anchor" href="#inherited">¶</a>@Inherited</h2><p>Inherited 是继承的意思，其表明了注解的继承关系，子类可以继承父类的注解声明。</p><p>如果一个类 1 被 @Inherited 注解过，那么用注解 A 去标记类 1，类 2 继承自类 1。不管类 2 有没有注解 A，类 2 都有 A 的注解，其继承自类 1。</p><h2 id="repeatable"><a class="header-anchor" href="#repeatable">¶</a>@Repeatable</h2><p>Repeatable 是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Repeatable &#123;</span><br><span class="line">    <span class="comment">// 包含一组相同类型的值</span></span><br><span class="line">    Class&lt;? extends Annotation&gt; value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以看出，@Repeatable 注解使用了泛型，其值是注解的 Class 类型，属性名是 value。</p><p>该注解的用法可以参考<a href="https://blog.csdn.net/ljcgit/article/details/81708679" target="_blank" rel="noopener">这篇博文</a>，此处就不介绍了，还是很简单的.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 注解的属性</span><br><span class="line"></span><br><span class="line">从上面的代码中，我们知道注解的定义是使用 @interface。其实所有的注解都隐式继承自 Annotation 这个接口。所以我们见到的所有注解的属性，严格意义上讲并不是属性，而是方法。想想接口的方法是怎么定义的？</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public interface A &#123;</span><br><span class="line">    // 接口的方法定义，加括号</span><br><span class="line">    String say();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public @interface B &#123;</span><br><span class="line">    // 注解的属性定义，加括号</span><br><span class="line">    String say();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两者的定义方式是不是出奇的一致！！！所以，注解的属性，念做属性，实为方法。因此，<strong>注解中的属性定义时，一定要加上括号。</strong></p><h1 id="java-内置注解"><a class="header-anchor" href="#java-内置注解">¶</a>Java 内置注解</h1><p>Java 的内置注解，相信我们大家都不陌生。包括 @Deprecated，@Override，@SuppressWarnings，@SafeVarargs，@FunctionalInterface。</p><h2 id="deprecated"><a class="header-anchor" href="#deprecated">¶</a>@Deprecated</h2><p>这个元素是用来标记过时的元素，编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量。比较鲜明的特征是，被这个注解标记的元素会被打上删除线。</p><h2 id="override"><a class="header-anchor" href="#override">¶</a>@Override</h2><p>这个元素提示子类要复写父类中被 @Override 修饰的方法。表明子类中被这个注解标记的方法均来自父类。该注解只可作用于方法。</p><h2 id="suppresswarnings"><a class="header-anchor" href="#suppresswarnings">¶</a>@SuppressWarnings</h2><p>这个注解用来抑制编译器的警告。之前说过调用被 @Deprecated 注解的方法后，编译器会警告提醒。而有时候开发者会忽略这种警告，他们可以在调用的地方通过 @SuppressWarnings 达到目的。</p><p>该注解的使用原理：Java 1.5 为 Java 增加了注解。使用时可以为 “javac” 指令增加 -Xlint 参数来控制是否报告这些警告（如@Deprecated）。默认情况下，Sun 编译器<strong>以简单的两行的形式输出警告。通过添加 -Xlint:keyword 标记（例如 -Xlint:finally），您可以获得关键字类型错误的完整说明。通过在关键字前面添加一个破折号，写为 -Xlint:-keyword，您可以取消警告。（-Xlint 支持的关键字的完整列表可以在 javac 文档页面上找到。）</strong></p><p>下面是使用到的关键字的详细说明：</p><ul><li>deprecation：使用了不赞成使用的类或方法时的警告</li><li>unchecked：执行了未检查的转换时的警告，例如使用集合时没有指定泛型类型</li><li>fallthrough：当 Switch 程序块直接通往下一种情况而**没有 Break **时的警告</li><li>path：在类路径、源文件路径等中有不存在的路径时的警告</li><li>serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告</li><li>finally：任何 finally 子句不能正常完成时的警告</li><li>all：关于以上所有情况的警告</li></ul><p>基于上面的描述，下面是一个使用例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">D2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 忽略废弃元素的警告，value中的可指定值在上面列举出来了</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(value=&#123;<span class="string">"deprecation"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       D1.foo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="safevarargs"><a class="header-anchor" href="#safevarargs">¶</a>@SafeVarargs</h2><p>参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作。它的存在会阻止编译器产生 unchecked 这样的警告。它是在 Java 1.7 的版本中加入的。</p><p>具体的例子此处我就不讲了，可以看看<a href="https://blog.csdn.net/lastsweetop/article/details/82863417" target="_blank" rel="noopener">这片博文</a></p><h2 id="functionalinterface"><a class="header-anchor" href="#functionalinterface">¶</a>@FunctionalInterface</h2><p>函数式接口注解，这个是 Java 1.8 版本引入的新特性。函数式编程很火，所以 Java 8 也及时添加了这个特性。函数式接口可以很容易转换为 Lambda 表达式。</p><h1 id="android-注解"><a class="header-anchor" href="#android-注解">¶</a>Android 注解</h1><p>Android 平台提供了部分注解供我们使用，在使用之前，需要导入相关的包，语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.android.support:support-annotations:VERSION_NUM&apos;</span><br></pre></td></tr></table></figure><p>此包提供的注解如下：</p><h2 id="intdef-和-stringdef"><a class="header-anchor" href="#intdef-和-stringdef">¶</a>IntDef 和 StringDef</h2><p>IntDef 和 StringDef 是 Android 提供的两个魔法变量注解，用于取代 enum 和 魔法数字(字符串)等，其有一个数组类型的 value 属性。</p><p>假设我们需要定义消息类型，包括语音、文本、表情、图片、视频等，这些消息类型用整数定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Msg</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> msgType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们并不希望出现其他数字的消息类型，即需要限定类型的范围。此时就有几种方法：</p><ul><li>在使用处加上注释，这并不是什么好方法，不建议采用</li><li>使用枚举类型代替整型，这种方法是可行的，但是在低端机上可以会存在内存占用大的情况。其使用方法如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Msg</span> </span>&#123;</span><br><span class="line">    MsgType msgType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> MsgType &#123;</span><br><span class="line">    TEXT, VOICE, PHOTO, VIDEO</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三种方法便是使用注解，可以使用 IntDef 注解。其使用方法如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、定义消息类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgType</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TEXT = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VOICE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PHOTO = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VIDEO = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2、自定义注解，指定取值范围，后续增加的消息类型都需要在这里加入</span></span><br><span class="line"><span class="comment">// IntDef 有一个属性 value 是一个 int 类型的数组</span></span><br><span class="line"><span class="meta">@IntDef</span>(value = &#123;MsgType.TEXT, MsgType.VOICE, MsgType.PHOTO, MsgType.VIDEO&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AMsgType &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3、使用注解</span></span><br><span class="line"><span class="comment">// 这样就指定了取值范围</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AMsgType</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> msgType;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这么简单，StringDef 的用法也差不多。不过需要注意的是，IntDef 注解还有个 boolean 类型的 flag 的属性，默认情况下，IntDef 的所有取值会被当作 enum （枚举类型）处理，而如果设置了 flag = true，那么 IntDef 中设置的取值范围就会被当作 flag （标志位）处理，标志位可以进行位运算。</p><p>另外，有一个 IntRange 注解和 IntDef 注解类似，前者可以指定取值范围，包括 from 和 to 两个属性，取值区间是连续的。而后者的取值范围更自由，可以不是连续的取值范围。</p><h2 id="threading-注解"><a class="header-anchor" href="#threading-注解">¶</a>Threading 注解</h2><p><strong>Thread注解是帮助我们设置方法的执行线程</strong>，如果和指定的线程不一致，抛出异常。Threading 注解类型：</p><ul><li>@UiThread：UI线程</li><li>@MainThread：主线程</li><li>@WorkerThread：工作线程（子线程）</li><li>@BinderThread：绑定线程</li></ul><h2 id="取值限制范围注解"><a class="header-anchor" href="#取值限制范围注解">¶</a>取值限制范围注解</h2><p>Android 提供了集中取值的范围限制注解供我们使用，其中就包括上面我们提到的 @IntRange 和 @FloatRange 注解，另外还包括一个 @Size 注解。常用的就这三个：</p><ul><li>@Size</li><li>@IntRange</li><li>@FloatRange</li></ul><p>@Size 使用 min、max，而后两者使用 from、to。@Size 用于定义尺寸，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(&#123;PARAMETER,LOCAL_VARIABLE,METHOD,FIELD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Size &#123;</span><br><span class="line">    <span class="comment">// 尺寸的默认值</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">    <span class="comment">// 尺寸 n 的取值范围：min &lt;= n &lt;= max</span></span><br><span class="line">    <span class="comment">// 可取的最小值</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">min</span><span class="params">()</span> <span class="keyword">default</span> Long.MIN_VALUE</span>;</span><br><span class="line">    <span class="comment">//　可取的最大值</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">max</span><span class="params">()</span> <span class="keyword">default</span> Long.MAX_VALUE</span>;</span><br><span class="line">    <span class="comment">// 尺寸的缩放倍数</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">multiple</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="callsuper-注解"><a class="header-anchor" href="#callsuper-注解">¶</a>@CallSuper 注解</h2><p>@CallSuper 注解主要是用来提示子类在覆盖父类的方法时，需要调用对应的super.***方法。下面的代码是个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">F</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提示子类在重写父类的 init 方法时，需要加上 super.init 语句</span></span><br><span class="line">    <span class="meta">@CallSuper</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span>  <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">F</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此处不加入这句，编译器会报错</span></span><br><span class="line">        <span class="keyword">super</span>.init();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="checkresult-注解"><a class="header-anchor" href="#checkresult-注解">¶</a>@CheckResult 注解</h2><p>此注解主要是提示我们使用到方法定义的返回值。该注解有一个 suggest 的字符串类型的属性，允许我们加上一些提醒，来告诉方法调用者为什么要使用此方法的返回值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CheckResult</span>(suggest = <span class="string">"这是注解的说明，请使用返回值!!!"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getInt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这种调用方式会报错</span></span><br><span class="line">    getInt();</span><br><span class="line">    <span class="comment">// 这种调用方法是正确的</span></span><br><span class="line">    <span class="keyword">int</span> result = getInt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，注解也可以通过反射获取到。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;本文主要讲解 Android 开发常用的注解&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="Android" scheme="xWenChen.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="xWenChen.github.io/tags/Android/"/>
    
      <category term="注解" scheme="xWenChen.github.io/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>回溯法-符号三角形问题</title>
    <link href="xWenChen.github.io/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E6%B3%95-%E7%AC%A6%E5%8F%B7%E4%B8%89%E8%A7%92%E5%BD%A2%E9%97%AE%E9%A2%98/"/>
    <id>xWenChen.github.io/算法/回溯法-符号三角形问题/</id>
    <published>2019-08-04T04:37:05.000Z</published>
    <updated>2023-01-18T15:08:07.455Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：回溯法</strong><br><strong>实际问题：符号三角形问题</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h1 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h1><p>如下图是由 14 个 + 和 14 个 - 组成的符号三角形,两个同号的下面是 +，两个异号的下面是 -。</p><p><img src="/images/%E5%9B%9E%E6%BA%AF%E6%B3%95-%E7%AC%A6%E5%8F%B7%E4%B8%89%E8%A7%92%E5%BD%A2%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0.png" alt="符号三角形问题描述"></p><p>设符号三角形的第一行有 n 个符号，求对于给定的 n，计算有多少个不同的符号三角形，使其所包含的 + 和 - 的数量相同。</p><h1 id="解题思路"><a class="header-anchor" href="#解题思路">¶</a>解题思路</h1><ol><li>设 + 为1，- 为 0，这样可以使用异或运算（<strong>相同为 0，不同为 1</strong>）表示符号三角形的关系：<ul><li>“+ +” 为 +：1 ^ 1 = 0</li><li>“- -” 为 +：0 ^ 0 = 0</li><li>“+ -” 为 -：1 ^ 0 = 1</li><li>“- +” 为 -：0 ^ 1 = 1。</li></ul></li><li>使用 x[n] 表示第一行的总共 n 个符号的取值，并且定义：<ul><li>x[i] = 0：第一行第 i 个符号的取值为 -。</li><li>x[i] = 1：第一行第 i 个符号的取值为 +。</li></ul></li><li>使用递归回溯，不断改变第一行的每个符号，搜索符合条件的解。</li><li>剪枝函数（剪枝操作，或者称作递归终止条件）是：当前 + 或者 - 的符号数量大于一半，或者列数达到指定上限（因为解题时是从第一列开始找，一直找到第 n 列截止）</li></ol><h1 id="代码解疑"><a class="header-anchor" href="#代码解疑">¶</a>代码解疑</h1><p>此处可以跳过，直接看代码，如果有不懂的地方，可以返回来看这里。</p><ol><li><p>位操作：从效率上讲，一个<strong>移位指令占2个机器周期</strong>，而<strong>乘除法指令占4个机器周期</strong>。故在做乘除法时，使用位运算有着更高的效率。在本次博文写的代码中，主要用到了两个技巧：<strong>与运算</strong>、<strong>异或运算</strong>与<strong>移位操作</strong>。</p><ul><li><p>与运算：与运算是一种逻辑运算技巧，它的规则是：真与真=真、假与真=假、真与假=假、假与假=假；即满足两个条件都为真时，结果才为真。在 Java 中，与运算符是 &amp;，&amp; 表示按位与，并且 0 表示假，1 表示真，即 1 &amp; 1 = 1、0 &amp; 1 = 0、1 &amp; 0 = 0、0 &amp; 0 = 0。若两个数相与，如 4 和 3与为 0，就可以表示为 100 &amp; 011 = 0，在计算机中，十进制的数是用二进制表示的，如 4 在计算机中的表示是 100。如需要了解更详细的知识，请自行百度。</p><p>扯远了，回归正题。在代码中，我们有判断一个数的奇偶性。使用了这样的技巧：n &amp; 1，在计算机中，奇数的最低位的值必然为 1（其他高位是2的整数倍，相加必然为偶数，最低位如果是0，就无法构成奇数），而 1 是最小的奇数，除了最低位，其他位都为 0。按照与运算的规则，**任何一个数 n 与上 1，除了最低位，其他位都是 0。如果 n 为奇数，与的结果最低位为 1，结果是 1；如果 n 为偶数，与的结果最低位为 0，结果是 0。**我们因而可以形如 n &amp; 1 的式子来判断一个数的奇偶性。</p></li><li><p>异或运算：逻辑运算的一种，前面解释过，此处不讲了。</p></li><li><p>移位操作：在 Java 中，移位运算符使用 &gt;&gt;（右移）和 &lt;&lt;（左移）表示的。如 4 右移一位，可以表示为 4 &gt;&gt; 1，从二进制的角度将，100（4） 变成了 010（2），即缩小了一半。如果左移，则是增大一倍，在有大量乘除操作的场景中，使用移位操作可以极大的提升效率。</p></li></ul></li><li><p>剪枝操作的使用位置有两处，二选一，但应注意两个位置的判断逻辑有差别。具体的代码注释中有详细说明。</p></li><li><p>根据符号三角形的构成规则，如果三角形第一行有 n 列，那么符号三角形就有 n 行，即行数和列数相等。并且相邻两行之间的列数差 1，带入等差数列的公式，可以得出符号三角形的符号总数为  n * (n + 1) / 2。</p></li><li><p>因为 + 和 - 的数量必须相等，所以符号三角形的符号数量是偶数，即 n * (n + 1) / 2 是偶数</p></li><li><p>统计完一种构造方式后，需要还原已统计符号的数量，才能进行下一次的符号三角形构造。</p></li></ol><h1 id="java-代码"><a class="header-anchor" href="#java-代码">¶</a>Java 代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SymbolicTriangleProblem</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一行的符号个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="comment">// half 的目标数值为 (n * (n + 1) / 2) / 2，即 n * (n + 1) / 4</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> half;</span><br><span class="line">    <span class="comment">// 当前"-"的个数 c：count</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> c;</span><br><span class="line">    <span class="comment">// 符号三角形矩阵</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] p;</span><br><span class="line">    <span class="comment">// 符号数组 s：sign</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] s = &#123;<span class="string">"+"</span>, <span class="string">"-"</span>&#125;;</span><br><span class="line">    <span class="comment">// 已找到的符号三角形的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> sum;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        compute(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"符合条件的符号三角形总数： "</span> + sum);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算指定列数下的符号三角形</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col 符号三角形第一行的列数，</span></span><br><span class="line"><span class="comment">     *      其必须满足 (col * (col + 1) &gt;&gt; 1) 是偶数，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        n = col;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// &gt;&gt; 右移一位，表示当前数除以 2</span></span><br><span class="line">        <span class="comment">// 当前的符号总个数，为 1 + 2 + ... + n 的数量</span></span><br><span class="line">        half = n * (n + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 符号数量为单数，返回</span></span><br><span class="line">        <span class="keyword">if</span>((half &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        half &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        p = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从第1行的第1个列开始查找</span></span><br><span class="line">        backtrack(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 回溯函数</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col 当前正在查找的位置：第 col 列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 如果将剪枝操作移动到这里，总数就不能算</span></span><br><span class="line"><span class="comment">         * (col * (col + 1) &gt;&gt; 1，而应该算 (col * (col - 1) &gt;&gt; 1，</span></span><br><span class="line"><span class="comment">         * 即算少一列的情况，因为可能会出现 col &gt; n 的情况，导致结果出错</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        if(c &gt; half || ((col * (col - 1) &gt;&gt; 1) - c &gt; half)) &#123;</span></span><br><span class="line"><span class="comment">            return;</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 当前的列数超过规定的列数</span></span><br><span class="line">        <span class="keyword">if</span>(col &gt; n) &#123;</span><br><span class="line">            sum++;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 打印符号</span></span><br><span class="line">            System.out.println(<span class="string">"第 "</span> + sum + <span class="string">" 个符号三角形："</span>);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="comment">// 打印符号三角形中每一行开始的空白</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                    System.out.print(<span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= (n - i + <span class="number">1</span>); j++) &#123;</span><br><span class="line">                    System.out.print(s[p[i][j]] + <span class="string">" "</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将"+"设为0，"-"设为1</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">                p[<span class="number">1</span>][col] = i;</span><br><span class="line">                <span class="comment">// 统计"-"的个数</span></span><br><span class="line">                c += i;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 判断接下来的 n - 1 行</span></span><br><span class="line">                <span class="comment">// 符号三角形问题中，行的总数等于列的总数</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= col; j++) &#123;</span><br><span class="line">                    <span class="comment">// 通过异或运算求其余行数的放置方式</span></span><br><span class="line">                    p[j][col - j + <span class="number">1</span>] = </span><br><span class="line">                        p[j - <span class="number">1</span>][col - j + <span class="number">1</span>] ^ p[j - <span class="number">1</span>][col - j + <span class="number">2</span>];</span><br><span class="line">                        </span><br><span class="line">                    c += p[j][col - j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// + 或者 - 的数量未超过一半</span></span><br><span class="line">                <span class="comment">// 此处使用 col * (col + 1) &gt;&gt; 1，是因为不会出现 col &gt; n的情况</span></span><br><span class="line">                <span class="keyword">if</span>(c &lt;= half &amp;&amp; ((col * (col + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) - c &lt;= half)) &#123;</span><br><span class="line">                    backtrack(col + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 还原 - 的数量</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= col; j++) &#123;</span><br><span class="line">                    c -= p[j][col - j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                c -= i;               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a class="header-anchor" href="#运行结果">¶</a>运行结果</h1><p>下图为列数为 4 的结果：<br><img src="/images/%E5%9B%9E%E6%BA%AF%E6%B3%95-%E7%AC%A6%E5%8F%B7%E4%B8%89%E8%A7%92%E5%BD%A2%E9%97%AE%E9%A2%98.png" alt="结果实例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：回溯法&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;实际问题：符号三角形问题&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="xWenChen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="回溯法" scheme="xWenChen.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回溯法-N皇后问题</title>
    <link href="xWenChen.github.io/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E6%B3%95-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98/"/>
    <id>xWenChen.github.io/算法/回溯法-N皇后问题/</id>
    <published>2019-07-18T14:58:03.000Z</published>
    <updated>2023-01-18T15:08:07.454Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：回溯法</strong><br><strong>实际问题：N皇后问题</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h1 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h1><p>  N 皇后问题要求求解<strong>在 N × N 的棋盘上放置 N 个皇后</strong>，并使各皇后彼此不受攻击的所有可能的棋盘布局。皇后彼此不受攻击的约束条件是：<strong>任何两个皇后均不能在棋盘上同一行、同一列或者同一对角线上出现</strong>。</p><h1 id="解题思路"><a class="header-anchor" href="#解题思路">¶</a>解题思路</h1><p>  由于N皇后问题不允许两个皇后在同一行，所以，可用一维数组 column 表示 N 皇后问题的解，column[i] 表示第 i 行的皇后所在的列号。由上述 column 数组求解 N 皇后问题，保证了任意两个皇后不在同一行上，我们只需判定皇后彼此不受攻击的其他条件，具体描述如下：</p><ul><li>若 column[i] = column[j]，则第 i 行与第 j 行皇后在同一列上。包含 (i, column[i])，(j, column[j]) 的解不可行。</li><li>第 i 行的皇后在第 j 列，第 s 行皇后在第 t 列，即 column[i] = j 和 column[s] = t，若 |i - s| = |j - t|，则皇后在同一对角线上。因为棋盘为正方形，对角线的斜率为 1。包含这种放置方式的解不可行。</li></ul><h1 id="java-代码"><a class="header-anchor" href="#java-代码">¶</a>Java 代码</h1><p>  有了上述的约束条件（即剪枝函数），则可以编写 Java 代码了。下面的 Java 代码采用的是<strong>递归回溯</strong>的方法（另有<strong>迭代回溯</strong>的方法）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NQueenProblem</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> result;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"请输入皇后的数量："</span>);</span><br><span class="line">        <span class="keyword">int</span> number = input.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// column[i] 表示第 i 行的皇后(也是第 i 个皇后)放在第 column[i] 列</span></span><br><span class="line">        <span class="keyword">int</span>[] column = <span class="keyword">new</span> <span class="keyword">int</span>[number];</span><br><span class="line">        </span><br><span class="line">        backtrack(column, <span class="number">0</span>, number);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"\n可行的结果数量为："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 求取 N 皇后问题的解，输出所有可行的答案</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> column 存储列数据的数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 当前求解的行数，，即从第 row 行开始求解放置方案</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> number 皇后的数量，即总行数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span>[] column, <span class="keyword">int</span> row, <span class="keyword">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 行数达标，输出结果</span></span><br><span class="line">        <span class="keyword">if</span>(row &gt;= number) &#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; number; j++) &#123;</span><br><span class="line">                    <span class="comment">// 输出第 i 个皇后的位置</span></span><br><span class="line">                    <span class="keyword">if</span>(j == column[i]) &#123;</span><br><span class="line">                        System.out.print((i + <span class="number">1</span>) + <span class="string">" "</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        System.out.print(<span class="number">0</span> + <span class="string">" "</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            result++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">                column[row] = i;</span><br><span class="line">                <span class="comment">// 如果当前位置可以放皇后，则进行下一行的位置</span></span><br><span class="line">                <span class="keyword">if</span>(place(row, column)) &#123;</span><br><span class="line">                    backtrack(column, row + <span class="number">1</span>, number);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前位置是否可以放皇后</span></span><br><span class="line"><span class="comment">     * 1、行相同或者列相同，不能放皇后</span></span><br><span class="line"><span class="comment">     * 2、|row1 - row2| = |column1 - column2|，即两个皇后不能处于</span></span><br><span class="line"><span class="comment">     *  对角线上(斜率为 1)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row 当前位置所在的行数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> column 列数组，用以通过行确定列。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">place</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span>[] column)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((column[i] == column[row]) || </span><br><span class="line">                (Math.abs(i - row) == Math.abs(column[i] - column[row]))) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="实验结果"><a class="header-anchor" href="#实验结果">¶</a>实验结果</h1><p>  下图为皇后为 6 的结果：<br><img src="/images/%E5%9B%9E%E6%BA%AF%E6%B3%95-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98-6%E7%9A%87%E5%90%8E.png" alt="6 皇后结果实例"></p><p>  下图为皇后为 4 的结果：<br><img src="/images/%E5%9B%9E%E6%BA%AF%E6%B3%95-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98-4%E7%9A%87%E5%90%8E.png" alt="6 皇后结果实例"></p><p>  上面的实验结果可以验证代码的正确性。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：回溯法&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;实际问题：N皇后问题&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="xWenChen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="回溯法" scheme="xWenChen.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回溯法-总览</title>
    <link href="xWenChen.github.io/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E6%B3%95-%E6%80%BB%E8%A7%88/"/>
    <id>xWenChen.github.io/算法/回溯法-总览/</id>
    <published>2019-07-18T14:14:35.000Z</published>
    <updated>2023-01-18T15:08:07.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念思想"><a class="header-anchor" href="#概念思想">¶</a>概念思想</h1><p>  回溯法有“通用的解题法”之称，用它可以系统地搜索一个问题的<strong>所有解</strong>或<strong>任一解</strong>。回溯法是一个既带有<strong>系统性</strong>又带有<strong>跳跃性</strong>的<strong>搜索算法</strong>，它在问题的解空间中，按<strong>深度优先策略</strong>，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，先判断该结点是否包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的搜索，转而逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先策略搜索。回溯法求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍历才结束。回溯法求问题的一个解时，只要搜索到问题的一个解就可结束。这种<strong>以深度优先方式系统地搜索问题解的算法称为回溯法</strong>，它适用于解组合数较大的问题。</p><hr><a id="more"></a><h1 id="算法框架"><a class="header-anchor" href="#算法框架">¶</a>算法框架</h1><p>  知道了什么叫回溯法，了解了回溯法的基本思想之后，我们就可以定义一个通用的回溯法算法框架，使我们更加方便透彻的在程序中实现它。它包含以下几个必要的步骤：</p><ul><li>**定义问题的解空间：**用回溯法解决问题时，应该明确定义问题的解空间。问题的解空间中应该至少包含问题一种（最优）解。</li><li>**确定解空间结构：**确定易于搜索的解空间结构，使得能用回溯法方便地搜索整个解空间 。通常将解空间组织成树或者图的形式。</li><li>**搜索解空间：**以深度优先方式搜索解空间，并在搜索过程中使用剪枝函数，避免无效搜索。剪枝函数的作用是终止当前结点搜索其子树，转而回溯到父节点。</li></ul><h1 id="博文导航"><a class="header-anchor" href="#博文导航">¶</a>博文导航</h1><ul><li><a href="/%E7%AE%97%E6%B3%95/%E5%9B%9E%E6%BA%AF%E6%B3%95-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98">回溯法-N皇后问题</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概念思想&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#概念思想&quot;&gt;¶&lt;/a&gt;概念思想&lt;/h1&gt;
&lt;p&gt;  回溯法有“通用的解题法”之称，用它可以系统地搜索一个问题的&lt;strong&gt;所有解&lt;/strong&gt;或&lt;strong&gt;任一解&lt;/strong&gt;。回溯法是一个既带有&lt;strong&gt;系统性&lt;/strong&gt;又带有&lt;strong&gt;跳跃性&lt;/strong&gt;的&lt;strong&gt;搜索算法&lt;/strong&gt;，它在问题的解空间中，按&lt;strong&gt;深度优先策略&lt;/strong&gt;，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，先判断该结点是否包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的搜索，转而逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先策略搜索。回溯法求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍历才结束。回溯法求问题的一个解时，只要搜索到问题的一个解就可结束。这种&lt;strong&gt;以深度优先方式系统地搜索问题解的算法称为回溯法&lt;/strong&gt;，它适用于解组合数较大的问题。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="xWenChen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="总览" scheme="xWenChen.github.io/tags/%E6%80%BB%E8%A7%88/"/>
    
      <category term="回溯法" scheme="xWenChen.github.io/tags/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="xWenChen.github.io/%E8%AF%AD%E6%B3%95/Markdown%E8%AF%AD%E6%B3%95/"/>
    <id>xWenChen.github.io/语法/Markdown语法/</id>
    <published>2019-06-23T09:24:14.000Z</published>
    <updated>2023-01-18T15:08:07.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="markdown-简介"><a class="header-anchor" href="#markdown-简介">¶</a>Markdown 简介</h1><p>Markdown 是一种纯文本格式的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作，提高效率。</p><hr><a id="more"></a><h1 id="语法讲解"><a class="header-anchor" href="#语法讲解">¶</a>语法讲解</h1><h2 id="标题"><a class="header-anchor" href="#标题">¶</a>标题</h2><p>在想要设置为标题的文字前面加 # 来表示，# 和文字之间需要空格隔开。</p><p>一个 # 是一级标题，二个 # 是二级标题，以此类推。最多支持六级标题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br><span class="line"></span><br><span class="line">注意：符号与内容之间有空格。</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/images/%E6%A0%87%E9%A2%98%E8%AF%AD%E6%B3%95%E7%9A%84%E6%BC%94%E7%A4%BA.png" alt="六个标题样式"></p><h2 id="字体"><a class="header-anchor" href="#字体">¶</a>字体</h2><p>要加粗的文字左右分别用两个 * 号包起来，要倾斜的文字左右分别用一个 * 号包起来，要倾斜和加粗的文字左右分别用三个 * 号包起来，要加删除线的文字左右分别用两个 ~ 号包起来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">**这是加粗的字体**</span><br><span class="line">*这是倾斜的字体*</span><br><span class="line">***这是加粗+倾斜的字体***</span><br><span class="line">~~这是加了删除线的字体~~</span><br><span class="line"></span><br><span class="line">注意：符号与内容之间无空格。</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><strong>这是加粗的字体</strong></p><p><em>这是倾斜的字体</em></p><p><strong><em>这是加粗+倾斜的字体</em></strong></p><p><s>这是加了删除线的字体</s></p><h2 id="分割线"><a class="header-anchor" href="#分割线">¶</a>分割线</h2><p>三个或者三个以上的 - 或者 * 都可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><p>效果如下：</p><hr><hr><hr><hr><h2 id="引用"><a class="header-anchor" href="#引用">¶</a>引用</h2><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;，直到 n 个，可以无限加下去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;这是引用的内容 1</span><br><span class="line">&gt;&gt;这是引用的内容 2</span><br><span class="line">&gt;&gt;&gt;&gt;这是引用的内容 3</span><br><span class="line"></span><br><span class="line">注意：符号与内容之间无空格。</span><br></pre></td></tr></table></figure><p>效果如下：</p><blockquote><p>这是引用的内容 1</p></blockquote><blockquote><blockquote><p>这是引用的内容 2</p></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><p>这是引用的内容 3</p></blockquote></blockquote></blockquote></blockquote><h2 id="图片"><a class="header-anchor" href="#图片">¶</a>图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">![图片 alt](图片地址 &apos;&apos;图片 title &apos;&apos;)</span><br><span class="line">说明：</span><br><span class="line">图片 alt 就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片 title 是图片的标题，当鼠标移到图片上时显示的内容。title 可加可不加。</span><br><span class="line">图片地址与图片标题之间有个空格，前者不加双引号，后者要加双引号。</span><br><span class="line">举例：</span><br><span class="line">![最小生成树](/images/prim/最小生成树.png &quot;原始连通图&quot;)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/images/prim/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.png" alt="最小生成树" title="原始连通图"></p><h2 id="超链接"><a class="header-anchor" href="#超链接">¶</a>超链接</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">[超链接名](链接地址 &apos;&apos;链接 title &apos;&apos;)</span><br><span class="line">说明：</span><br><span class="line">链接 title 是超链接的标题，当鼠标移到超链接上时显示的内容。title 可加可不加。</span><br><span class="line">链接地址与链接标题之间有个空格，前者不加双引号，后者要加双引号。</span><br><span class="line">举例：</span><br><span class="line">[访问百度](https://www.baidu.com &quot;跳转百度主页&quot;)</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><a href="https://www.baidu.com" title="跳转百度主页" target="_blank" rel="noopener">访问百度</a></p><h2 id="列表"><a class="header-anchor" href="#列表">¶</a>列表</h2><p><strong>无序列表</strong></p><p>无序列表用 - + * 任何一种都可以。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- 无序列表 1</span><br><span class="line">+ 无序列表 2</span><br><span class="line">* 无序列表 3</span><br><span class="line"></span><br><span class="line">注意：符号与内容之间要有空格，列表之间不空行。</span><br></pre></td></tr></table></figure><p>效果如下：</p><ul><li>无序列表 1</li></ul><ul><li>无序列表 2</li></ul><ul><li>无序列表 3</li></ul><p><strong>有序列表</strong></p><p>有序列表用数字加点表示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表 1</span><br><span class="line">2. 有序列表 2</span><br><span class="line">3. 有序列表 3</span><br><span class="line"></span><br><span class="line">注意：点号与内容之间要有空格，列表之间不空行。</span><br></pre></td></tr></table></figure><p>效果如下：</p><ol><li><p>有序列表 1</p></li><li><p>有序列表 2</p></li><li><p>有序列表 3</p></li></ol><p><strong>列表嵌套</strong></p><p>上一级和下一级之间敲三个空格即可。</p><p>效果如下：</p><ul><li><p>上一级无序列表</p><ol><li>下一级有序列表 1</li><li>下一级有序列表 2</li></ol></li><li><p>上一级无序列表</p><ul><li>下一级无序列表 1</li><li>下一级无序列表 2</li></ul></li></ul><ol><li><p>上一级有序列表</p><ul><li>下一级无序列表 1</li><li>下一级无序列表 2</li></ul></li><li><p>上一级有序列表</p><ol><li>下一级有序列表 1</li><li>下一级有序列表 2</li></ol></li></ol><h2 id="表格"><a class="header-anchor" href="#表格">¶</a>表格</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 居中 | 右对齐 |</span><br><span class="line">| :--- | :---: | ---: |</span><br><span class="line">| 内容 | 内容 | 内容 |</span><br><span class="line">| 内容 | 内容 | 内容 |</span><br><span class="line"></span><br><span class="line">注：</span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，可以多加几个</span><br><span class="line">- 左边加 ：表示文字居左</span><br><span class="line">- 两边加 ：表示文字居中</span><br><span class="line">- 右边加 ：表示文字居右</span><br><span class="line">- 两边都不加 : 使用默认格式，文字默认居左</span><br></pre></td></tr></table></figure><p>效果如下：</p><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:center">居中</th><th style="text-align:right">右对齐</th></tr></thead><tbody><tr><td style="text-align:left">内容1</td><td style="text-align:center">内容2</td><td style="text-align:right">内容3</td></tr><tr><td style="text-align:left">内容3</td><td style="text-align:center">内容4</td><td style="text-align:right">内容5</td></tr></tbody></table><h2 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h2><p><strong>单行代码</strong></p><p>单行代码用两个 ` 包括着即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`int a = 2;`</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><code>int a = 2;</code></p><p><strong>多行代码</strong></p><p>多行代码用六个 ` 包括着即可，开头的三个符号后还可以指定编程语言的类型，多行代码又叫代码块。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&apos;```java</span><br><span class="line">public class A &#123;</span><br><span class="line">public static main(String[] args) &#123;</span><br><span class="line">System.out.println(&quot;Hello world!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">```&apos;</span><br></pre></td></tr></table></figure><p>效果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello world!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Markdown 代码块中支持的常用高亮语言类型如下：</p><table><thead><tr><th style="text-align:center">语言</th><th style="text-align:center">Markdown 关键字</th></tr></thead><tbody><tr><td style="text-align:center">Bash</td><td style="text-align:center">bash</td></tr><tr><td style="text-align:center">CMake</td><td style="text-align:center">cmake</td></tr><tr><td style="text-align:center">C++</td><td style="text-align:center">cpp</td></tr><tr><td style="text-align:center">C#</td><td style="text-align:center">cs</td></tr><tr><td style="text-align:center">CSS</td><td style="text-align:center">asciidoc</td></tr><tr><td style="text-align:center">DOS.bat</td><td style="text-align:center">dos</td></tr><tr><td style="text-align:center">Dust</td><td style="text-align:center">dust</td></tr><tr><td style="text-align:center">ERB(Embedded Ruby)</td><td style="text-align:center">erb</td></tr><tr><td style="text-align:center">G-code(ISO 6983)</td><td style="text-align:center">gcode</td></tr><tr><td style="text-align:center">Go</td><td style="text-align:center">bash</td></tr><tr><td style="text-align:center">Gradle</td><td style="text-align:center">gradle</td></tr><tr><td style="text-align:center">Groovy</td><td style="text-align:center">groovy</td></tr><tr><td style="text-align:center">HTML</td><td style="text-align:center">html</td></tr><tr><td style="text-align:center">HTTP</td><td style="text-align:center">http</td></tr><tr><td style="text-align:center">Ini file</td><td style="text-align:center">ini</td></tr><tr><td style="text-align:center">Java</td><td style="text-align:center">java</td></tr><tr><td style="text-align:center">JavaScript</td><td style="text-align:center">javascript</td></tr><tr><td style="text-align:center">JSON</td><td style="text-align:center">json</td></tr><tr><td style="text-align:center">Makefile</td><td style="text-align:center">makefile</td></tr><tr><td style="text-align:center">Mathematica</td><td style="text-align:center">mathematica</td></tr><tr><td style="text-align:center">Matlab</td><td style="text-align:center">matlab</td></tr><tr><td style="text-align:center">Objective C</td><td style="text-align:center">objectivec</td></tr><tr><td style="text-align:center">PHP</td><td style="text-align:center">php</td></tr><tr><td style="text-align:center">Protocol Buffers</td><td style="text-align:center">protobuf</td></tr><tr><td style="text-align:center">Python</td><td style="text-align:center">python</td></tr><tr><td style="text-align:center">Q</td><td style="text-align:center">q</td></tr><tr><td style="text-align:center">R</td><td style="text-align:center">r</td></tr><tr><td style="text-align:center">Ruby</td><td style="text-align:center">ruby</td></tr><tr><td style="text-align:center">Rust</td><td style="text-align:center">rust</td></tr><tr><td style="text-align:center">Scheme</td><td style="text-align:center">scheme</td></tr><tr><td style="text-align:center">SQL</td><td style="text-align:center">sql</td></tr><tr><td style="text-align:center">Swift</td><td style="text-align:center">swift</td></tr><tr><td style="text-align:center">text</td><td style="text-align:center">text/plain</td></tr><tr><td style="text-align:center">TypeScript</td><td style="text-align:center">typescript</td></tr><tr><td style="text-align:center">Vim Script</td><td style="text-align:center">vim</td></tr><tr><td style="text-align:center">XML</td><td style="text-align:center">xml</td></tr><tr><td style="text-align:center">YAML</td><td style="text-align:center">yml</td></tr></tbody></table><h2 id="html-标签"><a class="header-anchor" href="#html-标签">¶</a>HTML 标签</h2><p>Markdown 是支持 HTML 标签的，因为 Markdown 标记语言的内容最终会被解析陈伟 HTML 标签，供浏览器显示。此处举几个用的较多的标签：</p><p><strong>页内跳转</strong></p><p>页内跳转可以实现从本页的 a 处跳转到 b 处。其采用 HTML 中的 a 标签，分两部分定义，下面通过个例子演示。</p><ul><li><p>例子：在 a 处显示一个超链接样式，点击可以跳转到 b 处。</p><ol><li>在 b 处设置一个锚点(定位点)，使用样式 <code>&lt;a name=&quot;b&quot;&gt;定位点&lt;/a&gt;</code>。</li><li>在 a 处设置跳转目标，跳转至 b 处，使用样式 <code>&lt;a href=&quot;#b&quot;&gt;点击跳转&lt;/a&gt;</code>。</li><li>点击 a 处即可跳转到 b 处，点击浏览器的回退按钮，即可返回到 a 处。</li></ol></li></ul><p>效果如下：</p><p><a name="b">定位点</a></p><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><p><a href="#b">点击跳转</a></p><p><strong>上下标</strong></p><p>上标：采用 <code>&lt;sup&gt;&lt;/sup&gt;</code> 标签。</p><p>下标：采用 <code>&lt;sub&gt;&lt;/sub&gt;</code> 标签。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H&lt;sub&gt;2&lt;/sub&gt;O</span><br><span class="line">2&lt;sup&gt;4&lt;/sup&gt; = 16</span><br></pre></td></tr></table></figure><p>效果如下：</p><p>H<sub>2</sub>O</p><p>2<sup>4</sup> = 16</p><p>更多的标签可以自行查找资料，如果担心过多的 HTML 代码会出现解析错误，可以使用 <code>[html][/html]</code> 包裹着 HTML 的源码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;markdown-简介&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#markdown-简介&quot;&gt;¶&lt;/a&gt;Markdown 简介&lt;/h1&gt;
&lt;p&gt;Markdown 是一种纯文本格式的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作，提高效率。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="语法" scheme="xWenChen.github.io/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
      <category term="markdown" scheme="xWenChen.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法-总览</title>
    <link href="xWenChen.github.io/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%80%BB%E8%A7%88/"/>
    <id>xWenChen.github.io/算法/贪心算法-总览/</id>
    <published>2019-06-22T14:08:09.000Z</published>
    <updated>2023-01-18T15:08:07.456Z</updated>
    
    <content type="html"><![CDATA[<h1 id="思想描述"><a class="header-anchor" href="#思想描述">¶</a>思想描述</h1><p>  贪心算法（贪婪算法）是指在对问题进行求解时，在每一步都做出在当前看来是最好的选择，从而希望能够导致结果是最好或者最优的算法。贪心算法所得到的结果往往不是整体的最优解，而是局部的最优解。</p><hr><a id="more"></a><p>  贪心算法有两个基本性质，即<strong>贪心选择</strong>性质和<strong>最优子结构</strong>性质。<strong>贪心选择</strong>性质是贪心算法与动态规划算法的主要区别，其采用从顶向下、以迭代的方法做出相继选择。每做一次贪心选择，就将所求问题简化为一个规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择的性质，我们需要证明每一步所作的贪心选择能最终得到问题的最优解。首先可以证明问题的一个整体最优解是从贪心选择开始的，而且作了贪心选择后，原问题简化为一个规模更小的类似子问题。然后，用数学归纳法证明，通过每一步贪心选择，最终可得到问题的一个整体最优解。<strong>最优子结构</strong>性质是指一个问题的最优解包含其子问题的最优解。运用贪心策略在每一次转化时都取得了最优解。问题的最优子结构性质是该问题可用贪心算法或动态规划算法求解的关键特征。贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。动态规划主要运用于二维或三维问题，而贪心一般是一维问题。</p><h1 id="算法特征"><a class="header-anchor" href="#算法特征">¶</a>算法特征</h1><p>  贪心算法和动态规划算法有着很多类似的地方，将两者进行比较，可以更加深刻的理解贪心算法具有的特征。</p><ol><li><p>最优解</p><ul><li>贪心算法：每一步的最优解一定包含上一步的最优解，上一步之前的最优解则不作保留；</li><li>动态规划：全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有的局部最优解</li></ul></li><li><p>构造过程：</p><ul><li>贪心算法：如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下（自顶向下）遍历最优子树即可（通常这个“最优”都是基于当前情况下显而易见的“最优”）；这样的话，就不需要知道一个节点的所有子树情况，于是构不成一棵完整的树；</li><li>动态规划：动态规划则自底向上，从叶子向根，构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，最后得到一棵完整的树，并且最终选择其中的最优值作为自身的值，得到答案</li></ul></li><li><p>复杂度：</p><ul><li>贪心算法：根据以上两条可以知道，贪心算法不能保证求得的最后解是最佳的，一般复杂度低；</li><li>动态规划：动态规划本质是穷举法，可以保证结果是最佳的，复杂度高。</li></ul></li></ol><h1 id="博文导航"><a class="header-anchor" href="#博文导航">¶</a>博文导航</h1><ul><li><a href="/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98">贪心算法-活动安排问题</a></li><li><a href="/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E4%B8%80%E8%88%AC%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98">贪心算法-一般背包问题</a></li><li><a href="/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">贪心算法-哈夫曼编码</a></li><li><a href="/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">贪心算法-单源最短路径</a></li><li><a href="/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">贪心算法-最小生成树</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;思想描述&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#思想描述&quot;&gt;¶&lt;/a&gt;思想描述&lt;/h1&gt;
&lt;p&gt;  贪心算法（贪婪算法）是指在对问题进行求解时，在每一步都做出在当前看来是最好的选择，从而希望能够导致结果是最好或者最优的算法。贪心算法所得到的结果往往不是整体的最优解，而是局部的最优解。&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="xWenChen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="总览" scheme="xWenChen.github.io/tags/%E6%80%BB%E8%A7%88/"/>
    
      <category term="贪心算法" scheme="xWenChen.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法-最小生成树</title>
    <link href="xWenChen.github.io/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91/"/>
    <id>xWenChen.github.io/算法/贪心算法-最小生成树/</id>
    <published>2019-06-20T15:38:00.000Z</published>
    <updated>2023-01-18T15:08:07.456Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：贪心算法</strong></p><p><strong>实际问题：最小生成树</strong></p><p><strong>编写语言：Java</strong></p><hr><a id="more"></a><p>  图的最小生成树指的是图的一个极小连通子图（同时一棵树），其包含图中的所有 n 个结点，并且有保持图连通的最少的边。设最小生成树中边的数量为 m，顶点的数量为 n，则 m 和 n 满足的数学关系如下：m = n -1。值得注意的是，一个图的最小生成树可能并不唯一。</p><h1 id="prim-算法"><a class="header-anchor" href="#prim-算法">¶</a>Prim 算法</h1><h2 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h2><p>  Prim 算法，又叫普里姆算法，是图论中的一种算法，可在加权连通图里搜索最小生成树。</p><p>  连通图：在一个无向图 G 中，若从顶点 i 到顶点 j 有路径相连（当然从 j 到 i 也一定有路径），则称 i 和 j 是连通的。如果图中任意两点都是连通的，那么图被称作连通图。如果 G 是有向图，那么连接 i 和 j 的路径中所有的边都必须同向。例如，在一个有向图中，E(i, j) 表示点 i 到 j 的边，则 E(j, i) 表示与 E(i, j) 反向的边，E(j, k) 表示与 E(i, j) 同向的边(k 点是 i，j 之外的其它点)。</p><h2 id="mst-生成过程"><a class="header-anchor" href="#mst-生成过程">¶</a>MST 生成过程</h2><p>  MST，全称 Minimum Spanning Tree，中文名最小生成树。使用 Prim 算法构造最小生成树的过程如下：</p><table><thead><tr><th style="text-align:center">图片</th><th style="text-align:center">描述</th><th style="text-align:center">可选点</th><th style="text-align:center">已加入点</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/images/prim/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.png" alt="原始图"></td><td style="text-align:center">原始图中有 7 个点，11 条边</td><td style="text-align:center">A B C D E F G</td><td style="text-align:center">-----</td></tr><tr><td style="text-align:center"><img src="/images/prim/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_Prim_1.png" alt="第 1 步"></td><td style="text-align:center">任选点A，将点 A 加入到观测域中，边(A, D)是最短的边。</td><td style="text-align:center">B D</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center"><img src="/images/prim/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_Prim_2.png" alt="第 2 步"></td><td style="text-align:center">将点 D 加入到观测域中，边(D, F)是最短的边。</td><td style="text-align:center">B E F G</td><td style="text-align:center">A D</td></tr><tr><td style="text-align:center"><img src="/images/prim/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_Prim_3.png" alt="第 3 步"></td><td style="text-align:center">将点 F 加入到观测域中，边(A, B)是最短的边。</td><td style="text-align:center">B E G</td><td style="text-align:center">A D F</td></tr><tr><td style="text-align:center"><img src="/images/prim/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_Prim_4.png" alt="第 4 步"></td><td style="text-align:center">将点 B 加入到观测域中，边(B, E)是最短的边。</td><td style="text-align:center">C E G</td><td style="text-align:center">A B D F</td></tr><tr><td style="text-align:center"><img src="/images/prim/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_Prim_5.png" alt="第 5 步"></td><td style="text-align:center">将点 E 加入到观测域中，边(C, E)是最短的边。</td><td style="text-align:center">C G</td><td style="text-align:center">A B D E F</td></tr><tr><td style="text-align:center"><img src="/images/prim/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_Prim_6.png" alt="第 6 步"></td><td style="text-align:center">将点 C 加入到观测域中，边(E, G)是最短的边。</td><td style="text-align:center">G</td><td style="text-align:center">A B C D E F</td></tr><tr><td style="text-align:center">-----</td><td style="text-align:center">将点 G 加入到观测域中，MST 构造完成。</td><td style="text-align:center">-----</td><td style="text-align:center">A B C D E F G</td></tr></tbody></table><h2 id="算法构造"><a class="header-anchor" href="#算法构造">¶</a>算法构造</h2><p>  **本算法基于无向图构造。**对于 i ∈ S(S 中存放着已经加入最小生成树的顶点), j ∈ V - S(V 是存放所有点的集合), 且权值 c[i][j] 最小的边(i, j)，实现 prim 算法比较简单的方法是设置两个数组 closest 和 lowcost, 对于每一个 j ∈ V - S, closest[j] 是 j 在 S 中的邻接顶点，它与 j 在 S 中的其他邻接顶点 k 相比较，有 c[j][closest[j]] &lt;= c[j][k]。lowcost[j] 的值就是 c[j][closest[j]]。在 Prim 算法的执行过程中，首先找出 V - S 中使 lowcost 值最小的顶点 j，然后根据数组 closest 选取边(j, closest[j])，最后将 j 添加到 S 中，并对 closest 和 lowcost 做必要的修改。</p><ol><li>初始化点集 S。任意选择一个点加入到 S 中；</li><li>寻找最短路径，将点 j 加入到 S 中。点 j 满足：j ∈ V - S, i ∈ S，并且 c[j][i] 最小，即 j 是与 i 相邻的顶点中权值最小的点（贪心性质的具体体现）；</li><li>将 i 加入到 closest[j] 中，将 c[i][j] 加入到 lowcost[j] 中(无向图中，c[i][j] = c[j][i])。</li><li>不断重复第二步和第三步，直到节点全部压入 S 中为止。</li></ol><h2 id="java-代码"><a class="header-anchor" href="#java-代码">¶</a>Java 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试用例：</span></span><br><span class="line"><span class="comment"> * 请输入图的顶点和边的个数(格式：顶点个数 边个数)：7 11</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 请输入图的路径长度(格式：起点 终点 长度)：</span></span><br><span class="line"><span class="comment"> * 1 2 7</span></span><br><span class="line"><span class="comment"> * 1 4 5</span></span><br><span class="line"><span class="comment"> * 2 3 8</span></span><br><span class="line"><span class="comment"> * 2 4 9</span></span><br><span class="line"><span class="comment"> * 2 5 7</span></span><br><span class="line"><span class="comment"> * 3 5 5</span></span><br><span class="line"><span class="comment"> * 4 5 15</span></span><br><span class="line"><span class="comment"> * 4 6 6</span></span><br><span class="line"><span class="comment"> * 5 6 8</span></span><br><span class="line"><span class="comment"> * 5 7 9</span></span><br><span class="line"><span class="comment"> * 6 7 11</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 结果：</span></span><br><span class="line"><span class="comment"> * 第 1 步: 加入边 (1, 4) 权重为 5</span></span><br><span class="line"><span class="comment"> * 第 2 步: 加入边 (4, 6) 权重为 6</span></span><br><span class="line"><span class="comment"> * 第 3 步: 加入边 (1, 2) 权重为 7</span></span><br><span class="line"><span class="comment"> * 第 4 步: 加入边 (2, 5) 权重为 7</span></span><br><span class="line"><span class="comment"> * 第 5 步: 加入边 (5, 3) 权重为 5</span></span><br><span class="line"><span class="comment"> * 第 6 步: 加入边 (5, 7) 权重为 9</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 总权值为：39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimMST</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"请输入图的顶点和边的个数(格式：顶点个数 边个数)："</span>);</span><br><span class="line"><span class="keyword">int</span> n = input.nextInt(); <span class="comment">//顶点的个数</span></span><br><span class="line"><span class="keyword">int</span> m = input.nextInt(); <span class="comment">//边的个数</span></span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//初始化邻接矩阵</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length; j++) &#123;</span><br><span class="line">a[i][j] = -<span class="number">1</span>; <span class="comment">//初始化没有边</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"请输入图的路径长度(格式：起点 终点 长度)："</span>);</span><br><span class="line"><span class="comment">//总共m条边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line"><span class="comment">//起点，范围1到n</span></span><br><span class="line"><span class="keyword">int</span> s = input.nextInt();</span><br><span class="line"><span class="comment">//终点，范围1到n</span></span><br><span class="line"><span class="keyword">int</span> e = input.nextInt();</span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line"><span class="keyword">int</span> l = input.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s &gt;= <span class="number">1</span> &amp;&amp; s &lt;= n &amp;&amp; e &gt;= <span class="number">1</span> &amp;&amp; e &lt;= n) &#123;</span><br><span class="line"><span class="comment">//无向有权图</span></span><br><span class="line">a[s][e] = l;</span><br><span class="line">a[e][s] = l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line">prim(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * prim算法求解最小生成树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> c 图的邻接矩阵</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prim</span><span class="params">(<span class="keyword">int</span>[][] c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = c.length;</span><br><span class="line"><span class="comment">//判断节点是否放入的矩阵</span></span><br><span class="line"><span class="keyword">boolean</span>[] s = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line"><span class="keyword">int</span>[] lowcost = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span>[] closest = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//放入顶点1</span></span><br><span class="line">s[<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt; n; j++) &#123;</span><br><span class="line">lowcost[j] = c[<span class="number">1</span>][j];</span><br><span class="line">closest[j] = <span class="number">1</span>;</span><br><span class="line">s[j] = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共扫描n-2次，v到v自己不用扫</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> min = Integer.MAX_VALUE;</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//找寻最短路径，记录点j和距离lowcost[j]</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; n; k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(lowcost[k] != -<span class="number">1</span> &amp;&amp; lowcost[k] &lt; min &amp;&amp; !s[k]) &#123;</span><br><span class="line">min = lowcost[k];</span><br><span class="line">j = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"第 "</span> + i + <span class="string">" 步: 加入边 ("</span> + closest[j] + </span><br><span class="line"><span class="string">", "</span> + j + <span class="string">") 权重为 "</span> + min);</span><br><span class="line">totalWeight += min;</span><br><span class="line"><span class="comment">//将j添加到S中</span></span><br><span class="line">s[j] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历整个图，用j更新lowcost数组</span></span><br><span class="line"><span class="comment">//判断在新的点加入的情况下，是否有更短的路径</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; k++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!s[k] &amp;&amp; c[j][k] != -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(c[j][k] &lt; lowcost[k] || lowcost[k] == -<span class="number">1</span>) &#123;</span><br><span class="line">lowcost[k] = c[j][k];</span><br><span class="line">closest[k] = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"\n总权值为："</span> + totalWeight);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果"><a class="header-anchor" href="#运行结果">¶</a>运行结果</h2><p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Prim%E7%AE%97%E6%B3%95.jpg" alt="结果示例"></p><h1 id="kruskal-算法"><a class="header-anchor" href="#kruskal-算法">¶</a>Kruskal 算法</h1><p>  Kruskal 算法，又叫克鲁斯卡尔算法，和 Prim 算法一样，是用来求一个连通图的最小生成树的。但是它的思路和 Prim 算法不一样，Prim 算法从顶点的角度出发，而 Kruskal 算法却是从边的角度出发。区别可以看下面的 MST 生成过程。</p><p><strong>连通分量</strong></p><p>  无向图 G 的极大连通子图称为 G 的连通分量( Connected Component)。任何连通图的连通分量只有一个，即是其自身，非连通的无向图有多个连通分量。如下图。</p><table><thead><tr><th style="text-align:center">图片</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/images/prim/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.png" alt="连通图"></td><td style="text-align:center">连通图的连通分量只有一个，就是它自身</td></tr><tr><td style="text-align:center"><img src="/images/%E9%9D%9E%E8%BF%9E%E9%80%9A%E5%9B%BE.png" alt="非连通图"></td><td style="text-align:center">该非连通图的连通分量有三个，分别是 (A B D)，(C E)，(F G)</td></tr></tbody></table><h2 id="mst-生成过程-v2"><a class="header-anchor" href="#mst-生成过程-v2">¶</a>MST 生成过程</h2><table><thead><tr><th style="text-align:center">图片</th><th style="text-align:center">描述</th><th style="text-align:center">已加入点</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/images/prim/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91.png" alt="原始图"></td><td style="text-align:center">原始图中有 7 个点，11 条边</td><td style="text-align:center">-----</td></tr><tr><td style="text-align:center"><img src="/images/kruskal/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_Kruskal_1.png" alt="第 1 步"></td><td style="text-align:center">加入边 (A, D)</td><td style="text-align:center">A D</td></tr><tr><td style="text-align:center"><img src="/images/kruskal/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_Kruskal_2.png" alt="第 2 步"></td><td style="text-align:center">加入边 (C, E)</td><td style="text-align:center">A C D E</td></tr><tr><td style="text-align:center"><img src="/images/kruskal/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_Kruskal_3.png" alt="第 3 步"></td><td style="text-align:center">加入边 (D, F)</td><td style="text-align:center">A C D E F</td></tr><tr><td style="text-align:center"><img src="/images/kruskal/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_Kruskal_4.png" alt="第 4 步"></td><td style="text-align:center">加入边 (A, B)</td><td style="text-align:center">A B C D E F</td></tr><tr><td style="text-align:center"><img src="/images/kruskal/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_Kruskal_5.png" alt="第 5 步"></td><td style="text-align:center">加入边 (B, E)，将两个不同的连通分量合并为一个连通分量</td><td style="text-align:center">A B C D E F</td></tr><tr><td style="text-align:center"><sup><a name="mst">图 1</a></sup><img src="/images/kruskal/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91_Kruskal_6.png" alt="第 6 步"></td><td style="text-align:center">加入边 (E, G)</td><td style="text-align:center">A B C D E F G</td></tr></tbody></table><h2 id="算法构造-v2"><a class="header-anchor" href="#算法构造-v2">¶</a>算法构造</h2><ol><li>构造边 Edge 类，用于存储原图中边的信息；构造并查集 DSU(Disjoint Set Union) 类，用于连通两个不同的分量(并操作)，并判断两个顶点是否处于一个连通分量中(检查操作)；</li><li>将图看作一个森林，即每个节点一开始都是一棵树。根节点是其自身；</li><li>对原图中的边按照权值从小到大排序。每次选择权值最小的边(贪心性质的具体体现)，对边的两个顶点进行并查操作，已经选过的边就不选了。</li><li>重复第 3 步，知道加入最小生成树中的边数量为 m，顶点的数量 n，其满足：m = n - 1。</li></ol><h2 id="java-代码-v2"><a class="header-anchor" href="#java-代码-v2">¶</a>Java 代码</h2><p><strong>说明</strong></p><ul><li>该算法中采用了路径压缩的策略，即每个节点只存储其根节点，不存储中间的父节点。每个节点的根节点存储在 root[] 数组中。</li><li>合并两颗不同的树时，遵循着将小树合并到大树的原则。其尺寸存储在 size 数组中。</li><li>对于 size，最初的时候每棵树只有一个节点，故合并时 size ++，就不会出错。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KruskalMST</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"请输入图的顶点和边的个数(格式：顶点个数 边个数)："</span>);</span><br><span class="line">        <span class="keyword">int</span> n = input.nextInt(); <span class="comment">// 顶点的个数</span></span><br><span class="line">        <span class="keyword">int</span> m = input.nextInt(); <span class="comment">// 边的个数</span></span><br><span class="line"></span><br><span class="line">        Edge[] edges = <span class="keyword">new</span> Edge[m];</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"请输入图的路径长度(格式：起点 终点 长度)："</span>);</span><br><span class="line">        <span class="comment">// 总共m条边</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Edge edge = <span class="keyword">new</span> Edge();</span><br><span class="line">            <span class="comment">//起点，范围1到n</span></span><br><span class="line">            edge.u = input.nextInt();</span><br><span class="line">            <span class="comment">//终点，范围1到n</span></span><br><span class="line">            edge.v = input.nextInt();</span><br><span class="line">            <span class="comment">//权重</span></span><br><span class="line">            edge.weight = input.nextInt();</span><br><span class="line"></span><br><span class="line">            edges[i] = edge;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对数组进行排序</span></span><br><span class="line">        Arrays.sort(edges, <span class="keyword">new</span> Comparator&lt;Edge&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Edge e1, Edge e2)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 返回值为int类型，大于0表示正序，小于0表示逆序</span></span><br><span class="line">                <span class="keyword">return</span> e1.weight - e2.weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        kruskal(n, edges);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * kruskal算法求解最小生成树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 顶点的个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> edges 存储边信息的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n, Edge[] edges)</span> </span>&#123;</span><br><span class="line">        DSU dsu = <span class="keyword">new</span> DSU(n);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最小生成树的总权值</span></span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 已加入边的数量，比顶点的数量小1.</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(Edge e : edges) &#123;</span><br><span class="line">            <span class="keyword">if</span>(m == (n - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> u = e.u;</span><br><span class="line">            <span class="keyword">int</span> v = e.v;</span><br><span class="line">            <span class="keyword">int</span> w = e.weight;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 两个节点不属于一个连通分量</span></span><br><span class="line">            <span class="keyword">if</span>(dsu.findRoot(u) != dsu.findRoot(v)) &#123;</span><br><span class="line">                totalWeight += e.weight;</span><br><span class="line">                dsu.union(u, v, w);</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"总权值为："</span> + totalWeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 存储边信息的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> u, v;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> weight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 并查集(Disjoint Set Union)类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DSU</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录每个节点根节点的数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>[] root;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 记录图的连通分量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span>[] size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 图的顶点的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DSU</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 存储每个节点的根节点</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        root = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 存储图的每个连通分量的尺寸</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        size = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将图当作森林，每个节点一开始都是一棵树。根节点是其自身</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; root.length; i++) &#123;</span><br><span class="line">            root[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将图当作森林，每个节点一开始都是一棵树，尺寸为 1</span></span><br><span class="line">        Arrays.fill(size, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 寻找目标节点的根节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 目标节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果节点有根节点，即该节点已经加入了其它树中</span></span><br><span class="line">        <span class="keyword">if</span>(root[x] != x) &#123;</span><br><span class="line">            <span class="comment">// 路径压缩，即只存储了根节点的信息，并未存储父节点的信息</span></span><br><span class="line">            root[x] = findRoot(root[x]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> root[x];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两棵树</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x 待合并的树1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y 待合并的树2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> w 边的权值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rootX = findRoot(x);</span><br><span class="line">        <span class="keyword">int</span> rootY = findRoot(y);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// x 和 y 的根节点相同，即两者处于同一棵树中，联通分量相同</span></span><br><span class="line">        <span class="keyword">if</span>(rootX == rootY) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 rootX 代表的树数量小于 rootY 所代表的树，那么就将</span></span><br><span class="line">        <span class="comment">// rootX 的树并到 rootY 的那棵树</span></span><br><span class="line">        <span class="keyword">if</span>(size[rootX] &lt; size[rootY]) &#123;</span><br><span class="line">            root[rootX] = rootY;</span><br><span class="line">            size[rootY]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root[rootY] = rootX;</span><br><span class="line">            size[rootX]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"加入边 ("</span> + x + <span class="string">", "</span> + y + <span class="string">")，其权值为："</span> + w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果-v2"><a class="header-anchor" href="#运行结果-v2">¶</a>运行结果</h2><p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-Kruskal%E7%AE%97%E6%B3%95.png" alt="运行结果"></p><h1 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h1><p>对比一下<a href="/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"> Dijkstra 算法</a>、Prim 算法、Kruskal 算法，发现三者有着很多相似之处，也有着不同之处。三者的区别其实主要体现在思想上：</p><ul><li>Dijkstra 算法，又叫单源最短路径算法，其目的是找出从一个点到其它点的最短路径，是<strong>一对多</strong>的关系；而 Prim 算法，是寻找最小生成树，对于无向图，其最小生成树可以有多个。如<a href="#mst">图 1</a>，因为没有方向性，树的根节点可以是 A - G 的任意一个节点。并且构造最小生成树的时候，也不拘泥于单点，而是基于观测域中的所有点构造，故 Prim 算法是<strong>多对多</strong>的关系。</li><li>Prim 算法与 Kruskal 算法都能得到连通图的最小生成树，二者的主要区别在于前者是从<strong>顶点</strong>的角度出发构造最小生成树，而后者是基于<strong>边</strong>构造最小生成树；并且前者的贪心性质主要是<strong>局部贪心</strong>，是在观测域范围内找最小的边，而后者就是<strong>整体贪心</strong>，是在整个图中寻找最短的边。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：贪心算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实际问题：最小生成树&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="xWenChen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="贪心算法" scheme="xWenChen.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法-单源最短路径</title>
    <link href="xWenChen.github.io/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    <id>xWenChen.github.io/算法/贪心算法-单源最短路径/</id>
    <published>2019-06-19T14:56:40.000Z</published>
    <updated>2023-01-18T15:08:07.455Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：贪心算法</strong></p><p><strong>实际问题：单源最短路径</strong></p><p><strong>编程语言：Java</strong></p><hr><a id="more"></a><h1 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h1><p>  单源最短路径算法，又称<a href="https://baike.baidu.com/item/%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/4049057?fr=aladdin" target="_blank" rel="noopener">迪杰斯特拉算法</a>。其目的是寻找从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。</p><h1 id="算法构造"><a class="header-anchor" href="#算法构造">¶</a>算法构造</h1><p><strong>相关解释</strong></p><ul><li>观测域：假设起点为v点，观测域便为v点的四周，即v的所有邻接点；</li><li>点集 V：图中所有点的集合；</li><li>点集 S：已经找到最短路径的终点集合；</li><li>数组 D：存储观测域内能观测到的最短路径，算上起点一共 n 个数值。比如 D[k] 对应在观测域中能观测到的，到顶点 k 的最短路径；</li><li>邻接矩阵 a：存储着有权图中的边的信息，是一个二维数组。比如 a[1][2] = 5 表示在有权图中，点 1 和点 2 之间有边，且边的权值为 5。如果两点之间没边，则用负数或则无穷大(∞)表示。</li></ul><p><strong>算法步骤</strong></p><ul><li>第一步：初始化点集 S，将起点 v 收入 S 中。初始化数组 D：D[k] = a[v][k]；</li><li>第二步：找寻次短路径。即查找数组 D，找出观测域中最短路径(v, j)：D[j] = min(D[k] | k 不属于 S)。将点 j 加入点集 S 中；</li><li>第三步：将 j 的邻接点并入观测域，即用 j 的邻接点更新数组 D；</li><li>第四步：不断重复第二步和第三步，直到节点全部压入 S 中为止。</li></ul><p>注：贪心算法的思想主要就体现在第二步和第三步之中。</p><h1 id="java-代码"><a class="header-anchor" href="#java-代码">¶</a>Java 代码</h1><p>  本代码求解的是<strong>无向有权图</strong>的最短路径，如果想求<strong>有向有权图</strong>的最短路径，则只需要将无向图的邻接矩阵改为有向图的邻接矩阵即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SSSP</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"请输入图的顶点和边的个数(格式：顶点个数 边个数)："</span>);</span><br><span class="line"><span class="keyword">int</span> n = input.nextInt(); <span class="comment">//顶点的个数</span></span><br><span class="line"><span class="keyword">int</span> m = input.nextInt(); <span class="comment">//边的个数</span></span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"><span class="comment">//初始化邻接矩阵</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.length; j++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j] = -<span class="number">1</span>; <span class="comment">//初始化没有边</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"请输入图的路径长度(格式：起点 终点 长度)："</span>);</span><br><span class="line"><span class="comment">//总共m条边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//起点，范围1到n</span></span><br><span class="line"><span class="keyword">int</span> s = input.nextInt();</span><br><span class="line"><span class="comment">//终点，范围1到n</span></span><br><span class="line"><span class="keyword">int</span> e = input.nextInt();</span><br><span class="line"><span class="comment">//长度</span></span><br><span class="line"><span class="keyword">int</span> l = input.nextInt();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(s &gt;= <span class="number">1</span> &amp;&amp; s &lt;= n &amp;&amp; e &gt;= <span class="number">1</span> &amp;&amp; e &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//无向有权图</span></span><br><span class="line">a[s][e] = l;</span><br><span class="line">a[e][s] = l;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">//距离数组</span></span><br><span class="line"><span class="keyword">int</span>[] dist = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"><span class="comment">//前驱节点数组</span></span><br><span class="line"><span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> v =<span class="number">1</span> ;<span class="comment">//顶点，从1开始</span></span><br><span class="line">dijkstra(v, a, dist, prev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单源最短路径算法(迪杰斯特拉算法)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> v 顶点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> a 邻接矩阵表示图</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dist 从顶点v到每个点的距离</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prev 前驱节点数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span>[][] a, <span class="keyword">int</span>[] dist, <span class="keyword">int</span>[] prev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = dist.length;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顶点从1开始，到n结束，一共n个结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span>(v &gt; <span class="number">0</span> &amp;&amp; v &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//顶点是否放入的标志</span></span><br><span class="line"><span class="keyword">boolean</span>[] s = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化为 v 到 i 的距离</span></span><br><span class="line">dist[i] = a[v][i];</span><br><span class="line"><span class="comment">//初始化顶点未放入</span></span><br><span class="line">s[i] = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//v到i无路，i的前驱节点置空</span></span><br><span class="line"><span class="keyword">if</span>(dist[i] == -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">prev[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">prev[i] = v;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//v到v的距离是0</span></span><br><span class="line">dist[v] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//顶点放入</span></span><br><span class="line">s[v] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//共扫描n-2次，v到v自己不用扫</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp = Integer.MAX_VALUE;</span><br><span class="line"><span class="comment">//u为下一个被放入的节点</span></span><br><span class="line"><span class="keyword">int</span> u = v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个for循环为第二步，观测域为v的观测域</span></span><br><span class="line"><span class="comment">//遍历所有顶点找到下一个距离最短的点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//j未放入，且v到j有路，且v到当前节点路径更小</span></span><br><span class="line"><span class="keyword">if</span>(!s[j] &amp;&amp; dist[j] != -<span class="number">1</span> &amp;&amp; dist[j] &lt; temp)</span><br><span class="line">&#123;</span><br><span class="line">u = j;</span><br><span class="line"><span class="comment">//temp始终为最小的路径长度</span></span><br><span class="line">temp = dist[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将得到的下一节点放入</span></span><br><span class="line">s[u] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个for循环为第三步，用u更新观测域</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; n; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!s[k] &amp;&amp; a[u][k] != -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> newdist=dist[u] + a[u][k];</span><br><span class="line"><span class="keyword">if</span>(newdist &lt; dist[k] || dist[k] == -<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">dist[k] = newdist;</span><br><span class="line">prev[k] = u;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(i + <span class="string">"节点的最短距离是："</span></span><br><span class="line">+ dist[i] + <span class="string">"；前驱点是："</span> + prev[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a class="header-anchor" href="#运行结果">¶</a>运行结果</h1><p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84.jpg" alt="j结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：贪心算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实际问题：单源最短路径&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编程语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="xWenChen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="贪心算法" scheme="xWenChen.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法-活动安排问题</title>
    <link href="xWenChen.github.io/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98/"/>
    <id>xWenChen.github.io/算法/贪心算法-活动安排问题/</id>
    <published>2019-06-14T12:38:42.000Z</published>
    <updated>2023-01-18T15:08:07.457Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：贪心算法</strong></p><p><strong>实际问题：活动安排问题</strong></p><p><strong>编写语言：Java</strong></p><hr><a id="more"></a><h1 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h1><p>  设有n个活动的集合 E = {1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动 i 都有一个要求使用该资源的起始时间 si 和一个结束时间 fi，且 si &lt; fi。如果选择了活动 i，则它在半开时间区间 [si, fi) 内占用资源。若区间 [si, fi) 与区间 [sj, fj) 不相交,则称活动 i 与活动 j 是相容的。也就是说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。</p><p>  将活动按照<strong>结束时间进行从小到大排序</strong>。然后用 i 代表第 i 个活动，s[i] 代表第 i 个活动开始时间，f[i] 代表第 i 个活动的结束时间。挑选出结束时间尽量早的活动（活动结束时间最早的活动），并且满足后一个活动的起始时间晚于前一个活动的结束时间，全部找出这些活动就是最大的相容活动子集合。即有活动 i，j 为 i 的下一个活动。f[i]最小，s[j] &gt;= f[i]。</p><h1 id="想法证明"><a class="header-anchor" href="#想法证明">¶</a>想法证明</h1><p>  上述思路的第一步是在最大相容活动子集合中加入最早结束的活动（以下称第一个活动）。实际上，总存在一个最优安排，其包含第一个活动。</p><p>  证明如下：</p><p>  设 E =｛0，1，2，…，n-1｝为所给的活动集合。由于 E 中活动安排安结束时间的<strong>非减序排列</strong>，所以活动 1 具有最早完成时间。首先证明活动安排问题有一个最优解以贪心选择开始（选择了活动 1）。设 A 是所给的活动安排问题的一个最优解，且 B 中活动也按结束时间非减序排列，A 中的第一个活动是活动 k。若 k = 1，则 A 就是一个以贪心选择开始的最优解。若 k &gt; 1，则我们设 B = A -｛k｝∪｛1｝。由于 end[1] ≤ end[k]（非减序排列），且 A 中活动是互为相容的，故 B 中的活动也是互为相容的。又由于 B 中的活动个数与 A 中活动个数相同，且 A 是最优的，故 B 也是最优的。也就是说 B 是一个以贪心选择活动 1 开始的最优活动安排。因此，证明了总存在一个以贪心选择开始的最优活动安排方案，也就是算法具有贪心选择性质。</p><h1 id="java代码"><a class="header-anchor" href="#java代码">¶</a>Java代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityArrangement</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Time&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Time(<span class="number">3</span>, <span class="number">5</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Time(<span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Time(<span class="number">5</span>, <span class="number">7</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Time(<span class="number">0</span>, <span class="number">6</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Time(<span class="number">6</span>, <span class="number">10</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Time(<span class="number">3</span>, <span class="number">8</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Time(<span class="number">5</span>, <span class="number">9</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Time(<span class="number">8</span>, <span class="number">12</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Time(<span class="number">8</span>, <span class="number">11</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Time(<span class="number">2</span>, <span class="number">13</span>));</span><br><span class="line">list.add(<span class="keyword">new</span> Time(<span class="number">12</span>, <span class="number">14</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//将数组按照结束时间排序</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Time&gt;()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Time t1, Time t2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t1.end - t2.end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//选出局部最优解，返回结果数组</span></span><br><span class="line">        <span class="keyword">boolean</span>[] r = greedySelector(list);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"被安排上的活动为："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(r[i] == <span class="keyword">true</span>)</span><br><span class="line">                System.out.print(<span class="string">"["</span> + list.get(i).start + <span class="string">", "</span> </span><br><span class="line">+ list.get(i).end + <span class="string">"] "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 利用贪心性质选出活动安排的最优解</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> list 存储活动的列表</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> r 最终返回的结果数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span>[] greedySelector(ArrayList&lt;Time&gt; list) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = list.size();</span><br><span class="line">        <span class="comment">//存储结果的数组</span></span><br><span class="line">        <span class="keyword">boolean</span>[] r = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将第一个活动放入活动表中</span></span><br><span class="line">        r[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//记录最近一次加入到r中的活动</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//依次检查活动i是否与当前已选择的活动相容</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i).start &gt;= list.get(j).end) &#123;</span><br><span class="line">                r[i] = <span class="keyword">true</span>;</span><br><span class="line">                j = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r[i] = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> start;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> end;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Time</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.start = start;</span><br><span class="line"><span class="keyword">this</span>.end = end;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a class="header-anchor" href="#运行结果">¶</a>运行结果</h1><p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：贪心算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实际问题：活动安排问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="xWenChen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="贪心算法" scheme="xWenChen.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法-哈夫曼编码</title>
    <link href="xWenChen.github.io/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81/"/>
    <id>xWenChen.github.io/算法/贪心算法-哈夫曼编码/</id>
    <published>2019-06-14T12:35:20.000Z</published>
    <updated>2023-01-18T15:08:07.456Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：贪心算法</strong></p><p><strong>实际问题：活动安排问题</strong></p><p><strong>编写语言：Java</strong></p><hr><a id="more"></a><h1 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h1><p>  哈夫曼编码(Huffman Coding)：又称霍夫曼编码，是由 Huffman 于1952年提出一种编码方法，是可变字长编码的一种。哈夫曼编码完全依据字符出现概率来构造异字头的平均长度最短的码字，有时被称为最佳编码，一般就叫做 Huffman 编码。通俗的讲，哈夫曼编码就是出现得越多的内容编码越短 ，出现频率越少的内容编码越长。<br>  哈夫曼树(Huffman Tree)：给定作为 n 个叶子结点，其各带 1 个权值（共 n 个），构造一棵二叉树，若该树的带权路径长度达到最小，则称这样的二叉树为最优二叉树，也称为哈夫曼树。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。哈夫曼树的构造方式为自底向上构造，即先构造叶子节点，在构造父节点，最后构造根节点。</p><h1 id="算法构造"><a class="header-anchor" href="#算法构造">¶</a>算法构造</h1><ol><li>对待编码的内容按照权值大小从小到大排序。</li><li>从已排序的内容列表中选取两个权值最小的内容。组成子节点。并将两者的权值想加，构成新的节点，但此节点无内容。</li><li>重复 1-2 步，有内容的组成叶子节点，无内容的不构成叶子节点。</li><li>对于最终构成的哈夫曼树，根节点不算入编码，左节点编码为 0，右节点编码为 1。</li><li>哈夫曼编码的解码过程是按照哈夫曼树遍历，完成一个内容解码就重新遍历哈夫曼树。</li></ol><h1 id="java-代码"><a class="header-anchor" href="#java-代码">¶</a>Java 代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuffmanCode</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 存放节点的容器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LinkedList&lt;HuffmanNode&gt; huffmanList =</span><br><span class="line">        <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//待编码元素个数</span></span><br><span class="line">System.out.print(<span class="string">"请输入待编码的节点个数："</span>);</span><br><span class="line">        <span class="keyword">int</span> n = input.nextInt();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"请输入节点的内容及其频数："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">String s = input.next();</span><br><span class="line"><span class="keyword">int</span> v = input.nextInt();</span><br><span class="line">            huffmanList.add(<span class="keyword">new</span> HuffmanNode(v, s));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        huffCode();</span><br><span class="line">        decode(huffmanList.get(<span class="number">0</span>), <span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈夫曼编码</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">huffCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(huffmanList.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(huffmanList.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 贪心算法核心，排序后每次取最小的两个数</span></span><br><span class="line"><span class="comment">             * 每取两个数之后就得重新排序，直到只剩下一个元素</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            Collections.sort(huffmanList);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这一步中隐含着一个规则，较小的为左子树，较大的为右子树。</span></span><br><span class="line"><span class="comment"> * 手画哈夫曼树时注意一下，构造的树和最后输出的结果就完全一致了。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">            HuffmanNode node = <span class="keyword">new</span> HuffmanNode(huffmanList.get(<span class="number">0</span>),</span><br><span class="line">                                               huffmanList.get(<span class="number">1</span>));</span><br><span class="line"><span class="comment">//去掉两个子节点，加入父节点。</span></span><br><span class="line"><span class="comment">//子节点虽然不在列表中，但并为被回收，因为在父节点中有引用</span></span><br><span class="line">            huffmanList.remove();</span><br><span class="line">            huffmanList.remove();</span><br><span class="line">            huffmanList.add(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解码算法</span></span><br><span class="line"><span class="comment"> * 打印顺序是从左到右打印哈夫曼树中的叶子节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decode</span><span class="params">(HuffmanNode h, String code)</span> </span>&#123;</span><br><span class="line"><span class="comment">//如果是叶子节点，就输出，只有叶子节点中存储着文本内容，父节点中没有</span></span><br><span class="line">        <span class="keyword">if</span>(h.lChild == <span class="keyword">null</span> &amp;&amp; h.rChild == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"元素 "</span> + h.name + <span class="string">"的编码为："</span> + code);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//如果是父节点，就遍历左右子树(编码遵循左0右1)，直到搜寻到叶子节点</span></span><br><span class="line"><span class="comment">//根据哈夫曼树的构造方式，父节点一定同时有左右子树，无须增加if判断</span></span><br><span class="line">decode(h.lChild, code + <span class="string">"0"</span>);</span><br><span class="line">        decode(h.rChild, code + <span class="string">"1"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈夫曼节点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuffmanNode</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">HuffmanNode</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    String name;</span><br><span class="line">    HuffmanNode lChild = <span class="keyword">null</span>;</span><br><span class="line">    HuffmanNode rChild = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuffmanNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuffmanNode</span><span class="params">(<span class="keyword">int</span> v,String s)</span> </span>&#123;</span><br><span class="line">        value = v;</span><br><span class="line">        name = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里是浅复制，lChild和l都指向一个内存区域，</span></span><br><span class="line"><span class="comment"> * rChild和r都指向同一个内存区域</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuffmanNode</span><span class="params">(HuffmanNode l,HuffmanNode r)</span> </span>&#123;</span><br><span class="line">        lChild = l;</span><br><span class="line">        rChild = r;</span><br><span class="line">        value = lChild.value + rChild.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(HuffmanNode node1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (value&lt;node1.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (value == node1.value) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="结果示例"><a class="header-anchor" href="#结果示例">¶</a>结果示例</h1><p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：贪心算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实际问题：活动安排问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="xWenChen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="贪心算法" scheme="xWenChen.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法-一般背包问题</title>
    <link href="xWenChen.github.io/%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E4%B8%80%E8%88%AC%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>xWenChen.github.io/算法/贪心算法-一般背包问题/</id>
    <published>2019-06-14T00:43:57.000Z</published>
    <updated>2023-01-18T15:08:07.455Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：贪心算法</strong></p><p><strong>实际问题：一般背包问题</strong></p><p><strong>编写语言：Java</strong></p><hr><a id="more"></a><h1 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h1><p>  给定n种物品和一个背包，物品i的重量是wi，其价值是vi，背包的容量为C，问应该如何选择装入背包的物品，使得装入背包中物品的总价值最大。物品可以不装入，可以全部装入，也可以部分装入。</p><p>  思路：首先计算每种物品单位重量的价值 valPer = vi / wi，然后依据贪心选择策略，将 valPer 尽量大的物品装入背包。直到背包装满为止。</p><h1 id="java-代码"><a class="header-anchor" href="#java-代码">¶</a>Java 代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Knapsack</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//存储物品的列表</span></span><br><span class="line">        ArrayList&lt;Goods&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Goods(<span class="number">1</span>, <span class="number">10</span>, <span class="number">35</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Goods(<span class="number">2</span>, <span class="number">40</span>, <span class="number">30</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Goods(<span class="number">3</span>, <span class="number">30</span>, <span class="number">60</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Goods(<span class="number">4</span>, <span class="number">50</span>, <span class="number">50</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Goods(<span class="number">5</span>, <span class="number">35</span>, <span class="number">40</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Goods(<span class="number">6</span>, <span class="number">40</span>, <span class="number">10</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Goods(<span class="number">7</span>, <span class="number">30</span>, <span class="number">25</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//背包容量</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">150</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span>[] r = select(c, list);</span><br><span class="line">        System.out.print(<span class="string">"第一个数代表最大价值，后续数代表装入背包的物品，"</span></span><br><span class="line">            + <span class="string">"最后一个物品为部分装入，其它物品为全部装入："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.length; i++) &#123;</span><br><span class="line">            System.out.print(r[i] + <span class="string">"   "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 根据贪心策略算出最优解</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> c 背包的容量</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> list 存储物品的列表</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@return</span> r 最终求得的结果数组，第一位为最大价值，最后一位为部分装入的</span></span><br><span class="line"><span class="comment">      * 物品序号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span>[] select(<span class="keyword">int</span> c, ArrayList&lt;Goods&gt; list) &#123;</span><br><span class="line">        <span class="comment">//对list按照单位重量的价值排序</span></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Goods&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Goods g1, Goods g2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(g2.v / g2.w - g1.v / g1.w &gt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(g2.v / g2.w - g1.v / g1.w &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; list.size(); j++)</span><br><span class="line">            System.out.print(list.get(j).id + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span>[] r = <span class="keyword">new</span> <span class="keyword">double</span>[list.size() + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//初始化最大价值</span></span><br><span class="line">        r[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//物品值等于-1表示未放入物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; r.length; j++)</span><br><span class="line">            r[j] = -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(list.get(i).w &gt; c)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            r[i + <span class="number">1</span>] = list.get(i).id;</span><br><span class="line">            r[<span class="number">0</span>] += list.get(i).v;</span><br><span class="line">            c -= list.get(i).w;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将最后一件物品加入背包中(最后一件物品不能全部加入，因为它的重量已经比</span></span><br><span class="line">        <span class="comment">//背包的剩余容量大了)</span></span><br><span class="line">        r[i + <span class="number">1</span>] = list.get(i).id;</span><br><span class="line">        r[<span class="number">0</span>] += c * (list.get(i).v / list.get(i).w);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span> </span>&#123;</span><br><span class="line">    <span class="comment">//物品id</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="comment">//物品价值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> v;</span><br><span class="line">    <span class="comment">//物品重量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> w;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行结果"><a class="header-anchor" href="#运行结果">¶</a>运行结果</h1><p><img src="/images/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E4%B8%80%E8%88%AC%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：贪心算法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实际问题：一般背包问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="xWenChen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="贪心算法" scheme="xWenChen.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-最优二叉搜索树</title>
    <link href="xWenChen.github.io/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>xWenChen.github.io/算法/动态规划-最优二叉搜索树/</id>
    <published>2018-09-29T13:06:10.000Z</published>
    <updated>2023-01-18T15:08:07.453Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：动态规划</strong><br><strong>实际问题：最优二叉搜索树</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h6><p>二叉搜索树的定义：<br>满足以下任意两个条件的一个，就可称这棵树为二叉搜索树：</p><ol><li>它是一棵空树</li><li>该树是一颗二叉树，非空，且满足下列两个条件：</li></ol><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值<br>即当该二叉树非空时，使用中序遍历可以得到一个递增的有序序列</li></ul><p>值得注意的是：</p><ol><li>二叉搜索树的左右子树也是二叉搜索树，我们因此可以使用递归手段来构造二叉搜索树</li><li>一个有序序列的二叉搜索树不只一棵，这就为我们寻找最优二叉搜索树提供了可能</li></ol><p>最优二叉搜索树指的是在一个序列的所有二叉搜索树中花费代价最小的那棵。</p><h6 id="递归结构"><a class="header-anchor" href="#递归结构">¶</a>递归结构</h6><p>用C[i , j]表示从 i 到 j 的最优二叉查找树的代价，假设有n个顶点，那么我们的目标是要求C[1 , n]从 i 到 j 的一个最优二叉查找树是怎么得到的？它是从 i 到 j 之间的顶点中选出一个顶点来做root，假设选出的这个做root的顶点是 k （i &lt;= k &lt;= j）, 那么显然有：</p><ul><li>C[i , j] = min(C[i, k - 1] + C[k + 1, j]) + Sum(pi, pj)，其中：1 &lt;= i &lt;= j &lt;= n，i &lt;= k &lt;= j，pi表示遍历第i个结点的代价，Sum(pi, pj)表示求第i个结点到第j个结点的代价总和</li></ul><p>上述求和公式最后为什么还要加一个求和结果呢？因为可以理解为公式前半部分只是找出最短路径，最后求和才是加上权重(网上有更详细更严谨的推导过程，可自行百度)</p><h6 id="java代码"><a class="header-anchor" href="#java代码">¶</a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptBST</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] p = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">0.1</span>, <span class="number">0.15</span>, <span class="number">0.2</span>, <span class="number">0.35</span>, <span class="number">0.2</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        Result r = getOptBST(p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.result.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; r.result.length; j++)</span><br><span class="line">            System.out.print(r.root[i][j] + <span class="string">"  "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 构造最优二叉搜索树的方法</span></span><br><span class="line"><span class="comment">      * param p: 中序序列的点的查找概率数组，返回最优的二叉查找树的代价</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">getOptBST</span><span class="params">(<span class="keyword">double</span>[] p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = p.length; <span class="comment">//序列长度</span></span><br><span class="line">        Result r = <span class="keyword">new</span> Result(n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从i到i的最小代价(找到的概率)就是找到i的代价(概率)</span></span><br><span class="line">            r.result[i][i] = p[i];</span><br><span class="line">            r.root[i][i] = i; <span class="comment">//只有一个结点时，最优二叉搜索树就是它本身</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m++) <span class="comment">//m代表二叉树的长度(所有结点的个数)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - m; i++) <span class="comment">//i为二叉树左起点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + m; <span class="comment">//j为二叉树的右终点</span></span><br><span class="line">                <span class="keyword">double</span> min = <span class="number">1000000</span>; <span class="comment">//该变量存储最小代价</span></span><br><span class="line">                <span class="keyword">int</span> tr = <span class="number">0</span>; <span class="comment">//tr: temp root，临时变量，表示根节点</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//求取最小值并记录根所在位置</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//用r1表示result[i,k-1]，r2表示result[k+1,j]</span></span><br><span class="line">                    <span class="keyword">double</span> r1 = <span class="number">0</span>, r2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i &lt; k)</span><br><span class="line">                        r1 = r.result[i][k - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(k &lt; j)</span><br><span class="line">                        r2 = r.result[k + <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(min &gt; r1 + r2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        min = r1 + r2;</span><br><span class="line">                        tr = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.root[i][j] = tr;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s = i; s &lt;= j; s++)</span><br><span class="line">                    sum += p[s];</span><br><span class="line">                r.result[i][j] = min + sum; <span class="comment">//递推公式体现在这里</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> //存储结果的类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[][] result; <span class="comment">//存储代价</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] root; <span class="comment">//存储构造路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result = <span class="keyword">new</span> <span class="keyword">double</span>[n][n];</span><br><span class="line">        root = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a class="header-anchor" href="#运行结果">¶</a>运行结果</h6><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：动态规划&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;实际问题：最优二叉搜索树&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="xWenChen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="xWenChen.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-最长公共子序列</title>
    <link href="xWenChen.github.io/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>xWenChen.github.io/算法/动态规划-最长公共子序列/</id>
    <published>2018-09-29T12:54:11.000Z</published>
    <updated>2023-01-18T15:08:07.453Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：动态规划</strong><br><strong>实际问题：最长公共子序列</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h6><p>子序列：是一个给定序列的子序列是在该序列中删去若干元素后得到的序列。如X={A, B, C, D}, {A, C}是X的子序列，{A, B, D}是X的子序列。</p><p>问题描述：给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列，X和Y的所有公共子序列中长度最长的即是X和Y的最长公共子序列。</p><p>值得一提的是，最长公共子序列不只一个，但构造的时候只能构造出一个。</p><h6 id="关键特征"><a class="header-anchor" href="#关键特征">¶</a>关键特征</h6><p>设序列X={x1, x2, x3, …, xm}和Y={y1, y2, y3, …, yn}的最长公共子序列为Z={z1, z2, z3, …, zk}，则：</p><ol><li>若xm=yn, 则zk=xm=yn, 且Zk-1是Xm-1和Yn-1的最长公共子序列</li><li>若xm!=yn, 且zk!=xm, 则Z是Xm-1和Y的最长公共子序列</li><li>若xm!=yn, 且zk!=yn, 则Z是X和Yn-1的最长公共子序列</li></ol><p>其中：Xm-1={x1, x2, …, xm-1}，Yn-1={y1, y2, …, yn-1}，Zk-1={z1, z2, …, zk-1}。</p><h6 id="递归结构"><a class="header-anchor" href="#递归结构">¶</a>递归结构</h6><p>用c[i][j]记录序列Xi和Yj的最长公共子序列长度，那么：</p><ol><li>当i=0, j=0时，c[i][j]=0</li><li>当i&gt;0, j&gt;0, xi=yj时，c[i][j] = c[i-1][j-1]+1</li><li>当i&gt;0, j&gt;0,xi!=yj时，c[i][j] = max{c[i][j-1], c[i-1][j]}</li></ol><p>其中，第3点是说当xm!=yn时，求取Xm-1, Y和X, Yn-1两者的最长公共子序列的较长者作为整体的最长公共子序列</p><h6 id="java代码"><a class="header-anchor" href="#java代码">¶</a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestCommonSubsequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//第一个字符留空，可以省去后续很多麻烦</span></span><br><span class="line">        <span class="keyword">char</span>[] x = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">' '</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'B'</span>, <span class="string">'D'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] y = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">' '</span>, <span class="string">'B'</span>, <span class="string">'D'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = x.length;</span><br><span class="line">        <span class="keyword">int</span> n = y.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span>[][] b = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        lcsLength(m - <span class="number">1</span>, n - <span class="number">1</span>, x, y, c, b);</span><br><span class="line">        lcs(m - <span class="number">1</span>, n - <span class="number">1</span>, x, b); <span class="comment">//从m-1，n-1开始往下面找</span></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 参数含义：</span></span><br><span class="line"><span class="comment">      * m: X序列的长度</span></span><br><span class="line"><span class="comment">      * n: Y序列的长度</span></span><br><span class="line"><span class="comment">      * x, y: 待求最长公共子序列的原始序列</span></span><br><span class="line"><span class="comment">      * c: 记录Xi和Yj的最长公共子序列长度</span></span><br><span class="line"><span class="comment">      * b: 记录得到c[i][j]的是哪个子问题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lcsLength</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">char</span>[] x, <span class="keyword">char</span>[] y, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] c, <span class="keyword">int</span>[][] b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            c[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            c[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x[i] == y[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    b[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(c[i-<span class="number">1</span>][j] &gt; c[i][j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    c[i][j] = c[i - <span class="number">1</span>][j];</span><br><span class="line">                    b[i][j] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    c[i][j] = c[i][j - <span class="number">1</span>];</span><br><span class="line">                    b[i][j] = <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 该方法构造一个X，Y的最长公共子序列</span></span><br><span class="line"><span class="comment">      * 参数含义：</span></span><br><span class="line"><span class="comment">      * i, j: 序列X, Y的下标</span></span><br><span class="line"><span class="comment">      * x: 原始序列，因为构造的是X, Y的最长公共子序列。</span></span><br><span class="line"><span class="comment">      *     此处用Y也行，因为x有的y也有。</span></span><br><span class="line"><span class="comment">      *     但是序列应全程保持一致(一开始用X，整个函数都用X)</span></span><br><span class="line"><span class="comment">      * b: 用于构造子序列的二维数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lcs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] x, <span class="keyword">int</span>[][] b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(b[i][j] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lcs(i - <span class="number">1</span>, j - <span class="number">1</span>, x, b);</span><br><span class="line">            System.out.print(x[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b[i][j] == <span class="number">2</span>)</span><br><span class="line">            lcs(i - <span class="number">1</span>, j, x, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lcs(i, j - <span class="number">1</span>, x, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a class="header-anchor" href="#运行结果">¶</a>运行结果</h6><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：动态规划&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;实际问题：最长公共子序列&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="xWenChen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="xWenChen.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-01背包问题</title>
    <link href="xWenChen.github.io/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>xWenChen.github.io/算法/动态规划-01背包问题/</id>
    <published>2018-09-29T12:46:20.000Z</published>
    <updated>2023-01-18T15:08:07.452Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：动态规划</strong><br><strong>实际问题：01背包问题</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h6><p>给定n种物品和一个背包，物品i的重量为wi，其价值是vi，背包的容量为c，问应如何向背包装入物品，使得背包中的物品价值最大。每个物品拿取或者不拿两种选择。不能选择装入某物品的一部分，也不能装入同一物品多次。</p><h6 id="递归结构"><a class="header-anchor" href="#递归结构">¶</a>递归结构</h6><p>声明一个大小为m[n][c]的二维数组，m[i][j]表示在面对第i件物品，且背包容量为j时所能获得的最大价值。则：</p><ol><li>m[i][j]=m[i-1][j]，j&lt;w[i]。其表示：背包容量不足以放下第i件物品，只能选择不拿。</li><li>m[i][j]=max{m[i-1][j],  m[i-1][j-wi]+vi}，j&gt;=w[i]。其表示：这时背包容量可以放下第i件物品，我们就要考虑拿这件物品是否能获取更大的价值。前者表示不装第i件物品的最大价值，后者表示装了第i件物品的最大价值，并为第i件物品预留了wi的容量。</li></ol><h6 id="java代码"><a class="header-anchor" href="#java代码">¶</a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneZeroKnapsackProblem</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//以下数组第0位(第0行，第0列)都不存储数据</span></span><br><span class="line">        <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>&#125;; <span class="comment">//每件物品的价值</span></span><br><span class="line">        <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>&#125;; <span class="comment">//每件物品的重量</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">12</span>; <span class="comment">//背包的容量</span></span><br><span class="line">        <span class="keyword">int</span> n = v.length - <span class="number">1</span>; <span class="comment">//物品的数量</span></span><br><span class="line">        <span class="keyword">int</span>[][] m = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][c + <span class="number">1</span>]; <span class="comment">//总价值数组</span></span><br><span class="line">        <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; <span class="comment">//构造最优解的数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= c; j++)</span><br><span class="line">                m[i][j] = <span class="number">0</span>;</span><br><span class="line">            r[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        knapsack(v, w, c, n, m);</span><br><span class="line">        traceback(m, w, c, n, r);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"物品数量为 "</span> + n + <span class="string">" ，背包容量为 "</span> + c);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"各个物品的价值为："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(v[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"各个物品的重量为："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(w[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"最多价值为："</span> + m[n][c]);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"放入的物品为："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            System.out.print(r[i] + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 该方法计算最优解：</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> v 存储每个物品的价值</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> w 存储每个物品的重量</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> c 存储背包容量</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> n 物品数量</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> m 存储构造的最优解</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] v, <span class="keyword">int</span>[] w, <span class="keyword">int</span> c, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//物品从第1件物品开始计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= w[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j] = max(m[i - <span class="number">1</span>][j], m[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j] = m[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 该方法构造最优解的生成过程：</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> m 存储最优解的数组</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> w 存储每个物品的重量</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> c 存储背包容量</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> n 物品数量</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> x 存储最优解生成过程的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceback</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span>[] w, <span class="keyword">int</span> c, <span class="keyword">int</span> n, <span class="keyword">int</span>[] x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m[i][c] == m[i - <span class="number">1</span>][c]) <span class="comment">//第i件物品为未放入</span></span><br><span class="line">            &#123;</span><br><span class="line">                x[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//第i件放入</span></span><br><span class="line">            &#123;</span><br><span class="line">                x[i] = <span class="number">1</span>;</span><br><span class="line">                c -= w[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a class="header-anchor" href="#运行结果">¶</a>运行结果</h6><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：动态规划&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;实际问题：01背包问题&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="xWenChen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="xWenChen.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-多边形游戏</title>
    <link href="xWenChen.github.io/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%B8%B8%E6%88%8F/"/>
    <id>xWenChen.github.io/算法/动态规划-多边形游戏/</id>
    <published>2018-09-29T11:43:11.000Z</published>
    <updated>2023-01-18T15:08:07.452Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：动态规划</strong><br><strong>实际问题：多边形游戏</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h6><p><strong>多边形游戏问题</strong>是<strong>矩阵连乘的最优计算次序问题</strong>与<strong>凸多边形最优三角剖分问题</strong>的推广。我在解决<strong>凸多边形最优三角剖分问题</strong>时偶然间看到了这个结论，便跳过了该问题，直接解决其推广的问题，即多边形游戏问题。对于<strong>凸多边形最优三角剖分问题</strong>有兴趣的读者，可以自行百度。</p><h6 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h6><p>有一个由n个顶点构成的多边形。每个顶点被赋予一个整数值，每条边被赋予一个运算符。每条边被赋予一个运算符+或*。所有边依次用整数1到n编号。<br>游戏规则：</p><ol><li>删去一条边</li><li>后续步骤按以下方式操作：</li></ol><ul><li>选择一条边E及边E的两个顶点v1和v2</li><li>用一个新的顶点v取代边E及由E连接着的2个顶点，将2个顶点上的数值由E上的运算符获得结果，病赋值给新的顶点v。最后，所有的边都被删除，游戏结束，得到游戏分数(最后顶点上的整数值)</li></ul><p>问题：对于给定的多边形，计算最高得分</p><h6 id="关键特征"><a class="header-anchor" href="#关键特征">¶</a>关键特征</h6><p>设给定的多边形的顶点和边的顺时针序列为 op[1], v[1], op[2], v[2], …, op[n], v[n]。其中 op[i] 表示第 i  边所对应的运算符，v[i] 表示第 i 个顶点上的数值，1 &lt;= i &lt;= n。</p><p>在所给定的多边形中，从顶点 i 开始，长度为 j(链中有 j 个顶点) 的顺时针链 p(i, j) 可表示为 v[i], op[i + 1], …, v[i + j - 1]。如果这条链的最后一次合并运算发生在 op[i + s] 处，则可在 op[i + s] 处将链分为两个子链 p(i, s) 和 p(i + s, j - s)。</p><p>设 m1 是子链 p(i, s) 内部合并得到的值，设 a 和 b 是子链 p(i, s) 内部合并可能得到的最小值和最大值；设 m2 是子链  p(i + s, j - s) 内部合并得到的值，设 c 和 d 是子链 p(i + s, j - s) 内部合并可能得到的最小值和最大值。则有：a &lt;= m1 &lt;= b, c &lt;= m2 &lt;= d。而两个子链合并得到的结果 m = (m1)op<a href="m2">i + s</a>。分析运算符的情况可得：</p><ol><li>当op[i + s] = '+'时，显然有 a + c &lt;= m &lt;= b + d。即链 p(i, j) 合并的最优性可由子链 p(i, s) 和 p(i + s, j - s) 的最优性推出。且最大值对应子链的最大值，最小值对应子链的最小值。</li><li>当op[i + s] = '*'时，考虑到 v[i] 可以取负整数，显然有 min{ac, ad, bc, bd} &lt;= m &lt;= max{ac, ad, bc, bd}，亦可由子链的最有性推出原链的最优性。</li></ol><p>综上，可得多边形游戏问题满足最优子结构性质</p><h6 id="递归结构"><a class="header-anchor" href="#递归结构">¶</a>递归结构</h6><p>设 m[i, j, 0] 是链 p(i, j) 合并的最小值，m[i, j, 1] 是链 p(i, j) 合并的最大值，并设最优合并在 op[i+s] 处，为方便起见，记：a=m[i, i+s, 0], b=m[i, i+s, 1], c=m[i+s, j-s, 0], d=[i+s, j-s, 1]，则关系式满足：</p><ul><li>当 op[i+s]=’+’, min(i, j, s) = a+c, max(i, j, s) = b+d</li><li>当 op[i+s]=’*’, min(i, j, s) = min(ac, ad, bc, bd), max(i, j, s) = max(ac, ad, bc, bd)</li></ul><p>由此可知 m[i, j, 0]=min(min(i, j, s)), m[i, j, 1]=max(max(i, j, s))，其中 1 &lt;= s &lt;= j - 1，这是个循环求值的过程。</p><h6 id="java代码"><a class="header-anchor" href="#java代码">¶</a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本代码所用示例为：+ -7 + 4 * 2 * 5</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolygonGame</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n; <span class="comment">//边和点个数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> minf, maxf;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] v; <span class="comment">//点集</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span>[] op; <span class="comment">//边集</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][][] m; <span class="comment">//存储最终计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//以下所有数组下标为0的都不使用</span></span><br><span class="line">        <span class="comment">//构造出的多边形的最终结果：+ -7 + 4 * 2 * 5</span></span><br><span class="line">        v = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;Integer.MIN_VALUE, -<span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        op = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">' '</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'*'</span>, <span class="string">'*'</span>&#125;;</span><br><span class="line">        m = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//m[i][j][0]：表示链的起点为i，长度为j时的结果最小值</span></span><br><span class="line">            m[i][<span class="number">1</span>][<span class="number">0</span>] = v[i];</span><br><span class="line">            <span class="comment">//m[i][j][1]：表示链的起点为i，长度为j时的结果最大值</span></span><br><span class="line">            m[i][<span class="number">1</span>][<span class="number">1</span>] = v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = polyMax();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 参数含义：</span></span><br><span class="line"><span class="comment">      * i：链的起点</span></span><br><span class="line"><span class="comment">      * s：断开位置</span></span><br><span class="line"><span class="comment">      * j：链长度</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minMax</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> s,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] e = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> a = m[i][s][<span class="number">0</span>],</span><br><span class="line">            b = m[i][s][<span class="number">1</span>],</span><br><span class="line">            r = (i + s - <span class="number">1</span>) % n + <span class="number">1</span>, <span class="comment">//多边形是封闭的，不能出现下标溢出</span></span><br><span class="line">            c = m[r][j - s][<span class="number">0</span>],</span><br><span class="line">            d = m[r][j - s][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(op[r] == <span class="string">'+'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            minf = a + c;</span><br><span class="line">            maxf = b + d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            e[<span class="number">1</span>] = a * c;</span><br><span class="line">            e[<span class="number">2</span>] = a * d;</span><br><span class="line">            e[<span class="number">3</span>] = b * c;</span><br><span class="line">            e[<span class="number">4</span>] = b * d;</span><br><span class="line">            minf = e[<span class="number">1</span>];</span><br><span class="line">            maxf = e[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; <span class="number">5</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(minf &gt; e[k])</span><br><span class="line">                    minf = e[k];</span><br><span class="line">                <span class="keyword">if</span>(maxf &lt; e[k])</span><br><span class="line">                    maxf = e[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">polyMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++) <span class="comment">//链的长度</span></span><br><span class="line">            <span class="comment">//链的起点，多边形是封闭的，不会存在什么问题</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; j; s++) <span class="comment">//断开的位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    minMax(i, s, j);</span><br><span class="line">                    <span class="keyword">if</span>(m[i][j][<span class="number">0</span>] &gt; minf)</span><br><span class="line">                        m[i][j][<span class="number">0</span>] = minf;</span><br><span class="line">                    <span class="keyword">if</span>(m[i][j][<span class="number">1</span>] &lt; maxf)</span><br><span class="line">                        m[i][j][<span class="number">1</span>] = maxf;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = m[<span class="number">1</span>][n][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span>(temp &lt; m[i][n][<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = m[i][n][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a class="header-anchor" href="#运行结果">¶</a>运行结果</h6><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%B8%B8%E6%88%8F.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：动态规划&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;实际问题：多边形游戏&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="xWenChen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="xWenChen.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-最大子段和</title>
    <link href="xWenChen.github.io/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/"/>
    <id>xWenChen.github.io/算法/动态规划-最大子段和/</id>
    <published>2018-09-29T02:38:20.000Z</published>
    <updated>2023-01-18T15:08:07.453Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：动态规划</strong><br><strong>实际问题：最大子段和</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="前言"><a class="header-anchor" href="#前言">¶</a>前言</h6><p>最大子段和有多种解法，暴力破解法是最简单的，但时间复杂度较高，最少需要 O(n^2)，未改进的算法为 O(n^3)；而且暴力破解这种思路对学习算法是没有帮助的。因此个人并未实现。仅对分治法和动态规划两种思路进行了实现。分治法的解决思路详见**<a href="/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C">分治法-最大子段和</a>**，分治法解决最大子段和问题需要的时间复杂度为 O(nlogn)，而本篇博文是采用动态规划的思路，动态规划解决最大子段和问题需要的时间复杂度为 O(n)。是最好的一种解决办法。</p><h6 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h6><p>给定n个整数（可能为负数）组成的序列 a[1],a[2],a[3],…,a[n], 求该序列如 a[i]+a[i+1]+…+a[j] 的子段和的最大值。当所给的整数均为负数时定义子段和为0，依此定义，所求的最优值为： Max{0,a[i]+a[i+1]+…+a[j]}, 1&lt;=i&lt;=j&lt;=n 例如，当（a[1],a[2],a[3],a[4],a[5],a[6]）=(-2,11,-4,13,-5,-2) 时，最大子段和为20。</p><h6 id="递归结构"><a class="header-anchor" href="#递归结构">¶</a>递归结构</h6><p>设 b[j] 存储的是 A[i:j] 的最大字段和，其中 1 &lt;= i &lt;= j，再定义一个 sum 存储最终结果，那么：</p><ol><li>当 b[j - 1] &lt;= 0，b[j] = a[j]，即当目前子序列 A[i:j - 1] 的和为负数时，给和不停的赋新值，直到和为正。</li><li>当 b[j - 1] &gt; 0，b[j] = b[j - 1] + a[j]，即当目前子序列 A[i:j - 1] 的和为正时，加上子序列中的下一个数，得到一个新的和 b[j]。</li><li>将 b[j] 和 sum 比较，若 b[j] &gt; sum，那么给 sum 赋新值  b[j]；若 b[j] &lt; sum，俺么保持 sum 值不变。通过这种方式来保持 sum 为子序列的最大值。</li></ol><h6 id="java代码"><a class="header-anchor" href="#java代码">¶</a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxSubsequenceSum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">2</span>, <span class="number">11</span>, -<span class="number">4</span>, <span class="number">13</span>, -<span class="number">5</span>, -<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result = maxSubSum(a);</span><br><span class="line">        System.out.println(<span class="string">"maxSubSum(a) = "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSum</span><span class="params">(<span class="keyword">int</span>[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b &gt; <span class="number">0</span>)</span><br><span class="line">                b += a[i];</span><br><span class="line">            <span class="comment">//当 b &lt;= 0 时，不断赋新值，相当于跳过了负数</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b = a[i];</span><br><span class="line">            <span class="keyword">if</span>(b &gt; sum)</span><br><span class="line">                sum = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a class="header-anchor" href="#运行结果">¶</a>运行结果</h6><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：动态规划&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;实际问题：最大子段和&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="xWenChen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="xWenChen.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-硬币问题</title>
    <link href="xWenChen.github.io/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98/"/>
    <id>xWenChen.github.io/算法/动态规划-硬币问题/</id>
    <published>2018-09-29T01:57:57.000Z</published>
    <updated>2023-01-18T15:08:07.454Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：动态规划</strong><br><strong>实际问题：硬币问题</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="问题描述"><a class="header-anchor" href="#问题描述">¶</a>问题描述</h6><p>假设有 1 元，3 元，5 元的硬币若干（无限），现在需要凑出 n 元。问如何组合才能使硬币的数量最少？</p><h6 id="关键特征"><a class="header-anchor" href="#关键特征">¶</a>关键特征</h6><p>要推出问题的关键特征与递归关系，必要的例子是少不了的。</p><p>我们先假设一个函数 d(i) 来表示需要凑出 i 的总价值需要的最少硬币数量，那么：</p><ol><li>当 i = 0 时，很显然我们可以知道 d(0) = 0。因为不要凑钱了嘛，当然也不需要任何硬币了。注意这是很重要的一步，其后所有的结果都从这一步延伸开来。</li><li>当 i = 1 时，因为我们有 1 元的硬币，所以直接在第 1 步的基础上，加上 1 个 1 元硬币，得出 d(1) = 1。</li><li>当 i = 2 时，因为我们并没有 2 元的硬币，所以只能拿 1 元的硬币来凑。在第 2 步的基础上，加上 1 个 1 元硬币，得出 d(2) = 2。</li><li>当 i = 3 时，我们可以在第 3 步的基础上加上 1 个 1 元硬币，得到 3 这个结果。但其实我们有 3 元硬币，所以这一步的最优结果不是建立在第 3 步的结果上得来的，而是应该建立在第 1 步上，加上 1 个 3 元硬币，得到 d(3) = 1。</li><li>接着就不再举例了，推导过程和上面一样。</li></ol><h6 id="递归结构"><a class="header-anchor" href="#递归结构">¶</a>递归结构</h6><p>我们来分析一下上述过程。可以看出，除了第 1 步这个看似基本的公理外，其他往后的结果都是建立在它之前得到的某一步的最优解上，加上 1 个硬币得到。即：d(i) = d(j) + 1，此处 j &lt; i，但是在上述例子中我们发现 i = 3 时，有两个解，但我们选择了第二个解，即：** d(i) = min(d(j) + 1) **</p><p>有了结构，思路就清晰了，代码写起来也就很方便了。</p><h6 id="java代码"><a class="header-anchor" href="#java代码">¶</a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下例子中 n 的数值取 11</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoinProblem</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;; <span class="comment">//硬币的面值</span></span><br><span class="line">        <span class="keyword">int</span> money = <span class="number">11</span>; <span class="comment">//待求取的目标数额</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = getLeastCoins(coins, money);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"硬币的面值为："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(coins[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"要凑齐数额 "</span> + i + <span class="string">" 最少需要 "</span> </span><br><span class="line">                + result[i] + <span class="string">" 个硬币"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * param coins 存储硬币面值的数组</span></span><br><span class="line"><span class="comment">      * param money 待求取的目标数额</span></span><br><span class="line"><span class="comment">      * return result 存储各个数额所需最少硬币的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getLeastCoins(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> money)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[money + <span class="number">1</span>];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//数额0只需0个便可凑齐</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; result.length; i++)</span><br><span class="line">            result[i] = <span class="number">10000</span>; <span class="comment">//初始化时各个数额需要最大上限个硬币</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= money; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(coin &lt;= i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> min = <span class="number">10000</span>; <span class="comment">//存储中间结果的变量，初始化为最大硬币上限</span></span><br><span class="line">                    min = result[i - coin] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(result[i] &gt; min)</span><br><span class="line">                        result[i] = min;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a class="header-anchor" href="#运行结果">¶</a>运行结果</h6><p><img src="/images/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：动态规划&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;实际问题：硬币问题&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="xWenChen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="xWenChen.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
</feed>
