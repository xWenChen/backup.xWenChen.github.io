<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>个人博客，使用 Hexo+Github 搭建</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wersong.cn/"/>
  <updated>2018-09-29T13:12:40.037Z</updated>
  <id>http://www.wersong.cn/</id>
  
  <author>
    <name>Wersong Zhang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划-最优二叉搜索树</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://www.wersong.cn/算法/动态规划-最优二叉搜索树/</id>
    <published>2018-09-29T13:06:10.000Z</published>
    <updated>2018-09-29T13:12:40.037Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：动态规划</strong><br><strong>实际问题：最优二叉搜索树</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h6><p>二叉搜索树的定义：<br>满足以下任意两个条件的一个，就可称这棵树为二叉搜索树：</p><ol><li>它是一棵空树</li><li>该树是一颗二叉树，非空，且满足下列两个条件：</li></ol><ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值<br>即当该二叉树非空时，使用中序遍历可以得到一个递增的有序序列</li></ul><p>值得注意的是：</p><ol><li>二叉搜索树的左右子树也是二叉搜索树，我们因此可以使用递归手段来构造二叉搜索树</li><li>一个有序序列的二叉搜索树不只一棵，这就为我们寻找最优二叉搜索树提供了可能</li></ol><p>最优二叉搜索树指的是在一个序列的所有二叉搜索树中花费代价最小的那棵。</p><h6 id="递归结构"><a href="#递归结构" class="headerlink" title="递归结构"></a>递归结构</h6><p>用C[i , j]表示从 i 到 j 的最优二叉查找树的代价，假设有n个顶点，那么我们的目标是要求C[1 , n]从 i 到 j 的一个最优二叉查找树是怎么得到的？它是从 i 到 j 之间的顶点中选出一个顶点来做root，假设选出的这个做root的顶点是 k （i &lt;= k &lt;= j）, 那么显然有：</p><ul><li>C[i , j] = min(C[i, k - 1] + C[k + 1, j]) + Sum(pi, pj)，其中：1 &lt;= i &lt;= j &lt;= n，i &lt;= k &lt;= j，pi表示遍历第i个结点的代价，Sum(pi, pj)表示求第i个结点到第j个结点的代价总和</li></ul><p>上述求和公式最后为什么还要加一个求和结果呢？因为可以理解为公式前半部分只是找出最短路径，最后求和才是加上权重(网上有更详细更严谨的推导过程，可自行百度)</p><h6 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptBST</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span>[] p = <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;<span class="number">0.1</span>, <span class="number">0.15</span>, <span class="number">0.2</span>, <span class="number">0.35</span>, <span class="number">0.2</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        Result r = getOptBST(p);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.result.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; r.result.length; j++)</span><br><span class="line">            System.out.print(r.root[i][j] + <span class="string">"  "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 构造最优二叉搜索树的方法</span></span><br><span class="line"><span class="comment">      * param p: 中序序列的点的查找概率数组，返回最优的二叉查找树的代价</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">getOptBST</span><span class="params">(<span class="keyword">double</span>[] p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = p.length; <span class="comment">//序列长度</span></span><br><span class="line">        Result r = <span class="keyword">new</span> Result(n);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//从i到i的最小代价(找到的概率)就是找到i的代价(概率)</span></span><br><span class="line">            r.result[i][i] = p[i];</span><br><span class="line">            r.root[i][i] = i; <span class="comment">//只有一个结点时，最优二叉搜索树就是它本身</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="number">1</span>; m &lt; n; m++) <span class="comment">//m代表二叉树的长度(所有结点的个数)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - m; i++) <span class="comment">//i为二叉树左起点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> j = i + m; <span class="comment">//j为二叉树的右终点</span></span><br><span class="line">                <span class="keyword">double</span> min = <span class="number">1000000</span>; <span class="comment">//该变量存储最小代价</span></span><br><span class="line">                <span class="keyword">int</span> tr = <span class="number">0</span>; <span class="comment">//tr: temp root，临时变量，表示根节点</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//求取最小值并记录根所在位置</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = i; k &lt;= j; k++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//用r1表示result[i,k-1]，r2表示result[k+1,j]</span></span><br><span class="line">                    <span class="keyword">double</span> r1 = <span class="number">0</span>, r2 = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">if</span>(i &lt; k)</span><br><span class="line">                        r1 = r.result[i][k - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(k &lt; j)</span><br><span class="line">                        r2 = r.result[k + <span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(min &gt; r1 + r2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        min = r1 + r2;</span><br><span class="line">                        tr = k;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                r.root[i][j] = tr;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s = i; s &lt;= j; s++)</span><br><span class="line">                    sum += p[s];</span><br><span class="line">                r.result[i][j] = min + sum; <span class="comment">//递推公式体现在这里</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Result</span> //存储结果的类</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span>[][] result; <span class="comment">//存储代价</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] root; <span class="comment">//存储构造路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Result</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result = <span class="keyword">new</span> <span class="keyword">double</span>[n][n];</span><br><span class="line">        root = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/动态规划-最优二叉搜索树.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：动态规划&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;实际问题：最优二叉搜索树&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://www.wersong.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-最长公共子序列</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://www.wersong.cn/算法/动态规划-最长公共子序列/</id>
    <published>2018-09-29T12:54:11.000Z</published>
    <updated>2018-09-29T13:04:11.757Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：动态规划</strong><br><strong>实际问题：最长公共子序列</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h6><p>子序列：是一个给定序列的子序列是在该序列中删去若干元素后得到的序列。如X={A, B, C, D}, {A, C}是X的子序列，{A, B, D}是X的子序列。</p><p>问题描述：给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列，X和Y的所有公共子序列中长度最长的即是X和Y的最长公共子序列。</p><p>值得一提的是，最长公共子序列不只一个，但构造的时候只能构造出一个。</p><h6 id="关键特征"><a href="#关键特征" class="headerlink" title="关键特征"></a>关键特征</h6><p>设序列X={x1, x2, x3, …, xm}和Y={y1, y2, y3, …, yn}的最长公共子序列为Z={z1, z2, z3, …, zk}，则：</p><ol><li>若xm=yn, 则zk=xm=yn, 且Zk-1是Xm-1和Yn-1的最长公共子序列</li><li>若xm!=yn, 且zk!=xm, 则Z是Xm-1和Y的最长公共子序列</li><li>若xm!=yn, 且zk!=yn, 则Z是X和Yn-1的最长公共子序列</li></ol><p>其中：Xm-1={x1, x2, …, xm-1}，Yn-1={y1, y2, …, yn-1}，Zk-1={z1, z2, …, zk-1}。</p><h6 id="递归结构"><a href="#递归结构" class="headerlink" title="递归结构"></a>递归结构</h6><p>用c[i][j]记录序列Xi和Yj的最长公共子序列长度，那么：</p><ol><li>当i=0, j=0时，c[i][j]=0</li><li>当i&gt;0, j&gt;0, xi=yj时，c[i][j] = c[i-1][j-1]+1</li><li>当i&gt;0, j&gt;0,xi!=yj时，c[i][j] = max{c[i][j-1], c[i-1][j]}</li></ol><p>其中，第3点是说当xm!=yn时，求取Xm-1, Y和X, Yn-1两者的最长公共子序列的较长者作为整体的最长公共子序列</p><h6 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongestCommonSubsequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//第一个字符留空，可以省去后续很多麻烦</span></span><br><span class="line">        <span class="keyword">char</span>[] x = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">' '</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'B'</span>, <span class="string">'D'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>&#125;;</span><br><span class="line">        <span class="keyword">char</span>[] y = <span class="keyword">new</span> <span class="keyword">char</span>[]&#123;<span class="string">' '</span>, <span class="string">'B'</span>, <span class="string">'D'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'A'</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> m = x.length;</span><br><span class="line">        <span class="keyword">int</span> n = y.length;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[][] c = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span>[][] b = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        lcsLength(m - <span class="number">1</span>, n - <span class="number">1</span>, x, y, c, b);</span><br><span class="line">        lcs(m - <span class="number">1</span>, n - <span class="number">1</span>, x, b); <span class="comment">//从m-1，n-1开始往下面找</span></span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 参数含义：</span></span><br><span class="line"><span class="comment">      * m: X序列的长度</span></span><br><span class="line"><span class="comment">      * n: Y序列的长度</span></span><br><span class="line"><span class="comment">      * x, y: 待求最长公共子序列的原始序列</span></span><br><span class="line"><span class="comment">      * c: 记录Xi和Yj的最长公共子序列长度</span></span><br><span class="line"><span class="comment">      * b: 记录得到c[i][j]的是哪个子问题</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lcsLength</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">char</span>[] x, <span class="keyword">char</span>[] y, </span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[][] c, <span class="keyword">int</span>[][] b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">            c[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            c[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(x[i] == y[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    c[i][j] = c[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    b[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(c[i-<span class="number">1</span>][j] &gt; c[i][j - <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    c[i][j] = c[i - <span class="number">1</span>][j];</span><br><span class="line">                    b[i][j] = <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    c[i][j] = c[i][j - <span class="number">1</span>];</span><br><span class="line">                    b[i][j] = <span class="number">3</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 该方法构造一个X，Y的最长公共子序列</span></span><br><span class="line"><span class="comment">      * 参数含义：</span></span><br><span class="line"><span class="comment">      * i, j: 序列X, Y的下标</span></span><br><span class="line"><span class="comment">      * x: 原始序列，因为构造的是X, Y的最长公共子序列。</span></span><br><span class="line"><span class="comment">      *     此处用Y也行，因为x有的y也有。</span></span><br><span class="line"><span class="comment">      *     但是序列应全程保持一致(一开始用X，整个函数都用X)</span></span><br><span class="line"><span class="comment">      * b: 用于构造子序列的二维数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lcs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[] x, <span class="keyword">int</span>[][] b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(b[i][j] == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            lcs(i - <span class="number">1</span>, j - <span class="number">1</span>, x, b);</span><br><span class="line">            System.out.print(x[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(b[i][j] == <span class="number">2</span>)</span><br><span class="line">            lcs(i - <span class="number">1</span>, j, x, b);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lcs(i, j - <span class="number">1</span>, x, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/动态规划-最长公共子序列.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：动态规划&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;实际问题：最长公共子序列&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://www.wersong.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-01背包问题</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://www.wersong.cn/算法/动态规划-01背包问题/</id>
    <published>2018-09-29T12:46:20.000Z</published>
    <updated>2018-09-29T12:51:17.032Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：动态规划</strong><br><strong>实际问题：01背包问题</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h6><p>给定n种物品和一个背包，物品i的重量为wi，其价值是vi，背包的容量为c，问应如何向背包装入物品，使得背包中的物品价值最大。每个物品拿取或者不拿两种选择。不能选择装入某物品的一部分，也不能装入同一物品多次。</p><h6 id="递归结构"><a href="#递归结构" class="headerlink" title="递归结构"></a>递归结构</h6><p>声明一个大小为m[n][c]的二维数组，m[i][j]表示在面对第i件物品，且背包容量为j时所能获得的最大价值。则：</p><ol><li>m[i][j]=m[i-1][j]，j&lt;w[i]。其表示：背包容量不足以放下第i件物品，只能选择不拿。</li><li>m[i][j]=max{m[i-1][j],  m[i-1][j-wi]+vi}，j&gt;=w[i]。其表示：这时背包容量可以放下第i件物品，我们就要考虑拿这件物品是否能获取更大的价值。前者表示不装第i件物品的最大价值，后者表示装了第i件物品的最大价值，并为第i件物品预留了wi的容量。</li></ol><h6 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneZeroKnapsackProblem</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//以下数组第0位(第0行，第0列)都不存储数据</span></span><br><span class="line">        <span class="keyword">int</span>[] v = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>&#125;; <span class="comment">//每件物品的价值</span></span><br><span class="line">        <span class="keyword">int</span>[] w = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>&#125;; <span class="comment">//每件物品的重量</span></span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">12</span>; <span class="comment">//背包的容量</span></span><br><span class="line">        <span class="keyword">int</span> n = v.length - <span class="number">1</span>; <span class="comment">//物品的数量</span></span><br><span class="line">        <span class="keyword">int</span>[][] m = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][c + <span class="number">1</span>]; <span class="comment">//总价值数组</span></span><br><span class="line">        <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>]; <span class="comment">//构造最优解的数组</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= c; j++)</span><br><span class="line">                m[i][j] = <span class="number">0</span>;</span><br><span class="line">            r[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        knapsack(v, w, c, n, m);</span><br><span class="line">        traceback(m, w, c, n, r);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"物品数量为 "</span> + n + <span class="string">" ，背包容量为 "</span> + c);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"各个物品的价值为："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(v[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"各个物品的重量为："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(w[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"最多价值为："</span> + m[n][c]);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"放入的物品为："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            System.out.print(r[i] + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 该方法计算最优解：</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> v 存储每个物品的价值</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> w 存储每个物品的重量</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> c 存储背包容量</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> n 物品数量</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> m 存储构造的最优解</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] v, <span class="keyword">int</span>[] w, <span class="keyword">int</span> c, <span class="keyword">int</span> n, <span class="keyword">int</span>[][] m)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//物品从第1件物品开始计算</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= c; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= w[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j] = max(m[i - <span class="number">1</span>][j], m[i - <span class="number">1</span>][j - w[i]] + v[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    m[i][j] = m[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 该方法构造最优解的生成过程：</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> m 存储最优解的数组</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> w 存储每个物品的重量</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> c 存储背包容量</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> n 物品数量</span></span><br><span class="line"><span class="comment">      * <span class="doctag">@param</span> x 存储最优解生成过程的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceback</span><span class="params">(<span class="keyword">int</span>[][] m, <span class="keyword">int</span>[] w, <span class="keyword">int</span> c, <span class="keyword">int</span> n, <span class="keyword">int</span>[] x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(m[i][c] == m[i - <span class="number">1</span>][c]) <span class="comment">//第i件物品为未放入</span></span><br><span class="line">            &#123;</span><br><span class="line">                x[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="comment">//第i件放入</span></span><br><span class="line">            &#123;</span><br><span class="line">                x[i] = <span class="number">1</span>;</span><br><span class="line">                c -= w[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/动态规划-01背包问题.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：动态规划&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;实际问题：01背包问题&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://www.wersong.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-多边形游戏</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%B8%B8%E6%88%8F/"/>
    <id>http://www.wersong.cn/算法/动态规划-多边形游戏/</id>
    <published>2018-09-29T11:43:11.000Z</published>
    <updated>2018-09-29T12:44:13.513Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：动态规划</strong><br><strong>实际问题：多边形游戏</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p><strong>多边形游戏问题</strong>是<strong>矩阵连乘的最优计算次序问题</strong>与<strong>凸多边形最优三角剖分问题</strong>的推广。我在解决<strong>凸多边形最优三角剖分问题</strong>时偶然间看到了这个结论，便跳过了该问题，直接解决其推广的问题，即多边形游戏问题。对于<strong>凸多边形最优三角剖分问题</strong>有兴趣的读者，可以自行百度。</p><h6 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h6><p>有一个由n个顶点构成的多边形。每个顶点被赋予一个整数值，每条边被赋予一个运算符。每条边被赋予一个运算符+或*。所有边依次用整数1到n编号。<br>游戏规则：</p><ol><li>删去一条边</li><li>后续步骤按以下方式操作：</li></ol><ul><li>选择一条边E及边E的两个顶点v1和v2</li><li>用一个新的顶点v取代边E及由E连接着的2个顶点，将2个顶点上的数值由E上的运算符获得结果，病赋值给新的顶点v。最后，所有的边都被删除，游戏结束，得到游戏分数(最后顶点上的整数值)</li></ul><p>问题：对于给定的多边形，计算最高得分</p><h6 id="关键特征"><a href="#关键特征" class="headerlink" title="关键特征"></a>关键特征</h6><p>设给定的多边形的顶点和边的顺时针序列为 op[1], v[1], op[2], v[2], …, op[n], v[n]。其中 op[i] 表示第 i  边所对应的运算符，v[i] 表示第 i 个顶点上的数值，1 &lt;= i &lt;= n。</p><p>在所给定的多边形中，从顶点 i 开始，长度为 j(链中有 j 个顶点) 的顺时针链 p(i, j) 可表示为 v[i], op[i + 1], …, v[i + j - 1]。如果这条链的最后一次合并运算发生在 op[i + s] 处，则可在 op[i + s] 处将链分为两个子链 p(i, s) 和 p(i + s, j - s)。</p><p>设 m1 是子链 p(i, s) 内部合并得到的值，设 a 和 b 是子链 p(i, s) 内部合并可能得到的最小值和最大值；设 m2 是子链  p(i + s, j - s) 内部合并得到的值，设 c 和 d 是子链 p(i + s, j - s) 内部合并可能得到的最小值和最大值。则有：a &lt;= m1 &lt;= b, c &lt;= m2 &lt;= d。而两个子链合并得到的结果 m = (m1)op<a href="m2">i + s</a>。分析运算符的情况可得：</p><ol><li>当op[i + s] = ‘+’时，显然有 a + c &lt;= m &lt;= b + d。即链 p(i, j) 合并的最优性可由子链 p(i, s) 和 p(i + s, j - s) 的最优性推出。且最大值对应子链的最大值，最小值对应子链的最小值。</li><li>当op[i + s] = ‘*’时，考虑到 v[i] 可以取负整数，显然有 min{ac, ad, bc, bd} &lt;= m &lt;= max{ac, ad, bc, bd}，亦可由子链的最有性推出原链的最优性。</li></ol><p>综上，可得多边形游戏问题满足最优子结构性质</p><h6 id="递归结构"><a href="#递归结构" class="headerlink" title="递归结构"></a>递归结构</h6><p>设 m[i, j, 0] 是链 p(i, j) 合并的最小值，m[i, j, 1] 是链 p(i, j) 合并的最大值，并设最优合并在 op[i+s] 处，为方便起见，记：a=m[i, i+s, 0], b=m[i, i+s, 1], c=m[i+s, j-s, 0], d=[i+s, j-s, 1]，则关系式满足：</p><ul><li>当 op[i+s]=’+’, min(i, j, s) = a+c, max(i, j, s) = b+d</li><li>当 op[i+s]=’*’, min(i, j, s) = min(ac, ad, bc, bd), max(i, j, s) = max(ac, ad, bc, bd)</li></ul><p>由此可知 m[i, j, 0]=min(min(i, j, s)), m[i, j, 1]=max(max(i, j, s))，其中 1 &lt;= s &lt;= j - 1，这是个循环求值的过程。</p><h6 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本代码所用示例为：+ -7 + 4 * 2 * 5</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PolygonGame</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> n; <span class="comment">//边和点个数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> minf, maxf;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] v; <span class="comment">//点集</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span>[] op; <span class="comment">//边集</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[][][] m; <span class="comment">//存储最终计算结果</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = <span class="number">4</span>;</span><br><span class="line">        <span class="comment">//以下所有数组下标为0的都不使用</span></span><br><span class="line">        <span class="comment">//构造出的多边形的最终结果：+ -7 + 4 * 2 * 5</span></span><br><span class="line">        v = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;Integer.MIN_VALUE, -<span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        op = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">' '</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'*'</span>, <span class="string">'*'</span>&#125;;</span><br><span class="line">        m = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//m[i][j][0]：表示链的起点为i，长度为j时的结果最小值</span></span><br><span class="line">            m[i][<span class="number">1</span>][<span class="number">0</span>] = v[i];</span><br><span class="line">            <span class="comment">//m[i][j][1]：表示链的起点为i，长度为j时的结果最大值</span></span><br><span class="line">            m[i][<span class="number">1</span>][<span class="number">1</span>] = v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = polyMax();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 参数含义：</span></span><br><span class="line"><span class="comment">      * i：链的起点</span></span><br><span class="line"><span class="comment">      * s：断开位置</span></span><br><span class="line"><span class="comment">      * j：链长度</span></span><br><span class="line"><span class="comment">      *</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">minMax</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> s,<span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] e = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> a = m[i][s][<span class="number">0</span>],</span><br><span class="line">            b = m[i][s][<span class="number">1</span>],</span><br><span class="line">            r = (i + s - <span class="number">1</span>) % n + <span class="number">1</span>, <span class="comment">//多边形是封闭的，不能出现下标溢出</span></span><br><span class="line">            c = m[r][j - s][<span class="number">0</span>],</span><br><span class="line">            d = m[r][j - s][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(op[r] == <span class="string">'+'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            minf = a + c;</span><br><span class="line">            maxf = b + d;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            e[<span class="number">1</span>] = a * c;</span><br><span class="line">            e[<span class="number">2</span>] = a * d;</span><br><span class="line">            e[<span class="number">3</span>] = b * c;</span><br><span class="line">            e[<span class="number">4</span>] = b * d;</span><br><span class="line">            minf = e[<span class="number">1</span>];</span><br><span class="line">            maxf = e[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">2</span>; k &lt; <span class="number">5</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(minf &gt; e[k])</span><br><span class="line">                    minf = e[k];</span><br><span class="line">                <span class="keyword">if</span>(maxf &lt; e[k])</span><br><span class="line">                    maxf = e[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">polyMax</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= n; j++) <span class="comment">//链的长度</span></span><br><span class="line">            <span class="comment">//链的起点，多边形是封闭的，不会存在什么问题</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; j; s++) <span class="comment">//断开的位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    minMax(i, s, j);</span><br><span class="line">                    <span class="keyword">if</span>(m[i][j][<span class="number">0</span>] &gt; minf)</span><br><span class="line">                        m[i][j][<span class="number">0</span>] = minf;</span><br><span class="line">                    <span class="keyword">if</span>(m[i][j][<span class="number">1</span>] &lt; maxf)</span><br><span class="line">                        m[i][j][<span class="number">1</span>] = maxf;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = m[<span class="number">1</span>][n][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            <span class="keyword">if</span>(temp &lt; m[i][n][<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                temp = m[i][n][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/动态规划-多边形游戏.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：动态规划&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;实际问题：多边形游戏&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://www.wersong.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-最大子段和</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/"/>
    <id>http://www.wersong.cn/算法/动态规划-最大子段和/</id>
    <published>2018-09-29T02:38:20.000Z</published>
    <updated>2018-09-29T10:33:24.496Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：动态规划</strong><br><strong>实际问题：最大子段和</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h6><p>最大子段和有多种解法，暴力破解法是最简单的，但时间复杂度较高，最少需要 O(n^2)，未改进的算法为 O(n^3)；而且暴力破解这种思路对学习算法是没有帮助的。因此个人并未实现。仅对分治法和动态规划两种思路进行了实现。分治法的解决思路详见<strong><a href="/算法/分治法-最大子段和">分治法-最大子段和</a></strong>，分治法解决最大子段和问题需要的时间复杂度为 O(nlogn)，而本篇博文是采用动态规划的思路，动态规划解决最大子段和问题需要的时间复杂度为 O(n)。是最好的一种解决办法。</p><h6 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h6><p>给定n个整数（可能为负数）组成的序列 a[1],a[2],a[3],…,a[n], 求该序列如 a[i]+a[i+1]+…+a[j] 的子段和的最大值。当所给的整数均为负数时定义子段和为0，依此定义，所求的最优值为： Max{0,a[i]+a[i+1]+…+a[j]}, 1&lt;=i&lt;=j&lt;=n 例如，当（a[1],a[2],a[3],a[4],a[5],a[6]）=(-2,11,-4,13,-5,-2) 时，最大子段和为20。</p><h6 id="递归结构"><a href="#递归结构" class="headerlink" title="递归结构"></a>递归结构</h6><p>设 b[j] 存储的是 A[i:j] 的最大字段和，其中 1 &lt;= i &lt;= j，再定义一个 sum 存储最终结果，那么：</p><ol><li>当 b[j - 1] &lt;= 0，b[j] = a[j]，即当目前子序列 A[i:j - 1] 的和为负数时，给和不停的赋新值，直到和为正。</li><li>当 b[j - 1] &gt; 0，b[j] = b[j - 1] + a[j]，即当目前子序列 A[i:j - 1] 的和为正时，加上子序列中的下一个数，得到一个新的和 b[j]。</li><li>将 b[j] 和 sum 比较，若 b[j] &gt; sum，那么给 sum 赋新值  b[j]；若 b[j] &lt; sum，俺么保持 sum 值不变。通过这种方式来保持 sum 为子序列的最大值。</li></ol><h6 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxSubsequenceSum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">2</span>, <span class="number">11</span>, -<span class="number">4</span>, <span class="number">13</span>, -<span class="number">5</span>, -<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result = maxSubSum(a);</span><br><span class="line">        System.out.println(<span class="string">"maxSubSum(a) = "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSum</span><span class="params">(<span class="keyword">int</span>[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(b &gt; <span class="number">0</span>)</span><br><span class="line">                b += a[i];</span><br><span class="line">            <span class="comment">//当 b &lt;= 0 时，不断赋新值，相当于跳过了负数</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b = a[i];</span><br><span class="line">            <span class="keyword">if</span>(b &gt; sum)</span><br><span class="line">                sum = b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/动态规划-最大子段和.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：动态规划&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;实际问题：最大子段和&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://www.wersong.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-硬币问题</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98/"/>
    <id>http://www.wersong.cn/算法/动态规划-硬币问题/</id>
    <published>2018-09-29T01:57:57.000Z</published>
    <updated>2018-09-29T02:18:27.172Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：动态规划</strong><br><strong>实际问题：硬币问题</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h6><p>假设有 1 元，3 元，5 元的硬币若干（无限），现在需要凑出 n 元。问如何组合才能使硬币的数量最少？</p><h6 id="关键特征"><a href="#关键特征" class="headerlink" title="关键特征"></a>关键特征</h6><p>要推出问题的关键特征与递归关系，必要的例子是少不了的。</p><p>我们先假设一个函数 d(i) 来表示需要凑出 i 的总价值需要的最少硬币数量，那么：</p><ol><li>当 i = 0 时，很显然我们可以知道 d(0) = 0。因为不要凑钱了嘛，当然也不需要任何硬币了。注意这是很重要的一步，其后所有的结果都从这一步延伸开来。</li><li>当 i = 1 时，因为我们有 1 元的硬币，所以直接在第 1 步的基础上，加上 1 个 1 元硬币，得出 d(1) = 1。</li><li>当 i = 2 时，因为我们并没有 2 元的硬币，所以只能拿 1 元的硬币来凑。在第 2 步的基础上，加上 1 个 1 元硬币，得出 d(2) = 2。</li><li>当 i = 3 时，我们可以在第 3 步的基础上加上 1 个 1 元硬币，得到 3 这个结果。但其实我们有 3 元硬币，所以这一步的最优结果不是建立在第 3 步的结果上得来的，而是应该建立在第 1 步上，加上 1 个 3 元硬币，得到 d(3) = 1。</li><li>接着就不再举例了，推导过程和上面一样。</li></ol><h6 id="递归结构"><a href="#递归结构" class="headerlink" title="递归结构"></a>递归结构</h6><p>我们来分析一下上述过程。可以看出，除了第 1 步这个看似基本的公理外，其他往后的结果都是建立在它之前得到的某一步的最优解上，加上 1 个硬币得到。即：d(i) = d(j) + 1，此处 j &lt; i，但是在上述例子中我们发现 i = 3 时，有两个解，但我们选择了第二个解，即：<strong> d(i) = min(d(j) + 1) </strong></p><p>有了结构，思路就清晰了，代码写起来也就很方便了。</p><h6 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下例子中 n 的数值取 11</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoinProblem</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] coins = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;; <span class="comment">//硬币的面值</span></span><br><span class="line">        <span class="keyword">int</span> money = <span class="number">11</span>; <span class="comment">//待求取的目标数额</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] result = getLeastCoins(coins, money);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"硬币的面值为："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; coins.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(coins[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"要凑齐数额 "</span> + i + <span class="string">" 最少需要 "</span> </span><br><span class="line">                + result[i] + <span class="string">" 个硬币"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * param coins 存储硬币面值的数组</span></span><br><span class="line"><span class="comment">      * param money 待求取的目标数额</span></span><br><span class="line"><span class="comment">      * return result 存储各个数额所需最少硬币的数组</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getLeastCoins(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> money)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[money + <span class="number">1</span>];</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//数额0只需0个便可凑齐</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; result.length; i++)</span><br><span class="line">            result[i] = <span class="number">10000</span>; <span class="comment">//初始化时各个数额需要最大上限个硬币</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= money; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> coin : coins)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(coin &lt;= i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> min = <span class="number">10000</span>; <span class="comment">//存储中间结果的变量，初始化为最大硬币上限</span></span><br><span class="line">                    min = result[i - coin] + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">if</span>(result[i] &gt; min)</span><br><span class="line">                        result[i] = min;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/动态规划-硬币问题.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：动态规划&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;实际问题：硬币问题&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://www.wersong.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-矩阵连乘</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98/"/>
    <id>http://www.wersong.cn/算法/动态规划-矩阵连乘/</id>
    <published>2018-09-29T01:33:02.000Z</published>
    <updated>2018-09-29T01:50:26.035Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：动态规划</strong><br><strong>实际问题：矩阵连乘</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h6><p>给定 n 个矩阵{A1, A2, A3, …, An}，其中Ai 与 Aj 是可乘的，j = i + 1, i = 1, 2, 3, …, n - 1。考察这 n 个矩阵的连乘积所需的最少乘法次数。</p><p>举例：数组：A(2, 3), B(3, 5), C(5, 7), 其中A(n, m) 表示 n 行 m 列的矩阵。若按照(A <em> B) </em> C 的顺序计算，那么有 2 <em> 3 </em> 5 + 2 <em> 5 </em> 7 = 30 + 70 = 100 次乘法计算，而如果按照 A <em> (B </em> C) 的次序计算，那么有 2 <em> 3 </em> 7 + 3 <em> 5 </em> 7 = 42 + 105 = 147 次乘法计算，可以看出，两个计算方法的结果是有差异的。那么寻找最少乘法次数(最优解)是确实有必要的。</p><h6 id="关键特征"><a href="#关键特征" class="headerlink" title="关键特征"></a>关键特征</h6><p>计算 A[1:n] 的最优次序所包含的计算矩阵子链 A[1:k] 和 A[k+1:n] 的次序也是最优的。事实上，若假设 A[1:k]  的计算次序不是最优的，在 A[k+1:n] 的计算次序不变的情况下，总次序会更少，此时就需要替换原次序。A[1:n] 的最优次序 k 的位置不变，只是 A[1:k] 的计算次序变了。综上，原问题包含了其子问题的解，这就是矩阵连乘的最优子结构性质。</p><h6 id="递归关系"><a href="#递归关系" class="headerlink" title="递归关系"></a>递归关系</h6><p>设计算 A[i:j] 所需的最少乘积次数为m[i][j]，则原问题的最优解为m[1][n]。其中 1 &lt;= i &lt;= j &lt;= n，并且有：</p><ul><li>当 i = j 时，A[i:j] = A 为单一矩阵，无须计算，因此 m[i][i] = 0;</li><li>当 i &lt; j 时，可利用最优子结构性质来计算m[i][j]，m[i][j] = min{m[i][k] + m[k+1][j] + pi-1 <em> pk </em> pj}，其中 i &lt;=k &lt; j，pi-1 <em> pk </em> pj 表示左右两个子链相乘，即它们分别表示左行、左列、右列。</li></ul><p>另外，将 m[i][j] 的断开位置记为 s[i][j]，方便后续构造相应的最优解</p><h6 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixSuccessiveMultiplication</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 全局变量含义：</span></span><br><span class="line"><span class="comment">      * p：表示矩阵链，其中矩阵 Ai 的维度为 p[i][0] * p[i][1]</span></span><br><span class="line"><span class="comment">      * m：m[i][j] 存储 A[i:j] 所需的最少乘积次数为m</span></span><br><span class="line"><span class="comment">      * s：s[i][j] 存储 m[i][j] 的断开位置 k</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] p;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] s;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//matrix[i] 表示第 i 个矩阵</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 下面 6 个矩阵：A1: 30 * 35; A2: 35 * 15; A3: 15 * 5</span></span><br><span class="line"><span class="comment">          *   A4: 5 * 10; A5: 10 * 20; A6 20 * 25</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        p = <span class="keyword">new</span> <span class="keyword">int</span>[][] &#123;&#123;<span class="number">30</span>, <span class="number">35</span>&#125;, &#123;<span class="number">35</span>, <span class="number">15</span>&#125;, &#123;<span class="number">15</span>, <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, <span class="number">10</span>&#125;, &#123;<span class="number">10</span>, <span class="number">20</span>&#125;, &#123;<span class="number">20</span>, <span class="number">25</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> l = p.length;</span><br><span class="line">        m = <span class="keyword">new</span> <span class="keyword">int</span>[l][l]; <span class="comment">// 6 = matrix.length</span></span><br><span class="line">        s = <span class="keyword">new</span> <span class="keyword">int</span>[l][l];</span><br><span class="line"></span><br><span class="line">        matrixChain(l);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 输出 result 和 place 数组查看结果，start 到 end 段代码可以不要</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//start</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; l; j++)</span><br><span class="line">                System.out.print(m[i][j] + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; l; j++)</span><br><span class="line">                System.out.print(s[i][j] + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//end</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">//输出最优解</span></span><br><span class="line">        traceback(<span class="number">0</span>, l - <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"\n"</span> + memoizedMatrixChain(l - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 参数含义：</span></span><br><span class="line"><span class="comment">      * p：表示矩阵链，其中矩阵 Ai 的维度为 p[i][0] * p[i][1]</span></span><br><span class="line"><span class="comment">      * n：表示矩阵链中矩阵的个数</span></span><br><span class="line"><span class="comment">      * m：m[i][j] 存储 A[i:j] 所需的最少乘积次数为m</span></span><br><span class="line"><span class="comment">      * s：s[i][j] 存储 m[i][j] 的断开位置 k</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matrixChain</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//m[i][i] 不需要计算，结果为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            m[i][i] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//mcLength: matrixChainLength: 矩阵链长度，最小为2</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> mcLength = <span class="number">2</span>; mcLength &lt;= n; mcLength++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//l: left为矩阵链左起点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; n - mcLength + <span class="number">1</span>; l++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//r: right为矩阵链右终点</span></span><br><span class="line">                <span class="keyword">int</span> r = l + mcLength - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//先算整条链从左到右的计算次数，不切割</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 计算方法为最左边的矩阵乘上右终点矩阵结果的列，</span></span><br><span class="line"><span class="comment">                 * 再加上右边矩阵链的乘积</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                m[l][r] = m[l + <span class="number">1</span>][r] + p[l][<span class="number">0</span>] * p[l][<span class="number">1</span>] * p[r][<span class="number">1</span>];</span><br><span class="line">                s[l][r] = l; <span class="comment">//断开位置为矩阵l</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//b: break为中间断开位置</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> b = l + <span class="number">1</span>; b &lt; r; b++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 矩阵l的行为左边矩阵链的行</span></span><br><span class="line"><span class="comment">                     * 矩阵b的列为左边矩阵链的列</span></span><br><span class="line"><span class="comment">                     * 矩阵r的列为右边矩阵链的列</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">int</span> t = m[l][b] + m[b + <span class="number">1</span>][r] </span><br><span class="line">                        + p[l][<span class="number">0</span>] * p[b][<span class="number">1</span>] * p[r][<span class="number">1</span>];</span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span>(t &lt; m[l][r])</span><br><span class="line">                    &#123;</span><br><span class="line">                        m[l][r] = t;</span><br><span class="line">                        s[l][r] = b;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 动态规划的备忘录方法，自顶而下的递归，参数含义与上面的函数相同</span></span><br><span class="line"><span class="comment">     * 备忘录方法是给记录项存入一个初始值，表示问题尚未解决。每次求解子问题时，</span></span><br><span class="line"><span class="comment">     * 先查看该值，若是初始值，表示该子问题尚未计算，计算值。若不是初始值，</span></span><br><span class="line"><span class="comment">     * 表示该子问题已计算过，直接返回即可。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">memoizedMatrixChain</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; n; j++)</span><br><span class="line">                m[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> lookupChain(<span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 检查整条链的最优计算次序和断开位置，此方法使用于备忘录方法中</span></span><br><span class="line"><span class="comment">      * 参数含义：</span></span><br><span class="line"><span class="comment">      * l: left为矩阵链左起点</span></span><br><span class="line"><span class="comment">      * r: right为矩阵链右终点</span></span><br><span class="line"><span class="comment">      * 返回值是矩阵链l到r的计算次序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">lookupChain</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m[l][r] &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> m[l][r];</span><br><span class="line">        <span class="keyword">if</span>(l == r)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> u = lookupChain(l + <span class="number">1</span>, r) + p[l][<span class="number">0</span>] * p[l][<span class="number">1</span>] * p[r][<span class="number">1</span>];</span><br><span class="line">        s[l][r] = l;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = l + <span class="number">1</span>; k &lt; r; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = lookupChain(l, k) + lookupChain(k + <span class="number">1</span>, r) </span><br><span class="line">                + p[l][<span class="number">0</span>] * p[k][<span class="number">1</span>] * p[r][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(t &lt; u)</span><br><span class="line">            &#123;</span><br><span class="line">                u = t;</span><br><span class="line">                s[l][r] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        m[l][r] = u;</span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 函数求矩阵链最少乘积结果的断开位置，使用了递归方法，自底而上</span></span><br><span class="line"><span class="comment">      * 参数说明：</span></span><br><span class="line"><span class="comment">      *  i: 矩阵链左起点</span></span><br><span class="line"><span class="comment">      *  j: 矩阵链右终点</span></span><br><span class="line"><span class="comment">      *  s: 断开位置的存储矩阵</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceback</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == j)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//s[i][j]是断开位置，s[i][j] + 1是断开位置的下一个矩阵</span></span><br><span class="line">        traceback(i, s[i][j]);</span><br><span class="line">        traceback(s[i][j] + <span class="number">1</span>, j);</span><br><span class="line">        </span><br><span class="line">        System.out.print(<span class="string">"A["</span> + i + <span class="string">", "</span> + j + <span class="string">"] = "</span>);</span><br><span class="line">        System.out.println(<span class="string">"A["</span> + i + <span class="string">", "</span> + s[i][j] </span><br><span class="line">            + <span class="string">"] + A["</span> + (s[i][j] + <span class="number">1</span>) + <span class="string">", "</span> + j + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p>说明：第一个结果为 m[i][j] 的值，第二个结果为 s[i][j] 的值，第三个结果为矩阵连乘中的计算次序，第四个结果为最少所需的计算次数<br><img src="/images/动态规划-矩阵连乘.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：动态规划&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;实际问题：矩阵连乘&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="动态规划" scheme="http://www.wersong.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>动态规划-总览</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E8%A7%88/"/>
    <id>http://www.wersong.cn/算法/动态规划-总览/</id>
    <published>2018-09-28T13:34:01.000Z</published>
    <updated>2018-09-28T15:12:53.965Z</updated>
    
    <content type="html"><![CDATA[<h6 id="思想描述"><a href="#思想描述" class="headerlink" title="思想描述"></a>思想描述</h6><p>动态规划问题是面试题中的热门话题，动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。<br><a id="more"></a><br>动态规划算法与<a href="/算法/分治法-总览">分治法</a>类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。</p><h6 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h6><ol><li>求一个问题的最优解 </li><li>大问题可以分解为子问题，子问题还有重叠的更小的子问题 </li><li>整体问题最优解取决于子问题的最优解（状态转移方程） </li><li>从上往下分析问题，从下往上解决问题 </li><li>讨论底层的边界问题<h6 id="博文导航"><a href="#博文导航" class="headerlink" title="博文导航"></a>博文导航</h6></li></ol><ul><li><a href="/算法/动态规划-矩阵连乘">动态规划-矩阵连乘</a></li><li><a href="/算法/动态规划-硬币问题">动态规划-硬币问题</a></li><li><a href="/算法/动态规划-最大子段和">动态规划-最大子段和</a></li><li><a href="/算法/动态规划-多边形游戏">动态规划-多边形游戏</a></li><li><a href="/算法/动态规划-01背包问题">动态规划-01背包问题</a></li><li><a href="/算法/动态规划-最长公共子序列">动态规划-最长公共子序列</a></li><li><a href="/算法/动态规划-最优二叉搜索树">动态规划-最优二叉搜索树</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;思想描述&quot;&gt;&lt;a href=&quot;#思想描述&quot; class=&quot;headerlink&quot; title=&quot;思想描述&quot;&gt;&lt;/a&gt;思想描述&lt;/h6&gt;&lt;p&gt;动态规划问题是面试题中的热门话题，动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="总览" scheme="http://www.wersong.cn/tags/%E6%80%BB%E8%A7%88/"/>
    
      <category term="动态规划" scheme="http://www.wersong.cn/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>分治法-最大子段和</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C/"/>
    <id>http://www.wersong.cn/算法/分治法-最大子段和/</id>
    <published>2018-08-31T08:49:20.000Z</published>
    <updated>2018-08-31T09:10:25.326Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：分治法</strong><br><strong>实际问题：最大子段和</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h6><p>此篇博文是分治法解决最大子段和问题的实现。<br>问题描述：给定由n个整数(可能为负数)组成的序列A={a1, a2, …, an}，求该序列形如sum(A, i, j)的子段和的最大值。当所有整数均为负整数时，定义其最大子段和为0，依次定义，所求的最大值为：max{0, sum(A, i, j)}， 例如：(a1, a2, a3, a4, a5, a6)=(-2, 11, -4, 13, -5, -2)时，最大子段和为sum(A, 2, 4)=20<br>算法思想：</p><pre><code>1. sum(A, 1, n)==sum(A, 1, n/2)2. sum(A, 1, n)==sum(A, n/2+1, n)3. sum(A, 1, n)==sum(A, i, j), 其中 1&lt;=i&lt;=n/2, n/2+1&lt;=j&lt;=n</code></pre><p>解释：即序列A的最大子段和可能在A的左半部分，也可能在A的右半部分，还可能跨越了A的左右两个部分</p><h6 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxSubsequenceSum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">2</span>, <span class="number">11</span>, -<span class="number">4</span>, <span class="number">13</span>, -<span class="number">5</span>, -<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> result = maxSubSum(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">"maxSubSum(a) = "</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">      * 使用分治思想求取最大子段和</span></span><br><span class="line"><span class="comment">      * 参数含义：</span></span><br><span class="line"><span class="comment">      *     a: 待求取最大子段和的数组</span></span><br><span class="line"><span class="comment">      *     left：子段起点</span></span><br><span class="line"><span class="comment">      *     right：子段终点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSum</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; <span class="comment">//sum为总的最大子段和</span></span><br><span class="line">        <span class="keyword">if</span>(left == right)</span><br><span class="line">            sum = a[left] &gt; <span class="number">0</span> ? a[left] : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 分治求解</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//求左子段的和</span></span><br><span class="line">            <span class="keyword">int</span> leftSum = maxSubSum(a, left, mid);</span><br><span class="line">            <span class="comment">//求右子段的和</span></span><br><span class="line">            <span class="keyword">int</span> rightSum = maxSubSum(a, mid + <span class="number">1</span>, right);</span><br><span class="line">            <span class="comment">//求跨越左右两段的子段和：开始</span></span><br><span class="line">            <span class="keyword">int</span> maxLefts = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> lefts = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 子段是连续的，从中间向两边扩散</span></span><br><span class="line"><span class="comment">             * 若是从左半部分从左边开始计算子段和，可能会导致整体的</span></span><br><span class="line"><span class="comment">             * 左右子段不连续，故左半部分子段和从右边往左边运算，</span></span><br><span class="line"><span class="comment">             * 右半部分子段和从左边往右边运算，保证整体的子段连续</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = mid; i &gt;= left; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                lefts += a[i];</span><br><span class="line">                <span class="keyword">if</span>(lefts &gt; maxLefts)</span><br><span class="line">                    maxLefts = lefts;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> maxRights = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> rights = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt; right; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                rights += a[i];</span><br><span class="line">                <span class="keyword">if</span>(rights &gt; maxRights)</span><br><span class="line">                    maxRights = rights;</span><br><span class="line">            &#125;</span><br><span class="line">            sum = maxLefts + maxRights;</span><br><span class="line">            <span class="comment">//求跨越左右两段的子段和：结束</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断得到最大子段和</span></span><br><span class="line">            <span class="keyword">if</span>(sum &lt; leftSum)</span><br><span class="line">                sum = leftSum;</span><br><span class="line">            <span class="keyword">if</span>(sum &lt; rightSum)</span><br><span class="line">                sum = rightSum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/分治法-最大子段和.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：分治法&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;实际问题：最大子段和&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分治法" scheme="http://www.wersong.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治法-总览</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95-%E6%80%BB%E8%A7%88/"/>
    <id>http://www.wersong.cn/算法/分治法-总览/</id>
    <published>2018-08-31T08:21:31.000Z</published>
    <updated>2018-08-31T08:57:01.685Z</updated>
    
    <content type="html"><![CDATA[<h6 id="思想描述"><a href="#思想描述" class="headerlink" title="思想描述"></a>思想描述</h6><p>分治法是一种算法思想，其设计思想为：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，这些子问题相互独立且与原问题相同。从而达到各个击破，分而治之的目的。在实际应用中，分治法往往会和递归算法结合在一起。<br><a id="more"></a><br>递归的概念：直接或者间接地调用自身的算法称为递归算法，用函数自身给出定义的函数称为递归函数。如下面的就是递归函数的一个简单例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此递归函数用来求斐波那契数列第n项的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getSum(n - <span class="number">1</span>) + getSum(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h6 id="博文导航"><a href="#博文导航" class="headerlink" title="博文导航"></a>博文导航</h6><ul><li><a href="/算法/分治法-排列问题">分治法-排列问题</a></li><li><a href="/算法/分治法-归并排序">分治法-归并排序</a></li><li><a href="/算法/分治法-快速排序">分治法-快速排序</a></li><li><a href="/算法/分治法-棋盘覆盖">分治法-棋盘覆盖</a></li><li><a href="/算法/分治法-最大子段和">分治法-最大子段和</a></li><li><a href="/算法/分治法-线性时间选择">分治法-线性时间选择</a></li><li><a href="/算法/分治法-循环赛日程表">分治法-循环赛日程表</a></li><li><a href="/算法/分治法-Strassen矩阵乘法">分治法-Strassen矩阵乘法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;思想描述&quot;&gt;&lt;a href=&quot;#思想描述&quot; class=&quot;headerlink&quot; title=&quot;思想描述&quot;&gt;&lt;/a&gt;思想描述&lt;/h6&gt;&lt;p&gt;分治法是一种算法思想，其设计思想为：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，这些子问题相互独立且与原问题相同。从而达到各个击破，分而治之的目的。在实际应用中，分治法往往会和递归算法结合在一起。&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分治法" scheme="http://www.wersong.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
      <category term="总览" scheme="http://www.wersong.cn/tags/%E6%80%BB%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>算法总览</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88/"/>
    <id>http://www.wersong.cn/算法/算法总览/</id>
    <published>2018-08-24T14:32:10.000Z</published>
    <updated>2018-09-29T11:40:50.202Z</updated>
    
    <content type="html"><![CDATA[<p>算法的重要性我不陈述了。<br>这是一篇算法部分的总览导航文。<br>参考书籍：<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/8430149" target="_blank" rel="noopener">《计算机算法设计与分析第4版》（王晓东著，电子工业出版社）</a><br><a id="more"></a></p><ul><li><a href="/算法/分治法-总览">分治法-总览</a></li><li><a href="/算法/动态规划-总览">动态规划-总览</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法的重要性我不陈述了。&lt;br&gt;这是一篇算法部分的总览导航文。&lt;br&gt;参考书籍：&lt;a href=&quot;https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90/8430149&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《计算机算法设计与分析第4版》（王晓东著，电子工业出版社）&lt;/a&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="总览" scheme="http://www.wersong.cn/tags/%E6%80%BB%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>分治法-循环赛日程表</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95-%E5%BE%AA%E7%8E%AF%E8%B5%9B%E6%97%A5%E7%A8%8B%E8%A1%A8/"/>
    <id>http://www.wersong.cn/算法/分治法-循环赛日程表/</id>
    <published>2018-08-15T08:49:03.000Z</published>
    <updated>2018-08-31T09:07:28.537Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：分治法</strong><br><strong>实际问题：循环赛日程表</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h6><p>假设有 n = 2^k 个运动员进行循环赛，要根据以下限制生成一个日程表：</p><pre><code>1. 每个选手必须与其他 n - 1 个选手各赛一次2. 每个选手一天只能赛一次3. 循环赛一共进行 n - 1 天</code></pre><p>生成内容：n行，n - 1列的表b，b(i)(j)表示选手i在j天遇到的对手</p><h6 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobinSchedule</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] table = getTable(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; table[<span class="number">0</span>].length; j++)</span><br><span class="line">                System.out.print(table[i][j] + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] getTable(<span class="keyword">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span> &lt;&lt; k; <span class="comment">//n = 2^k</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//构造第一行数作为初始数据</span></span><br><span class="line">        <span class="keyword">int</span>[][] a = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            a[<span class="number">0</span>][i] = i + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将整个赛程表分为四个部分：</span></span><br><span class="line"><span class="comment">         * 左上角1：(0, i), 右上角2：(0, r + i)</span></span><br><span class="line"><span class="comment">         * 左下角3：(r, i), 右下角4：(r, r + i)</span></span><br><span class="line"><span class="comment">         * r为跨度，思想是将内容 1 复制到内容 4，将内容 2 复制到内容 3</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//r是跨度，长度每次扩大一倍，跨度最小为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">1</span>; r &lt; n; r &lt;&lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += r &lt;&lt; <span class="number">1</span>) <span class="comment">//起点每次跨越两倍长度</span></span><br><span class="line">            &#123;</span><br><span class="line">                copy(a, r, r + i, <span class="number">0</span>, i, r); <span class="comment">//左上角换到右下角</span></span><br><span class="line">                copy(a, r, i, <span class="number">0</span>, r + i, r); <span class="comment">//右上角换到左下角</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(<span class="keyword">int</span>[][] a, <span class="keyword">int</span> tox, <span class="keyword">int</span> toy,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">int</span> fromx, <span class="keyword">int</span> fromy, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; r; j++)</span><br><span class="line">                a[tox + i][toy + j] = a[fromx + i][fromy + j];</span><br><span class="line">        <span class="comment">//System.out.println();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/分治法-循环赛日程表.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：分治法&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;实际问题：循环赛日程表&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分治法" scheme="http://www.wersong.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治法-棋盘覆盖</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95-%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96/"/>
    <id>http://www.wersong.cn/算法/分治法-棋盘覆盖/</id>
    <published>2018-08-15T06:15:22.000Z</published>
    <updated>2018-08-31T09:01:39.800Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：分治法</strong><br><strong>实际问题：棋盘覆盖</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h6><p>在一个 2^k×2^k 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。<br><img src="/images/4种L型骨牌.jpg" alt="4种L型骨牌"></p><h6 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoardCover</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] board;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//String[] 和 String... 的区别：一个是固定参数，一个是参数长度可变</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"提示：棋盘大小必须为2的幂次方。"</span> +</span><br><span class="line">            <span class="string">"\n      输入的格式为：棋盘大小，特殊方格横坐标，特殊方格纵坐标"</span> +</span><br><span class="line">            <span class="string">"\n      分隔符为：英文逗号 + 空格，即 \", \"\n"</span>);</span><br><span class="line">        System.out.print(<span class="string">"请输入数据："</span>);</span><br><span class="line">        String aryStr = input.nextLine();</span><br><span class="line">        String[] temp = aryStr.split(<span class="string">", "</span>);</span><br><span class="line">        <span class="keyword">int</span>[] msg = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">            msg[i] = Integer.parseInt(temp[i]);</span><br><span class="line">        board = <span class="keyword">new</span> <span class="keyword">int</span>[msg[<span class="number">0</span>]][msg[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">        cover(msg[<span class="number">0</span>], msg[<span class="number">1</span>], msg[<span class="number">2</span>], <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//给特殊点赋值</span></span><br><span class="line">        board[msg[<span class="number">1</span>]][msg[<span class="number">2</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; msg[<span class="number">0</span>]; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; msg[<span class="number">0</span>]; j++)</span><br><span class="line">                System.out.print(board[i][j] + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数含义：size为棋盘大小，x，y为特殊点坐标, sx，sy为棋盘起点坐标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cover</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> sx, <span class="keyword">int</span> sy)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> t = ++num; <span class="comment">//函数递归的层数</span></span><br><span class="line">        <span class="keyword">int</span> halfSize = size / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x &lt; sx + halfSize &amp;&amp; y &lt; sy + halfSize) <span class="comment">//特殊点在左上角棋盘</span></span><br><span class="line">        &#123;</span><br><span class="line">            cover(halfSize, x, y, sx, sy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//特殊点不在左上角棋盘</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//填充右下角为特殊点</span></span><br><span class="line">            <span class="keyword">int</span> tx = sx + halfSize - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> ty = sy + halfSize - <span class="number">1</span>;</span><br><span class="line">            board[tx][ty] = t;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//填充剩余棋盘</span></span><br><span class="line">            cover(halfSize, tx, ty, sx, sy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x &gt;= sx + halfSize &amp;&amp; y &lt; sy + halfSize) <span class="comment">//特殊点在右上角棋盘</span></span><br><span class="line">        &#123;</span><br><span class="line">            cover(halfSize, x, y, sx + halfSize, sy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//特殊点不在右上角棋盘</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//填充左下角为特殊点</span></span><br><span class="line">            <span class="keyword">int</span> tx = sx + halfSize;</span><br><span class="line">            <span class="keyword">int</span> ty = sy + halfSize - <span class="number">1</span>;</span><br><span class="line">            board[tx][ty] = t;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//填充剩余棋盘</span></span><br><span class="line">            cover(halfSize, tx, ty, sx + halfSize, sy);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x &lt; sx + halfSize &amp;&amp; y &gt;= sy + halfSize) <span class="comment">//特殊点在左下角棋盘</span></span><br><span class="line">        &#123;</span><br><span class="line">            cover(halfSize, x, y, sx, sy + halfSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//特殊点不在左下角棋盘</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//填充右上角为特殊点</span></span><br><span class="line">            <span class="keyword">int</span> tx = sx + halfSize - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> ty = sy + halfSize;</span><br><span class="line">            board[tx][ty] = t;</span><br><span class="line">            <span class="comment">//填充剩余棋盘</span></span><br><span class="line">            cover(halfSize, tx, ty, sx, sy + halfSize);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(x &gt;= sx + halfSize &amp;&amp; y &gt;= sy + halfSize) <span class="comment">//特殊点在右下角棋盘</span></span><br><span class="line">        &#123;</span><br><span class="line">            cover(halfSize, x, y, sx + halfSize, sy + halfSize);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">//特殊点不在右下角棋盘</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//填充左上角为特殊点</span></span><br><span class="line">            <span class="keyword">int</span> tx = sx + halfSize;</span><br><span class="line">            <span class="keyword">int</span> ty = sy + halfSize;</span><br><span class="line">            board[tx][ty] = t;</span><br><span class="line">            <span class="comment">//填充剩余棋盘</span></span><br><span class="line">            cover(halfSize, tx, ty, sx + halfSize, sy + halfSize);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/分治法-棋盘覆盖.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：分治法&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;实际问题：棋盘覆盖&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分治法" scheme="http://www.wersong.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治法-Strassen矩阵乘法</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95-Strassen%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/"/>
    <id>http://www.wersong.cn/算法/分治法-Strassen矩阵乘法/</id>
    <published>2018-08-15T03:57:29.000Z</published>
    <updated>2018-08-24T14:57:35.235Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：分治法</strong><br><strong>实际问题：Strassen 矩阵乘法</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h6><p>我们知道，两个大小为 2 * 2 的矩阵相乘，一般需要进行 8 次乘法。而Strassen矩阵乘法可以减少一次乘法，只需要 7 次，看似很少，但当数据量很大时，效率就会有显著提升。不过使用 Strassen矩阵乘法需要满足 矩阵边长为 2 的幂次方。因为该算法会用到分治，如果分治后矩阵两边边长不等，结果会出错。</p><p>使用下面的方法计算结果矩阵，假设两个长度为 2 的矩阵是 A，B，相乘后的结果矩阵为 C：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">M1</span> = A11(B12 - B22)注：Anm 表示 A 矩阵第 n 行 k 列的值，Bnm，Cnm 同理</span><br><span class="line"><span class="attr">M2</span> = (A11 + A12)B22</span><br><span class="line"><span class="attr">M3</span> = (A21 + A22)B11 </span><br><span class="line"><span class="attr">M4</span> = A22(B21 - B11)</span><br><span class="line"><span class="attr">M5</span> = (A11 + A22)(B11 + B22)</span><br><span class="line"><span class="attr">M6</span> = (A12 - A22)(B21 + B22)</span><br><span class="line"><span class="attr">M7</span> = (A11 - A21)(B11 + B12)</span><br></pre></td></tr></table></figure></p><p>可得结果为：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">C<span class="number">11</span> = <span class="name">M5</span> + <span class="name">M4</span> - <span class="name">M2</span> + <span class="name">M6</span></span><br><span class="line">C<span class="number">12</span> = <span class="name">M1</span> + <span class="name">M2</span></span><br><span class="line">C<span class="number">21</span> = <span class="name">M3</span> + <span class="name">M4</span></span><br><span class="line">C<span class="number">22</span> = <span class="name">M5</span> + <span class="name">M1</span> - <span class="name">M3</span> - <span class="name">M7</span></span><br></pre></td></tr></table></figure></p><h6 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrassenMatrixMultiply</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">            <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>,</span><br><span class="line">            <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>,</span><br><span class="line">            <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,</span><br><span class="line">            <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] c = sMM(a, b, length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(c[i] + <span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((i + <span class="number">1</span>) % length == <span class="number">0</span>) <span class="comment">//换行</span></span><br><span class="line">                System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sMM(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, <span class="keyword">int</span> length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(length == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> getResult(a, b);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tlength = length / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//把a数组分为四部分，进行分治递归</span></span><br><span class="line">            <span class="keyword">int</span>[] aa = <span class="keyword">new</span> <span class="keyword">int</span>[tlength * tlength];</span><br><span class="line">            <span class="keyword">int</span>[] ab = <span class="keyword">new</span> <span class="keyword">int</span>[tlength * tlength];</span><br><span class="line">            <span class="keyword">int</span>[] ac = <span class="keyword">new</span> <span class="keyword">int</span>[tlength * tlength];</span><br><span class="line">            <span class="keyword">int</span>[] ad = <span class="keyword">new</span> <span class="keyword">int</span>[tlength * tlength];</span><br><span class="line">            <span class="comment">//把b数组分为四部分，进行分治递归</span></span><br><span class="line">            <span class="keyword">int</span>[] ba = <span class="keyword">new</span> <span class="keyword">int</span>[tlength * tlength];</span><br><span class="line">            <span class="keyword">int</span>[] bb = <span class="keyword">new</span> <span class="keyword">int</span>[tlength * tlength];</span><br><span class="line">            <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[tlength * tlength];</span><br><span class="line">            <span class="keyword">int</span>[] bd = <span class="keyword">new</span> <span class="keyword">int</span>[tlength * tlength];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//划分子矩阵</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * 划分矩阵：</span></span><br><span class="line"><span class="comment">                     * 例子：将 4 * 4 的矩阵，变为 2 * 2 的矩阵，</span></span><br><span class="line"><span class="comment">                     * 那么原矩阵左上、右上、左下、右下的四个元素分别归为新矩阵</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="keyword">if</span>(i &lt; tlength)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(j &lt; tlength)</span><br><span class="line">                        &#123;</span><br><span class="line">                            aa[i * tlength + j] = a[i * length + j];</span><br><span class="line">                            ba[i * tlength + j] = b[i * length + j];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            ab[i * tlength + (j - tlength)]</span><br><span class="line">                            = a[i * length + j];</span><br><span class="line">                            bb[i * tlength + (j - tlength)]</span><br><span class="line">                            = b[i * length + j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(j &lt; tlength)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">//i 大于 tlength 时，需要减去 tlength，j同理</span></span><br><span class="line">                            <span class="comment">//因为 b，c，d三个子矩阵有对应了父矩阵的后半部分</span></span><br><span class="line">                            ac[(i - tlength) * tlength + j]</span><br><span class="line">                            = a[i * length + j];</span><br><span class="line">                            bc[(i - tlength) * tlength + j]</span><br><span class="line">                            = b[i * length + j];</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                        &#123;</span><br><span class="line">                            ad[(i - tlength) * tlength + (j - tlength)]</span><br><span class="line">                            = a[i * length + j];</span><br><span class="line">                            bd[(i - tlength) * tlength + (j - tlength)]</span><br><span class="line">                            = b[i * length + j];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//分治递归</span></span><br><span class="line">            <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[length * length];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//temp：4个临时矩阵</span></span><br><span class="line">            <span class="keyword">int</span>[] t1 = add(sMM(aa, ba, tlength), sMM(ab, bc, tlength));</span><br><span class="line">            <span class="keyword">int</span>[] t2 = add(sMM(aa, bb, tlength), sMM(ab, bd, tlength));</span><br><span class="line">            <span class="keyword">int</span>[] t3 = add(sMM(ac, ba, tlength), sMM(ad, bc, tlength));</span><br><span class="line">            <span class="keyword">int</span>[] t4 = add(sMM(ac, bb, tlength), sMM(ad, bd, tlength));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//归并结果</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; length; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(i &lt; tlength)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(j &lt; tlength)</span><br><span class="line">                            result[i * length + j]</span><br><span class="line">                            = t1[i * tlength + j];</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            result[i * length + j]</span><br><span class="line">                            = t2[i * tlength + (j - tlength)];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(j &lt; tlength)</span><br><span class="line">                            result[i * length + j]</span><br><span class="line">                            = t3[(i - tlength) * tlength + j];</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            result[i * length + j]</span><br><span class="line">                            = t4[(i - tlength) * tlength + (j - tlength)];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getResult(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p1 = a[<span class="number">0</span>] * (b[<span class="number">1</span>] - b[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">int</span> p2 = (a[<span class="number">0</span>] + a[<span class="number">1</span>]) * b[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> p3 = (a[<span class="number">2</span>] + a[<span class="number">3</span>]) * b[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> p4 = a[<span class="number">3</span>] * (b[<span class="number">2</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> p5 = (a[<span class="number">0</span>] + a[<span class="number">3</span>]) * (b[<span class="number">0</span>] + b[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">int</span> p6 = (a[<span class="number">1</span>] - a[<span class="number">3</span>]) * (b[<span class="number">2</span>] + b[<span class="number">3</span>]);</span><br><span class="line">        <span class="keyword">int</span> p7 = (a[<span class="number">0</span>] - a[<span class="number">2</span>]) * (b[<span class="number">0</span>] + b[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c00 = p5 + p4 - p2 + p6;</span><br><span class="line">        <span class="keyword">int</span> c01 = p1 + p2;</span><br><span class="line">        <span class="keyword">int</span> c10 = p3 + p4;</span><br><span class="line">        <span class="keyword">int</span> c11 = p5 + p1 -p3 - p7;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;c00, c01, c10, c11&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] add(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">            c[i] = a[i] + b[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回一个数是不是2的幂次方</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">adjust</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num &amp; (num - <span class="number">1</span>)) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/分治法-Strassen矩阵乘法.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：分治法&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;实际问题：Strassen 矩阵乘法&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分治法" scheme="http://www.wersong.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治法-线性时间选择</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9/"/>
    <id>http://www.wersong.cn/算法/分治法-线性时间选择/</id>
    <published>2018-08-14T02:35:55.000Z</published>
    <updated>2018-08-31T09:02:04.731Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：分治法</strong><br><strong>实际问题：线性时间选择</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h6><p>给定线性序集中 n 个元素和一个整数 k, 1 &lt;= k &lt;= n, 要求找出这 n 个元素中第 k 小的元素。即如果将这 n 个元素依其线性序排列时，排在第 k 个位置的元素即为要找的元素。</p><p>本篇博文代码会用到 <a href="/算法/分治法-快速排序">分治法-快速排序</a> 博文中用到的基准选择方法。<br>方法使用位置：代码第 25 行<br>方法实现位置：代码第 37 - 68 行</p><h6 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomizedSelect</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> t = select(a, <span class="number">0</span>, a.length - <span class="number">1</span>, <span class="number">4</span>); <span class="comment">//选出第四大的数</span></span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数含义：a为待查询的数组，low为起点，high为终点，target为带查询的目标</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(low == high)</span><br><span class="line">            <span class="keyword">return</span> a[low];</span><br><span class="line">        <span class="comment">//将数组以i为基准分为两部分，左边的都小于i，右边的都大于i</span></span><br><span class="line">        <span class="comment">//此处会用到快速排序算法中的划分方法来找基准</span></span><br><span class="line">        <span class="keyword">int</span> i = randPart(a, low, high);</span><br><span class="line">        <span class="keyword">int</span> length = i - low + <span class="number">1</span>; <span class="comment">//数组左半部分的长度</span></span><br><span class="line">        <span class="comment">//如果第target小的数小于等于左半部分的长度，则这个数在此部分内</span></span><br><span class="line">        <span class="keyword">if</span>(target &lt;= length)</span><br><span class="line">            <span class="keyword">return</span> select(a, low, i, target);</span><br><span class="line">        <span class="comment">//如果第target小的数大于左半部分的长度，则这个数在右半部分内，</span></span><br><span class="line">        <span class="comment">//且左半部分的数都小于第target小的数</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> select(a, i + <span class="number">1</span>, high, target - length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//划分寻找基准-随机化优化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randPart</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//随机产生一个 low 到 high 的整数</span></span><br><span class="line">        <span class="keyword">int</span> flag = low + r.nextInt(high - low + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivot = a[flag];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//实际还是相当于以a[0]为基准</span></span><br><span class="line">        a[flag] = a[low];</span><br><span class="line">        a[low] = pivot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1、从右往左找比基准小的数</span></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &gt; pivot)</span><br><span class="line">                high--;</span><br><span class="line">            <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">                a[low] = a[high];</span><br><span class="line">            <span class="comment">//2、从左往右找比基准大的数</span></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt;= pivot)</span><br><span class="line">                low++;</span><br><span class="line">            <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">                a[high] = a[low];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将pivot放到low和high相遇的地方</span></span><br><span class="line">        a[high] = pivot;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/分治法-线性时间选择.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：分治法&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;实际问题：线性时间选择&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分治法" scheme="http://www.wersong.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治法-归并排序</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.wersong.cn/算法/分治法-归并排序/</id>
    <published>2018-08-14T01:18:07.000Z</published>
    <updated>2018-08-31T09:01:01.949Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：分治法</strong><br><strong>实际问题：归并排序</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本篇博文代码是递归方式归并排序算法的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ary = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"排序前的数组："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ary.length; i++)</span><br><span class="line">            System.out.print(ary[i] + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        sort(ary);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"排序后的数组："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ary.length; i++)</span><br><span class="line">            System.out.print(ary[i] + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//low == high 说明两者相遇，即数组大小为1</span></span><br><span class="line">        <span class="keyword">if</span>(low &lt; high) <span class="comment">//当数组尺寸不为1的时候进行递归排序操作</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">            sort(a, low, mid); <span class="comment">//对左半部分排序</span></span><br><span class="line">            sort(a, mid + <span class="number">1</span>, high); <span class="comment">//对右半部分排序</span></span><br><span class="line">            <span class="comment">//对左右两半部分排序后，两者都有序，</span></span><br><span class="line">            <span class="comment">//但左半部分的值不一定小于右半部分，所以需要归并整理</span></span><br><span class="line">            merge(a, low, mid, high); <span class="comment">//归并</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] merge(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>]; <span class="comment">//下表从零开始，数组大小多1</span></span><br><span class="line">        <span class="comment">//i为待返回结果数组起点，j为左半部分数组起点，k为右半部分数组起点</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = low, k = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= mid &amp;&amp; k &lt;= high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(a[j] &lt; a[k])</span><br><span class="line">                r[i++] = a[j++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r[i++] = a[k++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若有左半部分一个元素未加入 result 数组，此处可解决这个问题</span></span><br><span class="line">        <span class="keyword">while</span>(j &lt;= mid)</span><br><span class="line">            r[i++] = a[j++];</span><br><span class="line">        <span class="comment">//若有由半部分一个元素未加入 result 数组，此处可解决这个问题</span></span><br><span class="line">        <span class="keyword">while</span>(k &lt;= high)</span><br><span class="line">            r[i++] = a[k++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将result数组拷入原数组对应位置</span></span><br><span class="line">        System.arraycopy(r, <span class="number">0</span>, a, low, r.length);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/分治法-归并排序.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：分治法&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;实际问题：归并排序&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分治法" scheme="http://www.wersong.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
      <category term="排序" scheme="http://www.wersong.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>分治法-排列问题</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95-%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>http://www.wersong.cn/算法/分治法-排列问题/</id>
    <published>2018-08-13T08:25:34.000Z</published>
    <updated>2018-08-31T09:01:26.428Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：分治法</strong><br><strong>实际问题：排列问题</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h6><p>显示列表list(a, b, c, d……) 的全排列，显示的条目数为：n!<br>例如(1, 2, 3)的全排列为(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)</p><h6 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面的例子将以 A B C 为例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayProblem</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] list = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"序列(A, B, C)的全排列为：\n"</span>);</span><br><span class="line">        array(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//全排列的产生函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">array</span><span class="params">(<span class="keyword">char</span>[] list)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        array(list, <span class="number">0</span>, list.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//产生 start 到 end 的全排列</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">array</span><span class="params">(<span class="keyword">char</span>[] list, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; end; i++)</span><br><span class="line">                System.out.print(list[i] + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt; end; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//交换 list[i] 和 list[k] 的位置(例：i = 1 时，start = 0，</span></span><br><span class="line">                <span class="comment">//交换 A B 的位置，此时为 B A C)</span></span><br><span class="line">                <span class="keyword">char</span> temp = list[i];</span><br><span class="line">                list[i] = list[start];</span><br><span class="line">                list[start] = temp;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//第一个交换位置后，产生剩下的全排列序列(第一个为 B，</span></span><br><span class="line">                <span class="comment">//产生 A C 的全排列)</span></span><br><span class="line">                array(list, start + <span class="number">1</span>, end);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//将一个有序序列全排列后，恢复原状，防止出现重复的结果</span></span><br><span class="line">                <span class="comment">//(会出现两个完全相同的序列，即一次排列输出两次, </span></span><br><span class="line">                <span class="comment">//可以注释掉下面三行代码，运行观察效果，然后分析原因)</span></span><br><span class="line">                temp = list[i];</span><br><span class="line">                list[i] = list[start];</span><br><span class="line">                list[start] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/分治法-全排列问题.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：分治法&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;实际问题：排列问题&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分治法" scheme="http://www.wersong.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>分治法-快速排序</title>
    <link href="http://www.wersong.cn/%E7%AE%97%E6%B3%95/%E5%88%86%E6%B2%BB%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://www.wersong.cn/算法/分治法-快速排序/</id>
    <published>2018-08-13T05:24:51.000Z</published>
    <updated>2018-08-31T09:01:15.337Z</updated>
    
    <content type="html"><![CDATA[<p><strong>算法思想：分治法</strong><br><strong>实际问题：快速排序</strong><br><strong>编写语言：Java</strong></p><hr><a id="more"></a><h6 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本篇博文代码主要有两种基准选择方式：基准=低下标处的值，基准=随机值</span></span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ary = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"排序前的数组："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ary.length; i++)</span><br><span class="line">            System.out.print(ary[i] + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        sort(ary);</span><br><span class="line"></span><br><span class="line">        System.out.print(<span class="string">"排序后的数组："</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ary.length; i++)</span><br><span class="line">            System.out.print(ary[i] + <span class="string">" "</span>);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sort(a, <span class="number">0</span>, a.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//当low == high时就返回</span></span><br><span class="line">        <span class="comment">//确保数组元素为1时就停止划分，防止数组下标越界</span></span><br><span class="line">        <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pivot = randPart(a, low, high);</span><br><span class="line">            sort(a, low, pivot - <span class="number">1</span>);</span><br><span class="line">            sort(a, pivot + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//划分寻找基准</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">part</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = a[low];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1、从右往左找比基准小的数</span></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &gt; pivot)</span><br><span class="line">                high--;</span><br><span class="line">            <span class="comment">//a处赋值</span></span><br><span class="line">            <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">                a[low] = a[high]; <span class="comment">//此时是 a[high] &lt; pivot, a[low] &lt; pivot</span></span><br><span class="line">            <span class="comment">//2、从左往右找比基准大的数</span></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt;= pivot)</span><br><span class="line">                low++;</span><br><span class="line">            <span class="comment">//3、一次寻找结束，交换两个值</span></span><br><span class="line">            <span class="comment">//b处赋值</span></span><br><span class="line">            <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">                a[high] = a[low]; <span class="comment">//此时是 a[high] &gt; pivot, a[low] &lt; pivot</span></span><br><span class="line">            <span class="comment">//a、b两处赋值，相当于一次交换，只是分开了</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将pivot放到left和right相遇的地方</span></span><br><span class="line">        a[high] = pivot;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//划分寻找基准-随机化优化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randPart</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="comment">//随机产生一个 low 到 high 的整数</span></span><br><span class="line">        <span class="keyword">int</span> flag = low + r.nextInt(high - low + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pivot = a[flag];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此处交换保证 1 处的赋值不出错，</span></span><br><span class="line">        <span class="comment">//因为只要原 a[low] &lt; pivot，那么这个交换算法就失败了</span></span><br><span class="line">        a[flag] = a[low];</span><br><span class="line">        a[low] = pivot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//1、从右往左找比基准小的数</span></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; a[high] &gt; pivot)</span><br><span class="line">                high--;</span><br><span class="line">            <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">                a[low] = a[high];</span><br><span class="line">            <span class="comment">//2、从左往右找比基准大的数</span></span><br><span class="line">            <span class="keyword">while</span>(low &lt; high &amp;&amp; a[low] &lt;= pivot)</span><br><span class="line">                low++;</span><br><span class="line">            <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">                a[high] = a[low];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将pivot放到low和high相遇的地方</span></span><br><span class="line">        a[high] = pivot;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> high;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h6><p><img src="/images/分治法-快速排序.jpg" alt="结果示例"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;算法思想：分治法&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;实际问题：快速排序&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;编写语言：Java&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="算法" scheme="http://www.wersong.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="分治法" scheme="http://www.wersong.cn/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
      <category term="排序" scheme="http://www.wersong.cn/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
</feed>
