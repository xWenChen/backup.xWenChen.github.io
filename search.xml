<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分治法-循环赛日程表]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E5%BE%AA%E7%8E%AF%E8%B5%9B%E6%97%A5%E7%A8%8B%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：循环赛日程表编写语言：Java 问题描述：假设有 n = 2^k 个运动员进行循环赛，要根据以下限制生成一个日程表： 1、每个选手必须与其他 n - 1 个选手各赛一次 2、每个选手一天只能赛一次 3、循环赛一共进行 n - 1 天生成内容：n行，n - 1列的表b，b(i)(j)表示选手i在j天遇到的对手代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class RoundRobinSchedule&#123; public static void main(String[] args) &#123; int[][] table = getTable(3); for(int i = 0; i &lt; table.length; i++) &#123; for(int j = 0; j &lt; table[0].length; j++) System.out.print(table[i][j] + " "); System.out.println(); &#125; &#125; public static int[][] getTable(int k) &#123; int n = 1 &lt;&lt; k; //n = 2^k //构造第一行数作为初始数据 int[][] a = new int[n][n]; for(int i = 0; i &lt; n; i++) a[0][i] = i + 1; /** * 将整个赛程表分为四个部分： * 左上角1：(0, i), 右上角2：(0, r + i) * 左下角3：(r, i), 右下角4：(r, r + i) * r为跨度，思想是将内容 1 复制到内容 4，将内容 2 复制到内容 3 */ //r是跨度，长度每次扩大一倍，跨度最小为1 for(int r = 1; r &lt; n; r &lt;&lt;= 1) for(int i = 0; i &lt; n; i += r &lt;&lt; 1) //起点每次跨越两倍长度 &#123; copy(a, r, r + i, 0, i, r); //左上角换到右下角 copy(a, r, i, 0, r + i, r); //右上角换到左下角 &#125; return a; &#125; public static void copy(int[][] a, int tox, int toy, int fromx, int fromy, int r) &#123; for(int i = 0; i &lt; r; i++) for(int j = 0; j &lt; r; j++) a[tox + i][toy + j] = a[fromx + i][fromy + j]; //System.out.println(); &#125;&#125; 运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-棋盘覆盖]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：棋盘覆盖编写语言：Java 问题描述：在一个 2^k×2^k 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.util.Scanner;public class BoardCover&#123; private static int[][] board; private static int num; //String[] 和 String... 的区别：一个是固定参数，一个是参数长度可变 public static void main(String... args) &#123; Scanner input = new Scanner(System.in); System.out.println("提示：棋盘大小必须为2的幂次方。" + "\n 输入的格式为：棋盘大小，特殊方格横坐标，特殊方格纵坐标" + "\n 分隔符为：英文逗号 + 空格，即 \", \"\n"); System.out.print("请输入数据："); String aryStr = input.nextLine(); String[] temp = aryStr.split(", "); int[] msg = new int[3]; for(int i = 0; i &lt; 3; i++) msg[i] = Integer.parseInt(temp[i]); board = new int[msg[0]][msg[0]]; cover(msg[0], msg[1], msg[2], 0, 0); //给特殊点赋值 board[msg[1]][msg[2]] = 0; for(int i = 0; i &lt; msg[0]; i++) &#123; for(int j = 0; j &lt; msg[0]; j++) System.out.print(board[i][j] + " "); System.out.println(); &#125; &#125; //参数含义：size为棋盘大小，x，y为特殊点坐标, sx，sy为棋盘起点坐标 public static void cover(int size, int x, int y, int sx, int sy) &#123; if(size == 1) return; int t = ++num; //函数递归的层数 int halfSize = size / 2; if(x &lt; sx + halfSize &amp;&amp; y &lt; sy + halfSize) //特殊点在左上角棋盘 &#123; cover(halfSize, x, y, sx, sy); &#125; else //特殊点不在左上角棋盘 &#123; //填充右下角为特殊点 int tx = sx + halfSize - 1; int ty = sy + halfSize - 1; board[tx][ty] = t; //填充剩余棋盘 cover(halfSize, tx, ty, sx, sy); &#125; if(x &gt;= sx + halfSize &amp;&amp; y &lt; sy + halfSize) //特殊点在右上角棋盘 &#123; cover(halfSize, x, y, sx + halfSize, sy); &#125; else //特殊点不在右上角棋盘 &#123; //填充左下角为特殊点 int tx = sx + halfSize; int ty = sy + halfSize - 1; board[tx][ty] = t; //填充剩余棋盘 cover(halfSize, tx, ty, sx + halfSize, sy); &#125; if(x &lt; sx + halfSize &amp;&amp; y &gt;= sy + halfSize) //特殊点在左下角棋盘 &#123; cover(halfSize, x, y, sx, sy + halfSize); &#125; else //特殊点不在左下角棋盘 &#123; //填充右上角为特殊点 int tx = sx + halfSize - 1; int ty = sy + halfSize; board[tx][ty] = t; //填充剩余棋盘 cover(halfSize, tx, ty, sx, sy + halfSize); &#125; if(x &gt;= sx + halfSize &amp;&amp; y &gt;= sy + halfSize) //特殊点在右下角棋盘 &#123; cover(halfSize, x, y, sx + halfSize, sy + halfSize); &#125; else //特殊点不在右下角棋盘 &#123; //填充左上角为特殊点 int tx = sx + halfSize; int ty = sy + halfSize; board[tx][ty] = t; //填充剩余棋盘 cover(halfSize, tx, ty, sx + halfSize, sy + halfSize); &#125; &#125;&#125; 运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-Strassen矩阵乘法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-Strassen%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：Strassen 矩阵乘法编写语言：Java 问题描述：我们知道，两个大小为 2 * 2 的矩阵相乘，一般需要进行 8 次乘法。而Strassen矩阵乘法可以减少一次乘法，只需要 7 次，看似很少，但当数据量很大时，效率就会有显著提升。不过使用 Strassen矩阵乘法需要满足 矩阵边长为 2 的幂次方。因为该算法会用到分治，如果分治后矩阵两边边长不等，结果会出错。 使用下面的方法计算结果矩阵，假设两个长度为 2 的矩阵是 A，B，相乘后的结果矩阵为 C：1234567M1 = A11(B12 - B22) 注：Anm 表示 A 矩阵第 n 行 k 列的值，Bnm，Cnm 同理M2 = (A11 + A12)B22M3 = (A21 + A22)B11 M4 = A22(B21 - B11)M5 = (A11 + A22)(B11 + B22)M6 = (A12 - A22)(B21 + B22)M7 = (A11 - A21)(B11 + B12) 可得结果为：1234C11 = M5 + M4 - M2 + M6C12 = M1 + M2C21 = M3 + M4C22 = M5 + M1 - M3 - M7 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172public class StrassenMatrixMultiply&#123; public static void main(String[] args) &#123; int[] a = new int[] &#123; 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4 &#125;; int[] b = new int[] &#123; 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4 &#125;; int length = 4; int[] c = sMM(a, b, length); for(int i = 0; i &lt; c.length; i++) &#123; System.out.print(c[i] + " "); if((i + 1) % length == 0) //换行 System.out.println(); &#125; &#125; public static int[] sMM(int[] a, int[] b, int length) &#123; if(length == 2) &#123; return getResult(a, b); &#125; else &#123; int tlength = length / 2; //把a数组分为四部分，进行分治递归 int[] aa = new int[tlength * tlength]; int[] ab = new int[tlength * tlength]; int[] ac = new int[tlength * tlength]; int[] ad = new int[tlength * tlength]; //把b数组分为四部分，进行分治递归 int[] ba = new int[tlength * tlength]; int[] bb = new int[tlength * tlength]; int[] bc = new int[tlength * tlength]; int[] bd = new int[tlength * tlength]; //划分子矩阵 for(int i = 0; i &lt; length; i++) &#123; for(int j = 0; j &lt; length; j++) &#123; /* * 划分矩阵： * 例子：将 4 * 4 的矩阵，变为 2 * 2 的矩阵， * 那么原矩阵左上、右上、左下、右下的四个元素分别归为新矩阵 */ if(i &lt; tlength) &#123; if(j &lt; tlength) &#123; aa[i * tlength + j] = a[i * length + j]; ba[i * tlength + j] = b[i * length + j]; &#125; else &#123; ab[i * tlength + (j - tlength)] = a[i * length + j]; bb[i * tlength + (j - tlength)] = b[i * length + j]; &#125; &#125; else &#123; if(j &lt; tlength) &#123; //i 大于 tlength 时，需要减去 tlength，j同理 //因为 b，c，d三个子矩阵有对应了父矩阵的后半部分 ac[(i - tlength) * tlength + j] = a[i * length + j]; bc[(i - tlength) * tlength + j] = b[i * length + j]; &#125; else &#123; ad[(i - tlength) * tlength + (j - tlength)] = a[i * length + j]; bd[(i - tlength) * tlength + (j - tlength)] = b[i * length + j]; &#125; &#125; &#125; &#125; //分治递归 int[] result = new int[length * length]; //temp：4个临时矩阵 int[] t1 = add(sMM(aa, ba, tlength), sMM(ab, bc, tlength)); int[] t2 = add(sMM(aa, bb, tlength), sMM(ab, bd, tlength)); int[] t3 = add(sMM(ac, ba, tlength), sMM(ad, bc, tlength)); int[] t4 = add(sMM(ac, bb, tlength), sMM(ad, bd, tlength)); //归并结果 for(int i = 0; i &lt; length; i++) &#123; for(int j = 0; j &lt; length; j++) &#123; if(i &lt; tlength) &#123; if(j &lt; tlength) result[i * length + j] = t1[i * tlength + j]; else result[i * length + j] = t2[i * tlength + (j - tlength)]; &#125; else &#123; if(j &lt; tlength) result[i * length + j] = t3[(i - tlength) * tlength + j]; else result[i * length + j] = t4[(i - tlength) * tlength + (j - tlength)]; &#125; &#125; &#125; return result; &#125; &#125; public static int[] getResult(int[] a, int[] b) &#123; int p1 = a[0] * (b[1] - b[3]); int p2 = (a[0] + a[1]) * b[3]; int p3 = (a[2] + a[3]) * b[0]; int p4 = a[3] * (b[2] - b[0]); int p5 = (a[0] + a[3]) * (b[0] + b[3]); int p6 = (a[1] - a[3]) * (b[2] + b[3]); int p7 = (a[0] - a[2]) * (b[0] + b[1]); int c00 = p5 + p4 - p2 + p6; int c01 = p1 + p2; int c10 = p3 + p4; int c11 = p5 + p1 -p3 - p7; return new int[] &#123;c00, c01, c10, c11&#125;; &#125; public static int[] add(int[] a, int[] b) &#123; int[] c = new int[a.length]; for(int i = 0; i &lt; a.length; i++) c[i] = a[i] + b[i]; return c; &#125; //返回一个数是不是2的幂次方 public static boolean adjust(int num) &#123; return (num &amp; (num - 1)) == 0; &#125;&#125; 运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-线性时间选择]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：线性时间选择编写语言：Java 问题描述：给定线性序集中 n 个元素和一个整数 k, 1 &lt;= k &lt;= n, 要求找出这 n 个元素中第 k 小的元素。即如果将这 n 个元素依其线性序排列时，排在第 k 个位置的元素即为要找的元素。 本篇博文代码会用到 分治法-快速排序 博文中用到的基准选择方法。方法使用位置：代码第 25 行方法实现位置：代码第 37 - 68 行 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.Random;public class RandomizedSelect&#123; public static void main(String[] args) &#123; int[] a = new int[] &#123;1, 3, 2, 6, 5, 8, 4, 9, 7, 0&#125;; int t = select(a, 0, a.length - 1, 4); //选出第四大的数 System.out.println(t); &#125; //参数含义：a为待查询的数组，low为起点，high为终点，target为带查询的目标 public static int select(int[] a, int low, int high, int target) &#123; if(low == high) return a[low]; //将数组以i为基准分为两部分，左边的都小于i，右边的都大于i //此处会用到快速排序算法中的划分方法来找基准 int i = randPart(a, low, high); int length = i - low + 1; //数组左半部分的长度 //如果第target小的数小于等于左半部分的长度，则这个数在此部分内 if(target &lt;= length) return select(a, low, i, target); //如果第target小的数大于左半部分的长度，则这个数在右半部分内， //且左半部分的数都小于第target小的数 else return select(a, i + 1, high, target - length); &#125; //划分寻找基准-随机化优化 public static int randPart(int[] a, int low, int high) &#123; Random r = new Random(); //随机产生一个 low 到 high 的整数 int flag = low + r.nextInt(high - low + 1); int pivot = a[flag]; //实际还是相当于以a[0]为基准 a[flag] = a[low]; a[low] = pivot; while(low &lt; high) &#123; //1、从右往左找比基准小的数 while(low &lt; high &amp;&amp; a[high] &gt; pivot) high--; if(low &lt; high) a[low] = a[high]; //2、从左往右找比基准大的数 while(low &lt; high &amp;&amp; a[low] &lt;= pivot) low++; if(low &lt; high) a[high] = a[low]; &#125; //将pivot放到low和high相遇的地方 a[high] = pivot; return high; &#125;&#125; 运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-归并排序]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：归并排序编写语言：Java 本篇博文代码是递归归并排序算法的实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MergeSort&#123; public static void main(String[] args) &#123; int[] ary = new int[] &#123;1, 3, 4, 5, 2, 7, 0, 6, 9, 8&#125;; System.out.print("排序前的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); sort(ary); System.out.print("排序后的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); &#125; public static int[] sort(int[] a) &#123; return sort(a, 0, a.length - 1); &#125; public static int[] sort(int[] a, int low, int high) &#123; //low == high 说明两者相遇，即数组大小为1 if(low &lt; high) //当数组尺寸不为1的时候进行递归排序操作 &#123; int mid = (low + high) / 2; sort(a, low, mid); //对左半部分排序 sort(a, mid + 1, high); //对右半部分排序 //对左右两半部分排序后，两者都有序， //但左半部分的值不一定小于右半部分，所以需要归并整理 merge(a, low, mid, high); //归并 &#125; return a; &#125; public static int[] merge(int[] a, int low, int mid, int high) &#123; int[] r = new int[high - low + 1]; //下表从零开始，数组大小多1 //i为待返回结果数组起点，j为左半部分数组起点，k为右半部分数组起点 int i = 0, j = low, k = mid + 1; while(j &lt;= mid &amp;&amp; k &lt;= high) &#123; if(a[j] &lt; a[k]) r[i++] = a[j++]; else r[i++] = a[k++]; &#125; //若有左半部分一个元素未加入 result 数组，此处可解决这个问题 while(j &lt;= mid) r[i++] = a[j++]; //若有由半部分一个元素未加入 result 数组，此处可解决这个问题 while(k &lt;= high) r[i++] = a[k++]; //将result数组拷入原数组对应位置 System.arraycopy(r, 0, a, low, r.length); return a; &#125;&#125; 运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-排列问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：全排列问题编写语言：Java 问题描述：显示 列表list(a, b, c, d……) 的全排列，显示的条目数为：n!代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//下面的例子将以 A B C 为例public class ArrayProblem&#123; public static void main(String[] args) &#123; char[] list = new char[] &#123;'A', 'B', 'C'&#125;; System.out.println("序列(A, B, C)的全排列为：\n"); array(list); &#125; //全排列的产生函数 public static void array(char[] list) &#123; array(list, 0, list.length); &#125; //产生 start 到 end 的全排列 public static void array(char[] list, int start, int end) &#123; if(start == end) &#123; for(int i = 0; i &lt; end; i++) System.out.print(list[i] + " "); System.out.println(); &#125; else &#123; for(int i = start; i &lt; end; i++) &#123; //交换 list[i] 和 list[k] 的位置(例：i = 1 时，start = 0， //交换 A B 的位置，此时为 B A C) char temp = list[i]; list[i] = list[start]; list[start] = temp; //第一个交换位置后，产生剩下的全排列序列(第一个为 B， //产生 A C 的全排列) array(list, start + 1, end); //将一个有序序列全排列后，恢复原状，防止出现重复的结果 //(会出现两个完全相同的序列，即一次排列输出两次, //可以注释掉下面三行代码，运行观察效果，然后分析原因) temp = list[i]; list[i] = list[start]; list[start] = temp; &#125; &#125; &#125;&#125; 运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-快速排序]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：快速排序编写语言：Java 本篇博文代码主要有两种基准选择方式：基准=低下标处的值，基准=随机值代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import java.util.Random;public class QuickSort&#123; public static void main(String[] args) &#123; int[] ary = new int[] &#123;1, 3, 4, 5, 2, 7, 0, 6, 9, 8&#125;; System.out.print("排序前的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); sort(ary); System.out.print("排序后的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); &#125; public static void sort(int[] a) &#123; sort(a, 0, a.length - 1); &#125; public static void sort(int[] a, int low, int high) &#123; //当low == high时就返回 //确保数组元素为1时就停止划分，防止数组下标越界 if(low &lt; high) &#123; int pivot = randPart(a, low, high); sort(a, low, pivot - 1); sort(a, pivot + 1, high); &#125; &#125; //划分寻找基准 public static int part(int[] a, int low, int high) &#123; int pivot = a[low]; while(low &lt; high) &#123; //1、从右往左找比基准小的数 while(low &lt; high &amp;&amp; a[high] &gt; pivot) high--; //a处赋值 if(low &lt; high) a[low] = a[high]; //此时是 a[high] &lt; pivot, a[low] &lt; pivot //2、从左往右找比基准大的数 while(low &lt; high &amp;&amp; a[low] &lt;= pivot) low++; //3、一次寻找结束，交换两个值 //b处赋值 if(low &lt; high) a[high] = a[low]; //此时是 a[high] &gt; pivot, a[low] &lt; pivot //a、b两处赋值，相当于一次交换，只是分开了 &#125; //将pivot放到left和right相遇的地方 a[high] = pivot; return high; &#125; //划分寻找基准-随机化优化 public static int randPart(int[] a, int low, int high) &#123; Random r = new Random(); //随机产生一个 low 到 high 的整数 int flag = low + r.nextInt(high - low + 1); int pivot = a[flag]; //此处交换保证 1 处的赋值不出错， //因为只要原 a[low] &lt; pivot，那么这个交换算法就失败了 a[flag] = a[low]; a[low] = pivot; while(low &lt; high) &#123; //1、从右往左找比基准小的数 while(low &lt; high &amp;&amp; a[high] &gt; pivot) high--; if(low &lt; high) a[low] = a[high]; //2、从左往右找比基准大的数 while(low &lt; high &amp;&amp; a[low] &lt;= pivot) low++; if(low &lt; high) a[high] = a[low]; &#125; //将pivot放到low和high相遇的地方 a[high] = pivot; return high; &#125;&#125; 运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
