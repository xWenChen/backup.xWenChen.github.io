<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[动态规划-最优二叉搜索树]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[算法思想：动态规划实际问题：最优二叉搜索树编写语言：Java 问题描述二叉搜索树的定义：满足以下任意两个条件的一个，就可称这棵树为二叉搜索树： 它是一棵空树 该树是一颗二叉树，非空，且满足下列两个条件： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值即当该二叉树非空时，使用中序遍历可以得到一个递增的有序序列 值得注意的是： 二叉搜索树的左右子树也是二叉搜索树，我们因此可以使用递归手段来构造二叉搜索树 一个有序序列的二叉搜索树不只一棵，这就为我们寻找最优二叉搜索树提供了可能 最优二叉搜索树指的是在一个序列的所有二叉搜索树中花费代价最小的那棵。 递归结构用C[i , j]表示从 i 到 j 的最优二叉查找树的代价，假设有n个顶点，那么我们的目标是要求C[1 , n]从 i 到 j 的一个最优二叉查找树是怎么得到的？它是从 i 到 j 之间的顶点中选出一个顶点来做root，假设选出的这个做root的顶点是 k （i &lt;= k &lt;= j）, 那么显然有： C[i , j] = min(C[i, k - 1] + C[k + 1, j]) + Sum(pi, pj)，其中：1 &lt;= i &lt;= j &lt;= n，i &lt;= k &lt;= j，pi表示遍历第i个结点的代价，Sum(pi, pj)表示求第i个结点到第j个结点的代价总和 上述求和公式最后为什么还要加一个求和结果呢？因为可以理解为公式前半部分只是找出最短路径，最后求和才是加上权重(网上有更详细更严谨的推导过程，可自行百度) Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class OptBST&#123; public static void main(String[] args) &#123; double[] p = new double[]&#123;0.1, 0.15, 0.2, 0.35, 0.2&#125;; Result r = getOptBST(p); for(int i = 0; i &lt; r.result.length; i++) &#123; for(int j = 0; j &lt; r.result.length; j++) System.out.print(r.root[i][j] + " "); System.out.println(); &#125; &#125; /** * 构造最优二叉搜索树的方法 * param p: 中序序列的点的查找概率数组，返回最优的二叉查找树的代价 */ public static Result getOptBST(double[] p) &#123; int n = p.length; //序列长度 Result r = new Result(n); for(int i = 0; i &lt; n; i++) &#123; //从i到i的最小代价(找到的概率)就是找到i的代价(概率) r.result[i][i] = p[i]; r.root[i][i] = i; //只有一个结点时，最优二叉搜索树就是它本身 &#125; for(int m = 1; m &lt; n; m++) //m代表二叉树的长度(所有结点的个数) &#123; for(int i = 0; i &lt; n - m; i++) //i为二叉树左起点 &#123; int j = i + m; //j为二叉树的右终点 double min = 1000000; //该变量存储最小代价 int tr = 0; //tr: temp root，临时变量，表示根节点 //求取最小值并记录根所在位置 for(int k = i; k &lt;= j; k++) &#123; //用r1表示result[i,k-1]，r2表示result[k+1,j] double r1 = 0, r2 = 0; if(i &lt; k) r1 = r.result[i][k - 1]; if(k &lt; j) r2 = r.result[k + 1][j]; if(min &gt; r1 + r2) &#123; min = r1 + r2; tr = k; &#125; &#125; r.root[i][j] = tr; double sum = 0; for(int s = i; s &lt;= j; s++) sum += p[s]; r.result[i][j] = min + sum; //递推公式体现在这里 &#125; &#125; return r; &#125;&#125;class Result //存储结果的类&#123; public double[][] result; //存储代价 public int[][] root; //存储构造路径 public Result(int n) &#123; result = new double[n][n]; root = new int[n][n]; &#125;&#125; 运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-最长公共子序列]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[算法思想：动态规划实际问题：最长公共子序列编写语言：Java 问题描述子序列：是一个给定序列的子序列是在该序列中删去若干元素后得到的序列。如X={A, B, C, D}, {A, C}是X的子序列，{A, B, D}是X的子序列。 问题描述：给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列，X和Y的所有公共子序列中长度最长的即是X和Y的最长公共子序列。 值得一提的是，最长公共子序列不只一个，但构造的时候只能构造出一个。 关键特征设序列X={x1, x2, x3, …, xm}和Y={y1, y2, y3, …, yn}的最长公共子序列为Z={z1, z2, z3, …, zk}，则： 若xm=yn, 则zk=xm=yn, 且Zk-1是Xm-1和Yn-1的最长公共子序列 若xm!=yn, 且zk!=xm, 则Z是Xm-1和Y的最长公共子序列 若xm!=yn, 且zk!=yn, 则Z是X和Yn-1的最长公共子序列 其中：Xm-1={x1, x2, …, xm-1}，Yn-1={y1, y2, …, yn-1}，Zk-1={z1, z2, …, zk-1}。 递归结构用c[i][j]记录序列Xi和Yj的最长公共子序列长度，那么： 当i=0, j=0时，c[i][j]=0 当i&gt;0, j&gt;0, xi=yj时，c[i][j] = c[i-1][j-1]+1 当i&gt;0, j&gt;0,xi!=yj时，c[i][j] = max{c[i][j-1], c[i-1][j]} 其中，第3点是说当xm!=yn时，求取Xm-1, Y和X, Yn-1两者的最长公共子序列的较长者作为整体的最长公共子序列 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class LongestCommonSubsequence&#123; public static void main(String[] args) &#123; //第一个字符留空，可以省去后续很多麻烦 char[] x = new char[]&#123;' ', 'A', 'B', 'C', 'B', 'D', 'A', 'B'&#125;; char[] y = new char[]&#123;' ', 'B', 'D', 'C', 'A', 'B', 'A'&#125;; int m = x.length; int n = y.length; int[][] c = new int[m][n]; int[][] b = new int[m][n]; lcsLength(m - 1, n - 1, x, y, c, b); lcs(m - 1, n - 1, x, b); //从m-1，n-1开始往下面找 System.out.println(); &#125; /** * 参数含义： * m: X序列的长度 * n: Y序列的长度 * x, y: 待求最长公共子序列的原始序列 * c: 记录Xi和Yj的最长公共子序列长度 * b: 记录得到c[i][j]的是哪个子问题 */ public static void lcsLength(int m, int n, char[] x, char[] y, int[][] c, int[][] b) &#123; for(int i = 0; i &lt; m; i++) c[i][0] = 0; for(int i = 0; i &lt; n; i++) c[0][i] = 0; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(x[i] == y[j]) &#123; c[i][j] = c[i - 1][j - 1] + 1; b[i][j] = 1; &#125; else if(c[i-1][j] &gt; c[i][j - 1]) &#123; c[i][j] = c[i - 1][j]; b[i][j] = 2; &#125; else &#123; c[i][j] = c[i][j - 1]; b[i][j] = 3; &#125; &#125; &#125; &#125; /** * 该方法构造一个X，Y的最长公共子序列 * 参数含义： * i, j: 序列X, Y的下标 * x: 原始序列，因为构造的是X, Y的最长公共子序列。 * 此处用Y也行，因为x有的y也有。 * 但是序列应全程保持一致(一开始用X，整个函数都用X) * b: 用于构造子序列的二维数组 */ public static void lcs(int i, int j, char[] x, int[][] b) &#123; if(i == 0 || j == 0) return; if(b[i][j] == 1) &#123; lcs(i - 1, j - 1, x, b); System.out.print(x[i] + " "); &#125; else if(b[i][j] == 2) lcs(i - 1, j, x, b); else lcs(i, j - 1, x, b); &#125;&#125; 运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-01背包问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[算法思想：动态规划实际问题：01背包问题编写语言：Java 问题描述给定n种物品和一个背包，物品i的重量为wi，其价值是vi，背包的容量为c，问应如何向背包装入物品，使得背包中的物品价值最大。每个物品拿取或者不拿两种选择。不能选择装入某物品的一部分，也不能装入同一物品多次。 递归结构声明一个大小为m[n][c]的二维数组，m[i][j]表示在面对第i件物品，且背包容量为j时所能获得的最大价值。则： m[i][j]=m[i-1][j]，j&lt;w[i]。其表示：背包容量不足以放下第i件物品，只能选择不拿。 m[i][j]=max{m[i-1][j], m[i-1][j-wi]+vi}，j&gt;=w[i]。其表示：这时背包容量可以放下第i件物品，我们就要考虑拿这件物品是否能获取更大的价值。前者表示不装第i件物品的最大价值，后者表示装了第i件物品的最大价值，并为第i件物品预留了wi的容量。 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class OneZeroKnapsackProblem&#123; public static void main(String[] args) &#123; //以下数组第0位(第0行，第0列)都不存储数据 int[] v = new int[]&#123;0, 8, 10, 6, 3, 7, 2&#125;; //每件物品的价值 int[] w = new int[]&#123;0, 4, 6, 2, 2, 5, 1&#125;; //每件物品的重量 int c = 12; //背包的容量 int n = v.length - 1; //物品的数量 int[][] m = new int[n + 1][c + 1]; //总价值数组 int[] r = new int[n + 1]; //构造最优解的数组 for(int i = 0; i &lt;= n; i++) &#123; for(int j = 0; j &lt;= c; j++) m[i][j] = 0; r[i] = 0; &#125; knapsack(v, w, c, n, m); traceback(m, w, c, n, r); System.out.println("物品数量为 " + n + " ，背包容量为 " + c); System.out.print("各个物品的价值为："); for(int i = 1; i &lt;= n; i++) &#123; System.out.print(v[i] + " "); &#125; System.out.println(); System.out.print("各个物品的重量为："); for(int i = 1; i &lt;= n; i++) &#123; System.out.print(w[i] + " "); &#125; System.out.println(); System.out.println("最多价值为：" + m[n][c]); System.out.print("放入的物品为："); for(int i = 1; i &lt;= n; i++) System.out.print(r[i] + " "); System.out.println(); &#125; /** * 该方法计算最优解： * @param v 存储每个物品的价值 * @param w 存储每个物品的重量 * @param c 存储背包容量 * @param n 物品数量 * @param m 存储构造的最优解 */ public static void knapsack(int[] v, int[] w, int c, int n, int[][] m) &#123; //物品从第1件物品开始计算 for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= c; j++) &#123; if(j &gt;= w[i]) &#123; m[i][j] = max(m[i - 1][j], m[i - 1][j - w[i]] + v[i]); &#125; else &#123; m[i][j] = m[i - 1][j]; &#125; &#125; &#125; &#125; /** * 该方法构造最优解的生成过程： * @param m 存储最优解的数组 * @param w 存储每个物品的重量 * @param c 存储背包容量 * @param n 物品数量 * @param x 存储最优解生成过程的数组 */ public static void traceback(int[][] m, int[] w, int c, int n, int[] x) &#123; for(int i = 1; i &lt;= n; i++) &#123; if(m[i][c] == m[i - 1][c]) //第i件物品为未放入 &#123; x[i] = 0; &#125; else //第i件放入 &#123; x[i] = 1; c -= w[i]; &#125; &#125; &#125; public static int max(int a, int b) &#123; return a &gt; b ? a : b; &#125;&#125; 运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-多边形游戏]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[算法思想：动态规划实际问题：多边形游戏编写语言：Java 前言多边形游戏问题是矩阵连乘的最优计算次序问题与凸多边形最优三角剖分问题的推广。我在解决凸多边形最优三角剖分问题时偶然间看到了这个结论，便跳过了该问题，直接解决其推广的问题，即多边形游戏问题。对于凸多边形最优三角剖分问题有兴趣的读者，可以自行百度。 问题描述有一个由n个顶点构成的多边形。每个顶点被赋予一个整数值，每条边被赋予一个运算符。每条边被赋予一个运算符+或*。所有边依次用整数1到n编号。游戏规则： 删去一条边 后续步骤按以下方式操作： 选择一条边E及边E的两个顶点v1和v2 用一个新的顶点v取代边E及由E连接着的2个顶点，将2个顶点上的数值由E上的运算符获得结果，病赋值给新的顶点v。最后，所有的边都被删除，游戏结束，得到游戏分数(最后顶点上的整数值) 问题：对于给定的多边形，计算最高得分 关键特征设给定的多边形的顶点和边的顺时针序列为 op[1], v[1], op[2], v[2], …, op[n], v[n]。其中 op[i] 表示第 i 边所对应的运算符，v[i] 表示第 i 个顶点上的数值，1 &lt;= i &lt;= n。 在所给定的多边形中，从顶点 i 开始，长度为 j(链中有 j 个顶点) 的顺时针链 p(i, j) 可表示为 v[i], op[i + 1], …, v[i + j - 1]。如果这条链的最后一次合并运算发生在 op[i + s] 处，则可在 op[i + s] 处将链分为两个子链 p(i, s) 和 p(i + s, j - s)。 设 m1 是子链 p(i, s) 内部合并得到的值，设 a 和 b 是子链 p(i, s) 内部合并可能得到的最小值和最大值；设 m2 是子链 p(i + s, j - s) 内部合并得到的值，设 c 和 d 是子链 p(i + s, j - s) 内部合并可能得到的最小值和最大值。则有：a &lt;= m1 &lt;= b, c &lt;= m2 &lt;= d。而两个子链合并得到的结果 m = (m1)opi + s。分析运算符的情况可得： 当op[i + s] = ‘+’时，显然有 a + c &lt;= m &lt;= b + d。即链 p(i, j) 合并的最优性可由子链 p(i, s) 和 p(i + s, j - s) 的最优性推出。且最大值对应子链的最大值，最小值对应子链的最小值。 当op[i + s] = ‘*’时，考虑到 v[i] 可以取负整数，显然有 min{ac, ad, bc, bd} &lt;= m &lt;= max{ac, ad, bc, bd}，亦可由子链的最有性推出原链的最优性。 综上，可得多边形游戏问题满足最优子结构性质 递归结构设 m[i, j, 0] 是链 p(i, j) 合并的最小值，m[i, j, 1] 是链 p(i, j) 合并的最大值，并设最优合并在 op[i+s] 处，为方便起见，记：a=m[i, i+s, 0], b=m[i, i+s, 1], c=m[i+s, j-s, 0], d=[i+s, j-s, 1]，则关系式满足： 当 op[i+s]=’+’, min(i, j, s) = a+c, max(i, j, s) = b+d 当 op[i+s]=’*’, min(i, j, s) = min(ac, ad, bc, bd), max(i, j, s) = max(ac, ad, bc, bd) 由此可知 m[i, j, 0]=min(min(i, j, s)), m[i, j, 1]=max(max(i, j, s))，其中 1 &lt;= s &lt;= j - 1，这是个循环求值的过程。 Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//本代码所用示例为：+ -7 + 4 * 2 * 5public class PolygonGame&#123; static int n; //边和点个数 static int minf, maxf; static int[] v; //点集 static char[] op; //边集 static int[][][] m; //存储最终计算结果 public static void main(String[] args) &#123; n = 4; //以下所有数组下标为0的都不使用 //构造出的多边形的最终结果：+ -7 + 4 * 2 * 5 v = new int[]&#123;Integer.MIN_VALUE, -7, 4, 2, 5&#125;; op = new char[] &#123;' ', '+', '+', '*', '*'&#125;; m = new int[n + 1][n + 1][2]; for(int i = 1; i &lt;= n; i++) &#123; //m[i][j][0]：表示链的起点为i，长度为j时的结果最小值 m[i][1][0] = v[i]; //m[i][j][1]：表示链的起点为i，长度为j时的结果最大值 m[i][1][1] = v[i]; &#125; int result = polyMax(); System.out.println(result); &#125; /** * 参数含义： * i：链的起点 * s：断开位置 * j：链长度 * */ public static void minMax(int i,int s,int j) &#123; int[] e = new int[n + 1]; int a = m[i][s][0], b = m[i][s][1], r = (i + s - 1) % n + 1, //多边形是封闭的，不能出现下标溢出 c = m[r][j - s][0], d = m[r][j - s][1]; if(op[r] == '+') &#123; minf = a + c; maxf = b + d; &#125; else &#123; e[1] = a * c; e[2] = a * d; e[3] = b * c; e[4] = b * d; minf = e[1]; maxf = e[1]; for(int k = 2; k &lt; 5; k++) &#123; if(minf &gt; e[k]) minf = e[k]; if(maxf &lt; e[k]) maxf = e[k]; &#125; &#125; &#125; public static int polyMax() &#123; for(int j = 2; j &lt;= n; j++) //链的长度 //链的起点，多边形是封闭的，不会存在什么问题 for(int i = 1; i &lt;= n; i++) for(int s = 1; s &lt; j; s++) //断开的位置 &#123; minMax(i, s, j); if(m[i][j][0] &gt; minf) m[i][j][0] = minf; if(m[i][j][1] &lt; maxf) m[i][j][1] = maxf; &#125; int temp = m[1][n][1]; for(int i = 1; i &lt;= n; i++) if(temp &lt; m[i][n][1]) &#123; temp = m[i][n][1]; &#125; return temp; &#125;&#125; 运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-最大子段和]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%2F</url>
    <content type="text"><![CDATA[算法思想：动态规划实际问题：最大子段和编写语言：Java 前言最大子段和有多种解法，暴力破解法是最简单的，但时间复杂度较高，最少需要 O(n^2)，未改进的算法为 O(n^3)；而且暴力破解这种思路对学习算法是没有帮助的。因此个人并未实现。仅对分治法和动态规划两种思路进行了实现。分治法的解决思路详见分治法-最大子段和，分治法解决最大子段和问题需要的时间复杂度为 O(nlogn)，而本篇博文是采用动态规划的思路，动态规划解决最大子段和问题需要的时间复杂度为 O(n)。是最好的一种解决办法。 问题描述给定n个整数（可能为负数）组成的序列 a[1],a[2],a[3],…,a[n], 求该序列如 a[i]+a[i+1]+…+a[j] 的子段和的最大值。当所给的整数均为负数时定义子段和为0，依此定义，所求的最优值为： Max{0,a[i]+a[i+1]+…+a[j]}, 1&lt;=i&lt;=j&lt;=n 例如，当（a[1],a[2],a[3],a[4],a[5],a[6]）=(-2,11,-4,13,-5,-2) 时，最大子段和为20。 递归结构设 b[j] 存储的是 A[i:j] 的最大字段和，其中 1 &lt;= i &lt;= j，再定义一个 sum 存储最终结果，那么： 当 b[j - 1] &lt;= 0，b[j] = a[j]，即当目前子序列 A[i:j - 1] 的和为负数时，给和不停的赋新值，直到和为正。 当 b[j - 1] &gt; 0，b[j] = b[j - 1] + a[j]，即当目前子序列 A[i:j - 1] 的和为正时，加上子序列中的下一个数，得到一个新的和 b[j]。 将 b[j] 和 sum 比较，若 b[j] &gt; sum，那么给 sum 赋新值 b[j]；若 b[j] &lt; sum，俺么保持 sum 值不变。通过这种方式来保持 sum 为子序列的最大值。 Java代码12345678910111213141516171819202122232425public class MaxSubsequenceSum&#123; public static void main(String[] args) &#123; int[] a = new int[]&#123;-2, 11, -4, 13, -5, -2&#125;; int result = maxSubSum(a); System.out.println("maxSubSum(a) = " + result); &#125; public static int maxSubSum(int[] a) &#123; int sum = 0, b = 0; for(int i = 0; i &lt; a.length; i++) &#123; if(b &gt; 0) b += a[i]; //当 b &lt;= 0 时，不断赋新值，相当于跳过了负数 else b = a[i]; if(b &gt; sum) sum = b; &#125; return sum; &#125;&#125; 运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-硬币问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[算法思想：动态规划实际问题：硬币问题编写语言：Java 问题描述假设有 1 元，3 元，5 元的硬币若干（无限），现在需要凑出 n 元。问如何组合才能使硬币的数量最少？ 关键特征要推出问题的关键特征与递归关系，必要的例子是少不了的。 我们先假设一个函数 d(i) 来表示需要凑出 i 的总价值需要的最少硬币数量，那么： 当 i = 0 时，很显然我们可以知道 d(0) = 0。因为不要凑钱了嘛，当然也不需要任何硬币了。注意这是很重要的一步，其后所有的结果都从这一步延伸开来。 当 i = 1 时，因为我们有 1 元的硬币，所以直接在第 1 步的基础上，加上 1 个 1 元硬币，得出 d(1) = 1。 当 i = 2 时，因为我们并没有 2 元的硬币，所以只能拿 1 元的硬币来凑。在第 2 步的基础上，加上 1 个 1 元硬币，得出 d(2) = 2。 当 i = 3 时，我们可以在第 3 步的基础上加上 1 个 1 元硬币，得到 3 这个结果。但其实我们有 3 元硬币，所以这一步的最优结果不是建立在第 3 步的结果上得来的，而是应该建立在第 1 步上，加上 1 个 3 元硬币，得到 d(3) = 1。 接着就不再举例了，推导过程和上面一样。 递归结构我们来分析一下上述过程。可以看出，除了第 1 步这个看似基本的公理外，其他往后的结果都是建立在它之前得到的某一步的最优解上，加上 1 个硬币得到。即：d(i) = d(j) + 1，此处 j &lt; i，但是在上述例子中我们发现 i = 3 时，有两个解，但我们选择了第二个解，即： d(i) = min(d(j) + 1) 有了结构，思路就清晰了，代码写起来也就很方便了。 Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//以下例子中 n 的数值取 11public class CoinProblem&#123; public static void main(String[] args) &#123; int[] coins = new int[]&#123;1, 3, 5&#125;; //硬币的面值 int money = 11; //待求取的目标数额 int[] result = getLeastCoins(coins, money); System.out.print("硬币的面值为："); for(int i = 0; i &lt; coins.length; i++) &#123; System.out.print(coins[i] + " "); &#125; System.out.println(); for(int i = 0; i &lt; result.length; i++) &#123; System.out.println("要凑齐数额 " + i + " 最少需要 " + result[i] + " 个硬币"); &#125; &#125; /** * param coins 存储硬币面值的数组 * param money 待求取的目标数额 * return result 存储各个数额所需最少硬币的数组 */ public static int[] getLeastCoins(int[] coins, int money) &#123; int[] result = new int[money + 1]; result[0] = 0; //数额0只需0个便可凑齐 for(int i = 1; i &lt; result.length; i++) result[i] = 10000; //初始化时各个数额需要最大上限个硬币 for(int i = 1; i &lt;= money; i++) &#123; for(int coin : coins) &#123; if(coin &lt;= i) &#123; int min = 10000; //存储中间结果的变量，初始化为最大硬币上限 min = result[i - coin] + 1; if(result[i] &gt; min) result[i] = min; &#125; &#125; &#125; return result; &#125;&#125; 运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-矩阵连乘]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%2F</url>
    <content type="text"><![CDATA[算法思想：动态规划实际问题：矩阵连乘编写语言：Java 问题描述给定 n 个矩阵{A1, A2, A3, …, An}，其中Ai 与 Aj 是可乘的，j = i + 1, i = 1, 2, 3, …, n - 1。考察这 n 个矩阵的连乘积所需的最少乘法次数。 举例：数组：A(2, 3), B(3, 5), C(5, 7), 其中A(n, m) 表示 n 行 m 列的矩阵。若按照(A B) C 的顺序计算，那么有 2 3 5 + 2 5 7 = 30 + 70 = 100 次乘法计算，而如果按照 A (B C) 的次序计算，那么有 2 3 7 + 3 5 7 = 42 + 105 = 147 次乘法计算，可以看出，两个计算方法的结果是有差异的。那么寻找最少乘法次数(最优解)是确实有必要的。 关键特征计算 A[1:n] 的最优次序所包含的计算矩阵子链 A[1:k] 和 A[k+1:n] 的次序也是最优的。事实上，若假设 A[1:k] 的计算次序不是最优的，在 A[k+1:n] 的计算次序不变的情况下，总次序会更少，此时就需要替换原次序。A[1:n] 的最优次序 k 的位置不变，只是 A[1:k] 的计算次序变了。综上，原问题包含了其子问题的解，这就是矩阵连乘的最优子结构性质。 递归关系设计算 A[i:j] 所需的最少乘积次数为m[i][j]，则原问题的最优解为m[1][n]。其中 1 &lt;= i &lt;= j &lt;= n，并且有： 当 i = j 时，A[i:j] = A 为单一矩阵，无须计算，因此 m[i][i] = 0; 当 i &lt; j 时，可利用最优子结构性质来计算m[i][j]，m[i][j] = min{m[i][k] + m[k+1][j] + pi-1 pk pj}，其中 i &lt;=k &lt; j，pi-1 pk pj 表示左右两个子链相乘，即它们分别表示左行、左列、右列。 另外，将 m[i][j] 的断开位置记为 s[i][j]，方便后续构造相应的最优解 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public class MatrixSuccessiveMultiplication&#123; /** * 全局变量含义： * p：表示矩阵链，其中矩阵 Ai 的维度为 p[i][0] * p[i][1] * m：m[i][j] 存储 A[i:j] 所需的最少乘积次数为m * s：s[i][j] 存储 m[i][j] 的断开位置 k */ private static int[][] p; private static int[][] m; private static int[][] s; public static void main(String[] args) &#123; //matrix[i] 表示第 i 个矩阵 /** * 下面 6 个矩阵：A1: 30 * 35; A2: 35 * 15; A3: 15 * 5 * A4: 5 * 10; A5: 10 * 20; A6 20 * 25 */ p = new int[][] &#123;&#123;30, 35&#125;, &#123;35, 15&#125;, &#123;15, 5&#125;, &#123;5, 10&#125;, &#123;10, 20&#125;, &#123;20, 25&#125; &#125;; int l = p.length; m = new int[l][l]; // 6 = matrix.length s = new int[l][l]; matrixChain(l); /* * 输出 result 和 place 数组查看结果，start 到 end 段代码可以不要 */ //start for(int i = 0; i &lt; l; i++) &#123; for(int j = i; j &lt; l; j++) System.out.print(m[i][j] + " "); System.out.println(); &#125; for(int i = 0; i &lt; l; i++) &#123; for(int j = i; j &lt; l; j++) System.out.print(s[i][j] + " "); System.out.println(); &#125; //end //输出最优解 traceback(0, l - 1); System.out.println("\n" + memoizedMatrixChain(l - 1)); &#125; /** * 参数含义： * p：表示矩阵链，其中矩阵 Ai 的维度为 p[i][0] * p[i][1] * n：表示矩阵链中矩阵的个数 * m：m[i][j] 存储 A[i:j] 所需的最少乘积次数为m * s：s[i][j] 存储 m[i][j] 的断开位置 k */ public static void matrixChain(int n) &#123; //m[i][i] 不需要计算，结果为0 for(int i = 0; i &lt; n; i++) m[i][i] = 0; //mcLength: matrixChainLength: 矩阵链长度，最小为2 for(int mcLength = 2; mcLength &lt;= n; mcLength++) &#123; //l: left为矩阵链左起点 for(int l = 0; l &lt; n - mcLength + 1; l++) &#123; //r: right为矩阵链右终点 int r = l + mcLength - 1; //先算整条链从左到右的计算次数，不切割 /* * 计算方法为最左边的矩阵乘上右终点矩阵结果的列， * 再加上右边矩阵链的乘积 */ m[l][r] = m[l + 1][r] + p[l][0] * p[l][1] * p[r][1]; s[l][r] = l; //断开位置为矩阵l //b: break为中间断开位置 for(int b = l + 1; b &lt; r; b++) &#123; /* * 矩阵l的行为左边矩阵链的行 * 矩阵b的列为左边矩阵链的列 * 矩阵r的列为右边矩阵链的列 */ int t = m[l][b] + m[b + 1][r] + p[l][0] * p[b][1] * p[r][1]; if(t &lt; m[l][r]) &#123; m[l][r] = t; s[l][r] = b; &#125; &#125; &#125; &#125; &#125; /* * 动态规划的备忘录方法，自顶而下的递归，参数含义与上面的函数相同 * 备忘录方法是给记录项存入一个初始值，表示问题尚未解决。每次求解子问题时， * 先查看该值，若是初始值，表示该子问题尚未计算，计算值。若不是初始值， * 表示该子问题已计算过，直接返回即可。 */ public static int memoizedMatrixChain(int n) &#123; for(int i = 0; i &lt; n; i++) for(int j = i; j &lt; n; j++) m[i][j] = 0; return lookupChain(0, n); &#125; /** * 检查整条链的最优计算次序和断开位置，此方法使用于备忘录方法中 * 参数含义： * l: left为矩阵链左起点 * r: right为矩阵链右终点 * 返回值是矩阵链l到r的计算次序 */ public static int lookupChain(int l, int r) &#123; if(m[l][r] &gt; 0) return m[l][r]; if(l == r) return 0; int u = lookupChain(l + 1, r) + p[l][0] * p[l][1] * p[r][1]; s[l][r] = l; for(int k = l + 1; k &lt; r; k++) &#123; int t = lookupChain(l, k) + lookupChain(k + 1, r) + p[l][0] * p[k][1] * p[r][1]; if(t &lt; u) &#123; u = t; s[l][r] = k; &#125; &#125; m[l][r] = u; return u; &#125; /** * 函数求矩阵链最少乘积结果的断开位置，使用了递归方法，自底而上 * 参数说明： * i: 矩阵链左起点 * j: 矩阵链右终点 * s: 断开位置的存储矩阵 */ public static void traceback(int i, int j) &#123; if(i == j) return; //s[i][j]是断开位置，s[i][j] + 1是断开位置的下一个矩阵 traceback(i, s[i][j]); traceback(s[i][j] + 1, j); System.out.print("A[" + i + ", " + j + "] = "); System.out.println("A[" + i + ", " + s[i][j] + "] + A[" + (s[i][j] + 1) + ", " + j + "]"); &#125;&#125; 运行结果说明：第一个结果为 m[i][j] 的值，第二个结果为 s[i][j] 的值，第三个结果为矩阵连乘中的计算次序，第四个结果为最少所需的计算次数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-总览]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E8%A7%88%2F</url>
    <content type="text"><![CDATA[思想描述动态规划问题是面试题中的热门话题，动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。 算法特征 求一个问题的最优解 大问题可以分解为子问题，子问题还有重叠的更小的子问题 整体问题最优解取决于子问题的最优解（状态转移方程） 从上往下分析问题，从下往上解决问题 讨论底层的边界问题博文导航 动态规划-矩阵连乘 动态规划-硬币问题 动态规划-最大子段和 动态规划-多边形游戏 动态规划-01背包问题 动态规划-最长公共子序列 动态规划-最优二叉搜索树]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>总览</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-最大子段和]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：最大子段和编写语言：Java 问题描述此篇博文是分治法解决最大子段和问题的实现。问题描述：给定由n个整数(可能为负数)组成的序列A={a1, a2, …, an}，求该序列形如sum(A, i, j)的子段和的最大值。当所有整数均为负整数时，定义其最大子段和为0，依次定义，所求的最大值为：max{0, sum(A, i, j)}， 例如：(a1, a2, a3, a4, a5, a6)=(-2, 11, -4, 13, -5, -2)时，最大子段和为sum(A, 2, 4)=20算法思想： 1. sum(A, 1, n)==sum(A, 1, n/2) 2. sum(A, 1, n)==sum(A, n/2+1, n) 3. sum(A, 1, n)==sum(A, i, j), 其中 1&lt;=i&lt;=n/2, n/2+1&lt;=j&lt;=n 解释：即序列A的最大子段和可能在A的左半部分，也可能在A的右半部分，还可能跨越了A的左右两个部分 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MaxSubsequenceSum&#123; public static void main(String[] args) &#123; int[] a = new int[]&#123;-2, 11, -4, 13, -5, -2&#125;; int result = maxSubSum(a, 0, a.length - 1); System.out.println("maxSubSum(a) = " + result); &#125; /** * 使用分治思想求取最大子段和 * 参数含义： * a: 待求取最大子段和的数组 * left：子段起点 * right：子段终点 */ public static int maxSubSum(int[] a, int left, int right) &#123; int sum = 0; //sum为总的最大子段和 if(left == right) sum = a[left] &gt; 0 ? a[left] : 0; else &#123; int mid = (left + right) / 2; /* * 分治求解 */ //求左子段的和 int leftSum = maxSubSum(a, left, mid); //求右子段的和 int rightSum = maxSubSum(a, mid + 1, right); //求跨越左右两段的子段和：开始 int maxLefts = 0; int lefts = 0; /* * 子段是连续的，从中间向两边扩散 * 若是从左半部分从左边开始计算子段和，可能会导致整体的 * 左右子段不连续，故左半部分子段和从右边往左边运算， * 右半部分子段和从左边往右边运算，保证整体的子段连续 */ for(int i = mid; i &gt;= left; i--) &#123; lefts += a[i]; if(lefts &gt; maxLefts) maxLefts = lefts; &#125; int maxRights = 0; int rights = 0; for(int i = mid + 1; i &lt; right; i++) &#123; rights += a[i]; if(rights &gt; maxRights) maxRights = rights; &#125; sum = maxLefts + maxRights; //求跨越左右两段的子段和：结束 //判断得到最大子段和 if(sum &lt; leftSum) sum = leftSum; if(sum &lt; rightSum) sum = rightSum; &#125; return sum; &#125;&#125; 运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-总览]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E6%80%BB%E8%A7%88%2F</url>
    <content type="text"><![CDATA[思想描述分治法是一种算法思想，其设计思想为：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，这些子问题相互独立且与原问题相同。从而达到各个击破，分而治之的目的。在实际应用中，分治法往往会和递归算法结合在一起。递归的概念：直接或者间接地调用自身的算法称为递归算法，用函数自身给出定义的函数称为递归函数。如下面的就是递归函数的一个简单例子：12345678//此递归函数用来求斐波那契数列第n项的值public static int getSum(int n)&#123; if(n &lt;= 1) return 1; else return getSum(n - 1) + getSum(n - 2);&#125; 博文导航 分治法-排列问题 分治法-归并排序 分治法-快速排序 分治法-棋盘覆盖 分治法-最大子段和 分治法-线性时间选择 分治法-循环赛日程表 分治法-Strassen矩阵乘法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
        <tag>总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法总览]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88%2F</url>
    <content type="text"><![CDATA[算法的重要性我不陈述了。这是一篇算法部分的总览导航文。参考书籍：《计算机算法设计与分析第4版》（王晓东著，电子工业出版社） 分治法-总览 动态规划-总览]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-循环赛日程表]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E5%BE%AA%E7%8E%AF%E8%B5%9B%E6%97%A5%E7%A8%8B%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：循环赛日程表编写语言：Java 问题描述假设有 n = 2^k 个运动员进行循环赛，要根据以下限制生成一个日程表： 1. 每个选手必须与其他 n - 1 个选手各赛一次 2. 每个选手一天只能赛一次 3. 循环赛一共进行 n - 1 天 生成内容：n行，n - 1列的表b，b(i)(j)表示选手i在j天遇到的对手 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class RoundRobinSchedule&#123; public static void main(String[] args) &#123; int[][] table = getTable(3); for(int i = 0; i &lt; table.length; i++) &#123; for(int j = 0; j &lt; table[0].length; j++) System.out.print(table[i][j] + " "); System.out.println(); &#125; &#125; public static int[][] getTable(int k) &#123; int n = 1 &lt;&lt; k; //n = 2^k //构造第一行数作为初始数据 int[][] a = new int[n][n]; for(int i = 0; i &lt; n; i++) a[0][i] = i + 1; /** * 将整个赛程表分为四个部分： * 左上角1：(0, i), 右上角2：(0, r + i) * 左下角3：(r, i), 右下角4：(r, r + i) * r为跨度，思想是将内容 1 复制到内容 4，将内容 2 复制到内容 3 */ //r是跨度，长度每次扩大一倍，跨度最小为1 for(int r = 1; r &lt; n; r &lt;&lt;= 1) for(int i = 0; i &lt; n; i += r &lt;&lt; 1) //起点每次跨越两倍长度 &#123; copy(a, r, r + i, 0, i, r); //左上角换到右下角 copy(a, r, i, 0, r + i, r); //右上角换到左下角 &#125; return a; &#125; public static void copy(int[][] a, int tox, int toy, int fromx, int fromy, int r) &#123; for(int i = 0; i &lt; r; i++) for(int j = 0; j &lt; r; j++) a[tox + i][toy + j] = a[fromx + i][fromy + j]; //System.out.println(); &#125;&#125; 运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-棋盘覆盖]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：棋盘覆盖编写语言：Java 问题描述在一个 2^k×2^k 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.util.Scanner;public class BoardCover&#123; private static int[][] board; private static int num; //String[] 和 String... 的区别：一个是固定参数，一个是参数长度可变 public static void main(String... args) &#123; Scanner input = new Scanner(System.in); System.out.println("提示：棋盘大小必须为2的幂次方。" + "\n 输入的格式为：棋盘大小，特殊方格横坐标，特殊方格纵坐标" + "\n 分隔符为：英文逗号 + 空格，即 \", \"\n"); System.out.print("请输入数据："); String aryStr = input.nextLine(); String[] temp = aryStr.split(", "); int[] msg = new int[3]; for(int i = 0; i &lt; 3; i++) msg[i] = Integer.parseInt(temp[i]); board = new int[msg[0]][msg[0]]; cover(msg[0], msg[1], msg[2], 0, 0); //给特殊点赋值 board[msg[1]][msg[2]] = 0; for(int i = 0; i &lt; msg[0]; i++) &#123; for(int j = 0; j &lt; msg[0]; j++) System.out.print(board[i][j] + " "); System.out.println(); &#125; &#125; //参数含义：size为棋盘大小，x，y为特殊点坐标, sx，sy为棋盘起点坐标 public static void cover(int size, int x, int y, int sx, int sy) &#123; if(size == 1) return; int t = ++num; //函数递归的层数 int halfSize = size / 2; if(x &lt; sx + halfSize &amp;&amp; y &lt; sy + halfSize) //特殊点在左上角棋盘 &#123; cover(halfSize, x, y, sx, sy); &#125; else //特殊点不在左上角棋盘 &#123; //填充右下角为特殊点 int tx = sx + halfSize - 1; int ty = sy + halfSize - 1; board[tx][ty] = t; //填充剩余棋盘 cover(halfSize, tx, ty, sx, sy); &#125; if(x &gt;= sx + halfSize &amp;&amp; y &lt; sy + halfSize) //特殊点在右上角棋盘 &#123; cover(halfSize, x, y, sx + halfSize, sy); &#125; else //特殊点不在右上角棋盘 &#123; //填充左下角为特殊点 int tx = sx + halfSize; int ty = sy + halfSize - 1; board[tx][ty] = t; //填充剩余棋盘 cover(halfSize, tx, ty, sx + halfSize, sy); &#125; if(x &lt; sx + halfSize &amp;&amp; y &gt;= sy + halfSize) //特殊点在左下角棋盘 &#123; cover(halfSize, x, y, sx, sy + halfSize); &#125; else //特殊点不在左下角棋盘 &#123; //填充右上角为特殊点 int tx = sx + halfSize - 1; int ty = sy + halfSize; board[tx][ty] = t; //填充剩余棋盘 cover(halfSize, tx, ty, sx, sy + halfSize); &#125; if(x &gt;= sx + halfSize &amp;&amp; y &gt;= sy + halfSize) //特殊点在右下角棋盘 &#123; cover(halfSize, x, y, sx + halfSize, sy + halfSize); &#125; else //特殊点不在右下角棋盘 &#123; //填充左上角为特殊点 int tx = sx + halfSize; int ty = sy + halfSize; board[tx][ty] = t; //填充剩余棋盘 cover(halfSize, tx, ty, sx + halfSize, sy + halfSize); &#125; &#125;&#125; 运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-Strassen矩阵乘法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-Strassen%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：Strassen 矩阵乘法编写语言：Java 问题描述我们知道，两个大小为 2 * 2 的矩阵相乘，一般需要进行 8 次乘法。而Strassen矩阵乘法可以减少一次乘法，只需要 7 次，看似很少，但当数据量很大时，效率就会有显著提升。不过使用 Strassen矩阵乘法需要满足 矩阵边长为 2 的幂次方。因为该算法会用到分治，如果分治后矩阵两边边长不等，结果会出错。 使用下面的方法计算结果矩阵，假设两个长度为 2 的矩阵是 A，B，相乘后的结果矩阵为 C：1234567M1 = A11(B12 - B22) 注：Anm 表示 A 矩阵第 n 行 k 列的值，Bnm，Cnm 同理M2 = (A11 + A12)B22M3 = (A21 + A22)B11 M4 = A22(B21 - B11)M5 = (A11 + A22)(B11 + B22)M6 = (A12 - A22)(B21 + B22)M7 = (A11 - A21)(B11 + B12) 可得结果为：1234C11 = M5 + M4 - M2 + M6C12 = M1 + M2C21 = M3 + M4C22 = M5 + M1 - M3 - M7 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172public class StrassenMatrixMultiply&#123; public static void main(String[] args) &#123; int[] a = new int[] &#123; 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4 &#125;; int[] b = new int[] &#123; 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4 &#125;; int length = 4; int[] c = sMM(a, b, length); for(int i = 0; i &lt; c.length; i++) &#123; System.out.print(c[i] + " "); if((i + 1) % length == 0) //换行 System.out.println(); &#125; &#125; public static int[] sMM(int[] a, int[] b, int length) &#123; if(length == 2) &#123; return getResult(a, b); &#125; else &#123; int tlength = length / 2; //把a数组分为四部分，进行分治递归 int[] aa = new int[tlength * tlength]; int[] ab = new int[tlength * tlength]; int[] ac = new int[tlength * tlength]; int[] ad = new int[tlength * tlength]; //把b数组分为四部分，进行分治递归 int[] ba = new int[tlength * tlength]; int[] bb = new int[tlength * tlength]; int[] bc = new int[tlength * tlength]; int[] bd = new int[tlength * tlength]; //划分子矩阵 for(int i = 0; i &lt; length; i++) &#123; for(int j = 0; j &lt; length; j++) &#123; /* * 划分矩阵： * 例子：将 4 * 4 的矩阵，变为 2 * 2 的矩阵， * 那么原矩阵左上、右上、左下、右下的四个元素分别归为新矩阵 */ if(i &lt; tlength) &#123; if(j &lt; tlength) &#123; aa[i * tlength + j] = a[i * length + j]; ba[i * tlength + j] = b[i * length + j]; &#125; else &#123; ab[i * tlength + (j - tlength)] = a[i * length + j]; bb[i * tlength + (j - tlength)] = b[i * length + j]; &#125; &#125; else &#123; if(j &lt; tlength) &#123; //i 大于 tlength 时，需要减去 tlength，j同理 //因为 b，c，d三个子矩阵有对应了父矩阵的后半部分 ac[(i - tlength) * tlength + j] = a[i * length + j]; bc[(i - tlength) * tlength + j] = b[i * length + j]; &#125; else &#123; ad[(i - tlength) * tlength + (j - tlength)] = a[i * length + j]; bd[(i - tlength) * tlength + (j - tlength)] = b[i * length + j]; &#125; &#125; &#125; &#125; //分治递归 int[] result = new int[length * length]; //temp：4个临时矩阵 int[] t1 = add(sMM(aa, ba, tlength), sMM(ab, bc, tlength)); int[] t2 = add(sMM(aa, bb, tlength), sMM(ab, bd, tlength)); int[] t3 = add(sMM(ac, ba, tlength), sMM(ad, bc, tlength)); int[] t4 = add(sMM(ac, bb, tlength), sMM(ad, bd, tlength)); //归并结果 for(int i = 0; i &lt; length; i++) &#123; for(int j = 0; j &lt; length; j++) &#123; if(i &lt; tlength) &#123; if(j &lt; tlength) result[i * length + j] = t1[i * tlength + j]; else result[i * length + j] = t2[i * tlength + (j - tlength)]; &#125; else &#123; if(j &lt; tlength) result[i * length + j] = t3[(i - tlength) * tlength + j]; else result[i * length + j] = t4[(i - tlength) * tlength + (j - tlength)]; &#125; &#125; &#125; return result; &#125; &#125; public static int[] getResult(int[] a, int[] b) &#123; int p1 = a[0] * (b[1] - b[3]); int p2 = (a[0] + a[1]) * b[3]; int p3 = (a[2] + a[3]) * b[0]; int p4 = a[3] * (b[2] - b[0]); int p5 = (a[0] + a[3]) * (b[0] + b[3]); int p6 = (a[1] - a[3]) * (b[2] + b[3]); int p7 = (a[0] - a[2]) * (b[0] + b[1]); int c00 = p5 + p4 - p2 + p6; int c01 = p1 + p2; int c10 = p3 + p4; int c11 = p5 + p1 -p3 - p7; return new int[] &#123;c00, c01, c10, c11&#125;; &#125; public static int[] add(int[] a, int[] b) &#123; int[] c = new int[a.length]; for(int i = 0; i &lt; a.length; i++) c[i] = a[i] + b[i]; return c; &#125; //返回一个数是不是2的幂次方 public static boolean adjust(int num) &#123; return (num &amp; (num - 1)) == 0; &#125;&#125; 运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-线性时间选择]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：线性时间选择编写语言：Java 问题描述给定线性序集中 n 个元素和一个整数 k, 1 &lt;= k &lt;= n, 要求找出这 n 个元素中第 k 小的元素。即如果将这 n 个元素依其线性序排列时，排在第 k 个位置的元素即为要找的元素。 本篇博文代码会用到 分治法-快速排序 博文中用到的基准选择方法。方法使用位置：代码第 25 行方法实现位置：代码第 37 - 68 行 Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.Random;public class RandomizedSelect&#123; public static void main(String[] args) &#123; int[] a = new int[] &#123;1, 3, 2, 6, 5, 8, 4, 9, 7, 0&#125;; int t = select(a, 0, a.length - 1, 4); //选出第四大的数 System.out.println(t); &#125; //参数含义：a为待查询的数组，low为起点，high为终点，target为带查询的目标 public static int select(int[] a, int low, int high, int target) &#123; if(low == high) return a[low]; //将数组以i为基准分为两部分，左边的都小于i，右边的都大于i //此处会用到快速排序算法中的划分方法来找基准 int i = randPart(a, low, high); int length = i - low + 1; //数组左半部分的长度 //如果第target小的数小于等于左半部分的长度，则这个数在此部分内 if(target &lt;= length) return select(a, low, i, target); //如果第target小的数大于左半部分的长度，则这个数在右半部分内， //且左半部分的数都小于第target小的数 else return select(a, i + 1, high, target - length); &#125; //划分寻找基准-随机化优化 public static int randPart(int[] a, int low, int high) &#123; Random r = new Random(); //随机产生一个 low 到 high 的整数 int flag = low + r.nextInt(high - low + 1); int pivot = a[flag]; //实际还是相当于以a[0]为基准 a[flag] = a[low]; a[low] = pivot; while(low &lt; high) &#123; //1、从右往左找比基准小的数 while(low &lt; high &amp;&amp; a[high] &gt; pivot) high--; if(low &lt; high) a[low] = a[high]; //2、从左往右找比基准大的数 while(low &lt; high &amp;&amp; a[low] &lt;= pivot) low++; if(low &lt; high) a[high] = a[low]; &#125; //将pivot放到low和high相遇的地方 a[high] = pivot; return high; &#125;&#125; 运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-归并排序]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：归并排序编写语言：Java Java代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//本篇博文代码是递归方式归并排序算法的实现public class MergeSort&#123; public static void main(String[] args) &#123; int[] ary = new int[] &#123;1, 3, 4, 5, 2, 7, 0, 6, 9, 8&#125;; System.out.print("排序前的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); sort(ary); System.out.print("排序后的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); &#125; public static int[] sort(int[] a) &#123; return sort(a, 0, a.length - 1); &#125; public static int[] sort(int[] a, int low, int high) &#123; //low == high 说明两者相遇，即数组大小为1 if(low &lt; high) //当数组尺寸不为1的时候进行递归排序操作 &#123; int mid = (low + high) / 2; sort(a, low, mid); //对左半部分排序 sort(a, mid + 1, high); //对右半部分排序 //对左右两半部分排序后，两者都有序， //但左半部分的值不一定小于右半部分，所以需要归并整理 merge(a, low, mid, high); //归并 &#125; return a; &#125; public static int[] merge(int[] a, int low, int mid, int high) &#123; int[] r = new int[high - low + 1]; //下表从零开始，数组大小多1 //i为待返回结果数组起点，j为左半部分数组起点，k为右半部分数组起点 int i = 0, j = low, k = mid + 1; while(j &lt;= mid &amp;&amp; k &lt;= high) &#123; if(a[j] &lt; a[k]) r[i++] = a[j++]; else r[i++] = a[k++]; &#125; //若有左半部分一个元素未加入 result 数组，此处可解决这个问题 while(j &lt;= mid) r[i++] = a[j++]; //若有由半部分一个元素未加入 result 数组，此处可解决这个问题 while(k &lt;= high) r[i++] = a[k++]; //将result数组拷入原数组对应位置 System.arraycopy(r, 0, a, low, r.length); return a; &#125;&#125; 运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-排列问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：排列问题编写语言：Java 问题描述显示列表list(a, b, c, d……) 的全排列，显示的条目数为：n!例如(1, 2, 3)的全排列为(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1) Java代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//下面的例子将以 A B C 为例public class ArrayProblem&#123; public static void main(String[] args) &#123; char[] list = new char[] &#123;'A', 'B', 'C'&#125;; System.out.println("序列(A, B, C)的全排列为：\n"); array(list); &#125; //全排列的产生函数 public static void array(char[] list) &#123; array(list, 0, list.length); &#125; //产生 start 到 end 的全排列 public static void array(char[] list, int start, int end) &#123; if(start == end) &#123; for(int i = 0; i &lt; end; i++) System.out.print(list[i] + " "); System.out.println(); &#125; else &#123; for(int i = start; i &lt; end; i++) &#123; //交换 list[i] 和 list[k] 的位置(例：i = 1 时，start = 0， //交换 A B 的位置，此时为 B A C) char temp = list[i]; list[i] = list[start]; list[start] = temp; //第一个交换位置后，产生剩下的全排列序列(第一个为 B， //产生 A C 的全排列) array(list, start + 1, end); //将一个有序序列全排列后，恢复原状，防止出现重复的结果 //(会出现两个完全相同的序列，即一次排列输出两次, //可以注释掉下面三行代码，运行观察效果，然后分析原因) temp = list[i]; list[i] = list[start]; list[start] = temp; &#125; &#125; &#125;&#125; 运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-快速排序]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：快速排序编写语言：Java Java代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//本篇博文代码主要有两种基准选择方式：基准=低下标处的值，基准=随机值import java.util.Random;public class QuickSort&#123; public static void main(String[] args) &#123; int[] ary = new int[] &#123;1, 3, 4, 5, 2, 7, 0, 6, 9, 8&#125;; System.out.print("排序前的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); sort(ary); System.out.print("排序后的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); &#125; public static void sort(int[] a) &#123; sort(a, 0, a.length - 1); &#125; public static void sort(int[] a, int low, int high) &#123; //当low == high时就返回 //确保数组元素为1时就停止划分，防止数组下标越界 if(low &lt; high) &#123; int pivot = randPart(a, low, high); sort(a, low, pivot - 1); sort(a, pivot + 1, high); &#125; &#125; //划分寻找基准 public static int part(int[] a, int low, int high) &#123; int pivot = a[low]; while(low &lt; high) &#123; //1、从右往左找比基准小的数 while(low &lt; high &amp;&amp; a[high] &gt; pivot) high--; //a处赋值 if(low &lt; high) a[low] = a[high]; //此时是 a[high] &lt; pivot, a[low] &lt; pivot //2、从左往右找比基准大的数 while(low &lt; high &amp;&amp; a[low] &lt;= pivot) low++; //3、一次寻找结束，交换两个值 //b处赋值 if(low &lt; high) a[high] = a[low]; //此时是 a[high] &gt; pivot, a[low] &lt; pivot //a、b两处赋值，相当于一次交换，只是分开了 &#125; //将pivot放到left和right相遇的地方 a[high] = pivot; return high; &#125; //划分寻找基准-随机化优化 public static int randPart(int[] a, int low, int high) &#123; Random r = new Random(); //随机产生一个 low 到 high 的整数 int flag = low + r.nextInt(high - low + 1); int pivot = a[flag]; //此处交换保证 1 处的赋值不出错， //因为只要原 a[low] &lt; pivot，那么这个交换算法就失败了 a[flag] = a[low]; a[low] = pivot; while(low &lt; high) &#123; //1、从右往左找比基准小的数 while(low &lt; high &amp;&amp; a[high] &gt; pivot) high--; if(low &lt; high) a[low] = a[high]; //2、从左往右找比基准大的数 while(low &lt; high &amp;&amp; a[low] &lt;= pivot) low++; if(low &lt; high) a[high] = a[low]; &#125; //将pivot放到low和high相遇的地方 a[high] = pivot; return high; &#125;&#125; 运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
