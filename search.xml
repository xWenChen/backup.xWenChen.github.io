<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：全排列问题编写语言：Java 问题描述：显示 列表list(a, b, c, d……) 的全排列，显示的条目数为：n!代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//下面的例子将以 A B C 为例 public class ArrayProblem &#123; public static void main(String[] args) &#123; char[] list = new char[]&#123;&apos;A&apos;, &apos;B&apos;, &apos;C&apos;&#125;; System.out.println(&quot;序列(A, B, C)的全排列为：\n&quot;); array(list); &#125; //全排列的产生函数 public static void array(char[] list) &#123; array(list, 0, list.length); &#125; //产生 start 到 end 的全排列 public static void array(char[] list, int start, int end) &#123; if(start == end) &#123; for(int i = 0; i &lt; end; i++) System.out.print(list[i] + &quot; &quot;); System.out.println(); &#125; else &#123; for(int i = start; i &lt; end; i++) &#123; //交换 list[start] 和 list[i] 的位置(例：i = 1 时，start = 0，交换 A B 的位置， //此时为 B A C) char temp = list[i]; list[i] = list[start]; list[start] = temp; //第一个交换位置后，产生剩下的全排列序列(第一个为 B，产生 A C 的全排列) array(list, start + 1, end); //将一个有序序列全排列后，恢复原状，防止出现重复的结果(会出现两个完全相同的序列， //即一次排列输出两次, 有兴趣可以注释掉下面三行代码，运行观察效果，然后分析原因) temp = list[i]; list[i] = list[start]; list[start] = temp; &#125; &#125; &#125; &#125; 运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
