<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分治法-Strassen矩阵乘法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-Strassen%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：Strassen矩阵乘法编写语言：Java 问题描述：我们知道，两个大小为 2 * 2 的矩阵相乘，一般需要进行 8 次乘法。而Strassen矩阵乘法可以减少一次乘法，只需要 7 次，看似很少，但当数据量很大时，效率就会有显著提升。不过使用 Strassen矩阵乘法需要满足 矩阵边长为 2 的幂次方。因为该算法会用到分治，如果分治后矩阵两边边长不等，结果会出错。 使用下面的方法计算结果矩阵，假设两个长度为 2 的矩阵是 A，B，相乘后的结果矩阵为 C：1234567M1 = A11(B12 - B22) 注：Anm 表示 A 矩阵第 n 行 k 列的值，Bnm，Cnm 同理M2 = (A11 + A12)B22M3 = (A21 + A22)B11 M4 = A22(B21 - B11)M5 = (A11 + A22)(B11 + B22)M6 = (A12 - A22)(B21 + B22)M7 = (A11 - A21)(B11 + B12) 可得结果为：1234C11 = M5 + M4 - M2 + M6C12 = M1 + M2C21 = M3 + M4C22 = M5 + M1 - M3 - M7 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172public class StrassenMatrixMultiply&#123; public static void main(String[] args) &#123; int[] a = new int[] &#123; 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4 &#125;; int[] b = new int[] &#123; 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4 &#125;; int length = 4; int[] c = sMM(a, b, length); for(int i = 0; i &lt; c.length; i++) &#123; System.out.print(c[i] + " "); if((i + 1) % length == 0) //换行 System.out.println(); &#125; &#125; public static int[] sMM(int[] a, int[] b, int length) &#123; if(length == 2) &#123; return getResult(a, b); &#125; else &#123; int tlength = length / 2; //把a数组分为四部分，进行分治递归 int[] aa = new int[tlength * tlength]; int[] ab = new int[tlength * tlength]; int[] ac = new int[tlength * tlength]; int[] ad = new int[tlength * tlength]; //把b数组分为四部分，进行分治递归 int[] ba = new int[tlength * tlength]; int[] bb = new int[tlength * tlength]; int[] bc = new int[tlength * tlength]; int[] bd = new int[tlength * tlength]; //划分子矩阵 for(int i = 0; i &lt; length; i++) &#123; for(int j = 0; j &lt; length; j++) &#123; /* * 划分矩阵： * 例子：将 4 * 4 的矩阵，变为 2 * 2 的矩阵， * 那么原矩阵左上、右上、左下、右下的四个元素分别归为新矩阵 */ if(i &lt; tlength) &#123; if(j &lt; tlength) &#123; aa[i * tlength + j] = a[i * length + j]; ba[i * tlength + j] = b[i * length + j]; &#125; else &#123; ab[i * tlength + (j - tlength)] = a[i * length + j]; bb[i * tlength + (j - tlength)] = b[i * length + j]; &#125; &#125; else &#123; if(j &lt; tlength) &#123; //i 大于 tlength 时，需要减去 tlength，j同理 //因为 b，c，d三个子矩阵有对应了父矩阵的后半部分 ac[(i - tlength) * tlength + j] = a[i * length + j]; bc[(i - tlength) * tlength + j] = b[i * length + j]; &#125; else &#123; ad[(i - tlength) * tlength + (j - tlength)] = a[i * length + j]; bd[(i - tlength) * tlength + (j - tlength)] = b[i * length + j]; &#125; &#125; &#125; &#125; //分治递归 int[] result = new int[length * length]; //temp：4个临时矩阵 int[] t1 = add(sMM(aa, ba, tlength), sMM(ab, bc, tlength)); int[] t2 = add(sMM(aa, bb, tlength), sMM(ab, bd, tlength)); int[] t3 = add(sMM(ac, ba, tlength), sMM(ad, bc, tlength)); int[] t4 = add(sMM(ac, bb, tlength), sMM(ad, bd, tlength)); //归并结果 for(int i = 0; i &lt; length; i++) &#123; for(int j = 0; j &lt; length; j++) &#123; if(i &lt; tlength) &#123; if(j &lt; tlength) result[i * length + j] = t1[i * tlength + j]; else result[i * length + j] = t2[i * tlength + (j - tlength)]; &#125; else &#123; if(j &lt; tlength) result[i * length + j] = t3[(i - tlength) * tlength + j]; else result[i * length + j] = t4[(i - tlength) * tlength + (j - tlength)]; &#125; &#125; &#125; return result; &#125; &#125; public static int[] getResult(int[] a, int[] b) &#123; int p1 = a[0] * (b[1] - b[3]); int p2 = (a[0] + a[1]) * b[3]; int p3 = (a[2] + a[3]) * b[0]; int p4 = a[3] * (b[2] - b[0]); int p5 = (a[0] + a[3]) * (b[0] + b[3]); int p6 = (a[1] - a[3]) * (b[2] + b[3]); int p7 = (a[0] - a[2]) * (b[0] + b[1]); int c00 = p5 + p4 - p2 + p6; int c01 = p1 + p2; int c10 = p3 + p4; int c11 = p5 + p1 -p3 - p7; return new int[] &#123;c00, c01, c10, c11&#125;; &#125; public static int[] add(int[] a, int[] b) &#123; int[] c = new int[a.length]; for(int i = 0; i &lt; a.length; i++) c[i] = a[i] + b[i]; return c; &#125; //返回一个数是不是2的幂次方 public static boolean adjust(int num) &#123; return (num &amp; (num - 1)) == 0; &#125;&#125; 运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-线性时间选择]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：线性时间选择编写语言：Java 问题描述：给定线性序集中 n 个元素和一个整数 k, 1 &lt;= k &lt;= n, 要求找出这 n 个元素中第 k 小的元素。即如果将这 n 个元素依其线性序排列时，排在第 k 个位置的元素即为要找的元素。 本篇博文代码会用到 分治法-快速排序 博文中用到的基准选择方法。方法使用位置：代码第 25 行方法实现位置：代码第 37 - 68 行 代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.Random;public class RandomizedSelect&#123; public static void main(String[] args) &#123; int[] a = new int[] &#123;1, 3, 2, 6, 5, 8, 4, 9, 7, 0&#125;; int t = select(a, 0, a.length - 1, 4); //选出第四大的数 System.out.println(t); &#125; //参数含义：a为待查询的数组，low为起点，high为终点，target为带查询的目标 public static int select(int[] a, int low, int high, int target) &#123; if(low == high) return a[low]; //将数组以i为基准分为两部分，左边的都小于i，右边的都大于i //此处会用到快速排序算法中的划分方法来找基准 int i = randPart(a, low, high); int length = i - low + 1; //数组左半部分的长度 //如果第target小的数小于等于左半部分的长度，则这个数在此部分内 if(target &lt;= length) return select(a, low, i, target); //如果第target小的数大于左半部分的长度，则这个数在右半部分内， //且左半部分的数都小于第target小的数 else return select(a, i + 1, high, target - length); &#125; //划分寻找基准-随机化优化 public static int randPart(int[] a, int low, int high) &#123; Random r = new Random(); //随机产生一个 low 到 high 的整数 int flag = low + r.nextInt(high - low + 1); int pivot = a[flag]; //实际还是相当于以a[0]为基准 a[flag] = a[low]; a[low] = pivot; while(low &lt; high) &#123; //1、从右往左找比基准小的数 while(low &lt; high &amp;&amp; a[high] &gt; pivot) high--; if(low &lt; high) a[low] = a[high]; //2、从左往右找比基准大的数 while(low &lt; high &amp;&amp; a[low] &lt;= pivot) low++; if(low &lt; high) a[high] = a[low]; &#125; //将pivot放到low和high相遇的地方 a[high] = pivot; return high; &#125;&#125; 运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-归并排序]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：归并排序编写语言：Java 本篇博文代码是递归归并排序算法的实现代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MergeSort&#123; public static void main(String[] args) &#123; int[] ary = new int[] &#123;1, 3, 4, 5, 2, 7, 0, 6, 9, 8&#125;; System.out.print("排序前的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); sort(ary); System.out.print("排序后的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); &#125; public static int[] sort(int[] a) &#123; return sort(a, 0, a.length - 1); &#125; public static int[] sort(int[] a, int low, int high) &#123; //low == high 说明两者相遇，即数组大小为1 if(low &lt; high) //当数组尺寸不为1的时候进行递归排序操作 &#123; int mid = (low + high) / 2; sort(a, low, mid); //对左半部分排序 sort(a, mid + 1, high); //对右半部分排序 //对左右两半部分排序后，两者都有序， //但左半部分的值不一定小于右半部分，所以需要归并整理 merge(a, low, mid, high); //归并 &#125; return a; &#125; public static int[] merge(int[] a, int low, int mid, int high) &#123; int[] r = new int[high - low + 1]; //下表从零开始，数组大小多1 //i为待返回结果数组起点，j为左半部分数组起点，k为右半部分数组起点 int i = 0, j = low, k = mid + 1; while(j &lt;= mid &amp;&amp; k &lt;= high) &#123; if(a[j] &lt; a[k]) r[i++] = a[j++]; else r[i++] = a[k++]; &#125; //若有左半部分一个元素未加入 result 数组，此处可解决这个问题 while(j &lt;= mid) r[i++] = a[j++]; //若有由半部分一个元素未加入 result 数组，此处可解决这个问题 while(k &lt;= high) r[i++] = a[k++]; //将result数组拷入原数组对应位置 System.arraycopy(r, 0, a, low, r.length); return a; &#125;&#125; 运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-排列问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：全排列问题编写语言：Java 问题描述：显示 列表list(a, b, c, d……) 的全排列，显示的条目数为：n!代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//下面的例子将以 A B C 为例public class ArrayProblem&#123; public static void main(String[] args) &#123; char[] list = new char[] &#123;'A', 'B', 'C'&#125;; System.out.println("序列(A, B, C)的全排列为：\n"); array(list); &#125; //全排列的产生函数 public static void array(char[] list) &#123; array(list, 0, list.length); &#125; //产生 start 到 end 的全排列 public static void array(char[] list, int start, int end) &#123; if(start == end) &#123; for(int i = 0; i &lt; end; i++) System.out.print(list[i] + " "); System.out.println(); &#125; else &#123; for(int i = start; i &lt; end; i++) &#123; //交换 list[i] 和 list[k] 的位置(例：i = 1 时，start = 0， //交换 A B 的位置，此时为 B A C) char temp = list[i]; list[i] = list[start]; list[start] = temp; //第一个交换位置后，产生剩下的全排列序列(第一个为 B， //产生 A C 的全排列) array(list, start + 1, end); //将一个有序序列全排列后，恢复原状，防止出现重复的结果 //(会出现两个完全相同的序列，即一次排列输出两次, //可以注释掉下面三行代码，运行观察效果，然后分析原因) temp = list[i]; list[i] = list[start]; list[start] = temp; &#125; &#125; &#125;&#125; 运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-快速排序]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：快速排序编写语言：Java 本篇博文代码主要有两种基准选择方式：基准=低下标处的值，基准=随机值代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import java.util.Random;public class QuickSort&#123; public static void main(String[] args) &#123; int[] ary = new int[] &#123;1, 3, 4, 5, 2, 7, 0, 6, 9, 8&#125;; System.out.print("排序前的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); sort(ary); System.out.print("排序后的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); &#125; public static void sort(int[] a) &#123; sort(a, 0, a.length - 1); &#125; public static void sort(int[] a, int low, int high) &#123; //当low == high时就返回 //确保数组元素为1时就停止划分，防止数组下标越界 if(low &lt; high) &#123; int pivot = randPart(a, low, high); sort(a, low, pivot - 1); sort(a, pivot + 1, high); &#125; &#125; //划分寻找基准 public static int part(int[] a, int low, int high) &#123; int pivot = a[low]; while(low &lt; high) &#123; //1、从右往左找比基准小的数 while(low &lt; high &amp;&amp; a[high] &gt; pivot) high--; //a处赋值 if(low &lt; high) a[low] = a[high]; //此时是 a[high] &lt; pivot, a[low] &lt; pivot //2、从左往右找比基准大的数 while(low &lt; high &amp;&amp; a[low] &lt;= pivot) low++; //3、一次寻找结束，交换两个值 //b处赋值 if(low &lt; high) a[high] = a[low]; //此时是 a[high] &gt; pivot, a[low] &lt; pivot //a、b两处赋值，相当于一次交换，只是分开了 &#125; //将pivot放到left和right相遇的地方 a[high] = pivot; return high; &#125; //划分寻找基准-随机化优化 public static int randPart(int[] a, int low, int high) &#123; Random r = new Random(); //随机产生一个 low 到 high 的整数 int flag = low + r.nextInt(high - low + 1); int pivot = a[flag]; //此处交换保证 1 处的赋值不出错， //因为只要原 a[low] &lt; pivot，那么这个交换算法就失败了 a[flag] = a[low]; a[low] = pivot; while(low &lt; high) &#123; //1、从右往左找比基准小的数 while(low &lt; high &amp;&amp; a[high] &gt; pivot) high--; if(low &lt; high) a[low] = a[high]; //2、从左往右找比基准大的数 while(low &lt; high &amp;&amp; a[low] &lt;= pivot) low++; if(low &lt; high) a[high] = a[low]; &#125; //将pivot放到low和high相遇的地方 a[high] = pivot; return high; &#125;&#125; 运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
