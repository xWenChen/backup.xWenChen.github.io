<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android 模版设计模式实战]]></title>
    <url>%2FAndroid%2FAndroid%20%E6%A8%A1%E7%89%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[本文主要讲解如何在实际项目中使用模版设计模式优化代码结构 ¶概念 在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。这种类型的设计模式属于行为型模式。 模版设计模式的本质便是固定算法框架。 上面的概念中有三个要点： 父类定义方法模版 子类实现方法的某一个部分 调用以父类的方式调用 ¶优点 在开发时，只需要考虑方法的实现。不需要考虑方法在何种情况下被调用。实现代码复用。 一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。 各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。 需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。 ¶核心思想 代码复用，避免重复 ¶使用 下面，让我们来介绍一个例子。假设我们需要设计一个即时聊天工具，这个工具可以显示图片、语音、文本、表情等等类型的消息。并且可以显示消息发送的状态，显示消息的时间，显示成员头像，显示成员名称。显示有哪些人读了你的消息。相信使用过 QQ 或者微信的人对这些一定都不陌生。我们暂且将这些功能称为：消息内容、消息时间、消息回执、消息状态、成员头像、成员名称。以发送端的消息显示为例，其可以长这个样子。 根据我们对 QQ 和微信的使用，可以很明显的看出，以下的部分是公有布局： 消息时间 消息回执 消息状态 成员头像 成员名称 公共操作，如点击事件、长按事件等等。 除开上面的公共部分，其实每种消息类型的不同之处便是消息内容部分，对应上图中的主布局区域。 理清了这些思路，我们可以很轻松的根据模版模式构建出一个消息的显示流程。 首先，我们应该确定在哪个类里面进行消息的绑定操作。对于 Android，现在已经开始流行使用 RecyclerView，使用 RecyclerView，我们应该在 ViewHolder 中，进行数据的绑定。通过定义一个基类 ViewHolder，实现公共的逻辑。然后定义子类，实现不同消息类型的消息内容的绑定，便可以定义出一套消息绑定的流程。 下面，我们来一一讲解。首先是流程。 定义公共布局：将上面我们列举到的时间、头像、名字、已读回执、消息状态这些，定义为公共布局。 在基类 ViewHolder 中，定义绑定这些公共方法的逻辑。 在子类 ViewHolder 中，对私有数据进行绑定。 布局就不详讲了。主要是采用 include 标签，将公共的布局包含到对应的消息类型中。我们重点讲解第2、3步。 ¶定义基类 基类的定义属于第二步，又可以具体细分为三步。其定义方式如下（注：以下所有的代码，只讲解流程，不会涉及具体的代码）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public abstract class BaseChatItemHolder extends RecyclerView.ViewHolder &#123; // 2.1 定义外部类调用入口，绑定数据 public void onBindViewHolder(Msg msg, int position) &#123; // 绑定消息公共的数据部分 bindCommonData(msg, position); // 绑定消息私有的数据部分 bindPrivateData(msg, position); &#125; // 2.2 定义公共的数据绑定流程，流程不可更改 public void bindCommonData(Msg msg, int position) &#123; // 设置消息时间 setTime(msg); // 设置成员头像 setHead(msg); // 设置成员名称 setName(msg); // 设置消息状态 setState(msg); // 设置消息回执 setMsgReceipt(msg); // 设置公共操作 setCommonOperation(msg); &#125; // 2.3 定义公共方法，非抽象，需要父类提供实现 // 设置消息时间 public void setTime(Msg msg) &#123; // 省略具体绑定过程 &#125; // 设置成员头像 public void setHead(Msg msg) &#123; // 省略具体绑定过程 &#125; // 设置成员名称 public void setName(Msg msg) &#123; // 省略具体绑定过程 &#125; // 设置消息状态 public void setState(Msg msg) &#123; // 省略具体绑定过程 &#125; // 设置消息回执 public void setMsgReceipt(Msg msg) &#123; // 省略具体绑定过程 &#125; // 设置公共操作 public void setCommonOperation(Msg msg) &#123; // 省略具体绑定过程 &#125; // 2.4 定义消息私有内容绑定的抽象方法 public abstract void bindPrivateData(Msg msg, int position);&#125; 在上面的流程设计中，我们定义了公共方法，以表示公共消息布局的绑定过程，公共的方法不必声明为 abstract。子类特有的消息内容区域需要设置为抽象类型的，表示子类必须自己处理消息内容布局的绑定过程，并且消息内容的布局需要自己设计。但必须置于一个公共的父布局下。比如所有消息类型的内容布局，其根布局必须是 ConstraintLayout。 Msg 表示消息，是所有消息类型的父类。如图片消息 PhotoMsg、语音 VoiceMsg 等等这些消息类型都由其衍生出来。其包含了所有消息类型共有的一些属性，比如消息的 id，发送者的 id，接受者的 id，聊天框的 id 等等。当然，具体的内容视业务而定，这里只是举个例子。 ¶定义子类 接下来，我讲讲子类如何利用父类定义的流程。这里举两个例子。以图片消息(PhotoMsg)、语音消息(VoiceMsg)为例。图片消息无需什么特殊的操作，而语音消息需要特殊的长按操作。 注：前面提到过，消息内容的布局应该包裹在 ConstraintLayout 中，如下： 123456789&lt;!-- 消息内容的布局区域，可以统一命名，方便设置公共操作 --&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout android:id="@+id/chat_msg_item_content" android:layout_width="wrap_content" android:layout_height="wrap_content"&gt; &lt;!-- 消息内容的布局 --&gt; &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 图片消息 根据上面提到的原则，图片消息的布局如下： 1234567891011&lt;!-- 消息内容的布局区域，可以统一命名，方便设置公共操作 --&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout android:id="@+id/chat_msg_item_content" android:layout_width="wrap_content" android:layout_height="wrap_content"&gt; &lt;!-- 显示图片的 ImageView，布局参数省略 --&gt; &lt;ImageView android:id="@+id/iv_photo" android:layout_width="40dp" android:layout_height="40dp" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 1234567891011121314public class PhotoChatItemHolder extends BaseChatItemHolder &#123; public PhotoChatItemHolder(ViewGroup parent, @LayoutRes int resId) &#123; super(parent, resId); &#125; @Override public void bindPrivateData(Msg msg, int position) &#123; // 父类消息转成图片消息，进行私有消息内容数据部分的绑定 PhotoMsg photoMsg = (PhotoMsg) msg; // 省略具体绑定过程 ... &#125;&#125; 图片消息除了私有部分，其他无须特殊处理，便可以复用父类的绑定流程。无需重写父类中的非 abstract 类型的方法，使用父类提供的默认实现即可。 语音消息 语音消息的布局如下： 1234567891011&lt;!-- 消息内容的布局区域，可以统一命名，方便设置公共操作 --&gt;&lt;androidx.constraintlayout.widget.ConstraintLayout android:id="@+id/chat_msg_item_content" android:layout_width="wrap_content" android:layout_height="wrap_content"&gt; &lt;!-- 显示图片的 ImageView，布局参数省略 --&gt; &lt;VoiceView android:id="@+id/vv_voice" android:layout_width="40dp" android:layout_height="40dp" /&gt;&lt;/androidx.constraintlayout.widget.ConstraintLayout&gt; 上面我们假设了语音需要特殊的长按操作。则可以构建如下代码： 1234567891011121314151617181920212223public class VoiceChatItemHolder extends BaseChatItemHolder &#123; public VoiceChatItemHolder(ViewGroup parent, @LayoutRes int resId) &#123; super(parent, resId); &#125; @Override public void setCommonOperation(Msg msg) &#123; // 1. 子类重写绑定过程，代执行到此处，会采用子类的实现，不会调用父类的方法 ... // 2. 如果任性一点，不要长按事件，这里的实现甚至可以返回空。做到差异化。 &#125; @Override public void bindPrivateData(Msg msg, int position) &#123; // 父类消息转成语音消息，进行私有数据部分的绑定 VoiceMsg voiceMsg = (VoiceMsg) msg; ... // 3. 甚至你可以在这里调用公共操作方法，自定义部分加载流程，覆盖上面的长按事件调用。 setCommonOperation(msg); ... &#125;&#125; 上面的例子，我们重写了父类中的非抽象公共方法。但是却没有改变绑定流程，便达到了我们想要的效果。并且我们应该将私有部分消息内容的数据绑定放到最后，这样可以给予最大的自由度。另外给了三点说明，写在了注释中。 ¶使用 学习 Java 的时候，我们都知道 Java 类有声明类型和实际类型。此处我们要想正确的调用，达到正确效果，便需要返回正确的实际类型。创建 ViewHolder 时，可以这么写。以图片和语音消息为例。 12345678910111213public class ViewHolderManager &#123; public BaseChatItemHolder createViewHolder(ViewGroup parent, int msgType) &#123; int resId = MsgLayoutManager.getInstance().getLayoutResId(msgType); switch(msgType) &#123; case MsgType.PHOTO: return new PhotoChatItemHolder(parent, resId); break; case MsgType.VOICE: return new VoiceChatItemHolder(parent, resId); break; &#125; &#125;&#125; 上面的实现很简单。但却能达到我们想要的效果。 讲完了构建，下面就讲下调用，很简单，在真正需要绑定布局的地方，比如消息适配器 MsgAdapter 的绑定方法中，调用 ViewHolder 的绑定方法即可。 12345678910111213141516171819public class MsgAdapter extends RecyclerView.Adapter&lt;BaseChatItemHolder&gt;&#123; List&lt;Msg&gt; msgList; @Override public BaseChatItemViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; return ViewHolderManager.getInstance().createViewHolder(parent, viewType); &#125; @Override public void onBindViewHolder(BaseChatItemViewHolder holder, int position) &#123; Msg msg = getItem(position); holder.onBindViewHolder(msg, position); &#125; public Msg getItem(int position) &#123; return msgList.get(i); &#125;&#125; 上面的调用过程，创建和绑定数据的流程都很简单。 下面来总结一下。 ¶总结 模版模式使用的 Java 语言特性，核心有两个。1 是抽象类可以拥有抽象方法和非抽象方法。抽象方法要求子类必须实现，可以用来制定差异化。非抽象方法则可以用来定义流程。2 是 Java 的方法调用实际上，会最终调用到类的实际类型中的方法实现，而不是声明类型中的方法实现。 模版模式是以代码复用为目的。避免一个类出现海量代码。规范了流程，提高了可读性。并且给予了子类极大的自由度。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射]]></title>
    <url>%2FJava%2FJava%20%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[本文主要讲解 Java 反射相关的基本知识 ¶概念 相信每个 Java 语言攻城狮都或多或少听说过反射的概念。反射可以说是Java中最强大的技术了。JAVA反射机制是指在**运行状态(运行时)**中，动态获取信息以及动态调用对象方法的功能。 在 Java 中，通过类加载器和类路径可以唯一确定一个类。通过添加数据、指定实例名等方式，我们可以唯一确定一个类实例；我们可以把这个过程叫做映射。那么反过来，我们是否可以通过类名或者类实例去获取方法、属性、类路径等信息呢？答案当然是可以了。这就是反射。从逻辑上讲，映射和反射就是对立的两个概念，映射是实例映射类的过程，反射是类映射实例的过程 反射包含以下两个关键点： 对于任意一个类，都能够知道这个类的所有属性和方法； 对于任意一个对象，都能够调用它的任意方法和属性 简单来说反射就是解剖一个类，然后获取这个类中的属性和方法。前提是要获取这个类的Class对象。 ¶构成基础 Java 语言的反射机制，依赖于 Class 类和 java.lang.reflect 类库。其主要的类如下： Class：表示类或者接口 Field：表示类中的成员变量 Method：表示类中的方法 Constructor：表示类的构造方法 Array：该类提供了动态创建数组和访问数组元素的静态方法 ¶Class 类 Class 类是 Java 中用来表示运行时类型信息的对应类。在 Java 中，每个类都有一个 Class 对象，当我们编写并且编译一个新创建的类，相关信息就会被写到 .class 文件里。当我们 new 一个新对象或者引用静态成员变量时，JVM 中的类加载器子系统便会将对应 Class 对象加载到 JVM 中。我们可以将 Class 类称为类类型，Class 对象称为类类型对象。 Class 类有以下的特点： Class 类是类，class 则是 Java 语言保留的关键字。 Class 类只有一个私有的构造函数，只有 JVM 能够创建 Class 类的实例。 对于**同一个类(包名 + 类名相同，且由同一个类加载器加载)**的所有对象，在 JVM 中只有唯一一个对应的 Class 类实例来描述其类型信息。 .class 文件存储了一个 Class 的所有信息，比如所有的方法，所有的构造函数，所有的字段（成员属性）等等。JVM 启动的时候通过 .class 文件会将相关的类加载到内存中。 在上面的描述的基础上，我们便可以得到一个类的所有信息了。首先，让我们获取类的实例对象。有三种方法： forName 方法 可以通过 Class.forName 方法获取类的实例： 12// 获取 String 类的实例Class&lt;String&gt; clazz = Class.forName("java.lang.String"); getClass 方法 另外，我们也可以通过 Object.getClass 这个实例方法来获取类的实例。 123Class&lt;String&gt; clazz1 = "a".getClass();// 数组对象的 getClass 方法Class clazz2 = (new byte[1024]).getClass(); 使用 class 关键字 还有一种方法是使用 class 关键字： 1234// 类Class clazz1 = Integer.class;// 数组Class clazz2 = int [][].class; 使用 TYPE 属性 另外，对于 Java 中定义的基本类型和 void 关键字，都有对应的包装类。在包装类中有一个静态属性 TYPE，保存了该包装类的类类型。如 Integer 类中定义的 TYPE： 1public static final Class&lt;Integer&gt; TYPE = (Class&lt;Integer&gt;) Class.getPrimitiveClass("int"); 我们可以使用 TYPE 属性获取类对象，语法如下： 12Class clazz1 = Integer.TYPE;Class clazz2 = Void.TYPE; Java 的基本类型包括：boolean、byte、char、short、int、long、float、double。外加一个 void，可以用 TYPE 获取类对象。 在获取到了类的实例对象后，我们便可以获取其中存储的信息了。在这之前，我们先讲一下 AccessibleObject。 ¶AccessibleObject AccessibleObject 是 Field、Method、Constructor 三个类共同继承的父类，它提供了将反射的对象标记为，在使用时取消默认 Java 语言访问控制检查的能力。并且 AccessibleObject 实现了 AnnotatedElement 接口，提供了与获取注解相关的能力。这句话有点绕。举个例子。类 A 有一个私有成员 test(声明为 private)。类 B 是不能访问的，但是通过 AccessibleObject 提供的方法，我们却可以将 A.test 属性的限制范围设置为可访问，这样我们便能在 B 类中访问 A.test 属性了。 123456789101112131415public class A &#123; private int test = 1;&#125;public class B &#123; public void getTest() &#123; A a = new A(); // 获取类对象 Class clazz = a.getClass(); // 改变修饰符 clazz.getField("test").setAccessible(true); // 获取 test 属性的值，此处 getInt 仍然需要传入 Object 实例，原因后面解释 System.out.println(clazz.getField("test").getInt(a)); &#125;&#125; 在讲了 AccessibleObject 类，我们来看看反射机制中我们经常用过的类。 ¶Field Field 提供了有关类或接口的单个属性的信息，以及对它的动态访问的能力。 动态访问 对于类的某些属性，其修饰符是使用 private，外部是无法访问的，但是通过 Field 的 setAccessible 方法，我们便可以访问到这些属性。例子在上面已经列举到了，此处就不列举了。 下面来看看我们经常用到的一些方法： 方法名 作用 getFields() 获取类中public类型的属性 getDeclaredFields() 获取类中所有的属性，但不包括继承的属性 getField(String name) 获取类中名称为 name 的属性 getType() 返回变量的类类型，返回值是 Class getGenericType() 返回变量的类型，返回值是 Type isEnumConstant() 判断当前变量是否是枚举类 getModifiers() 以整数形式，返回此对象的 Java 语言修饰符 getName() 获取属性的名字 get(Object obj) 返回指定对象 obj 上此 Field 的值 set(Object obj, Object value) 将指定对象的此 Field 设置为指定的新值 isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) 判断是否有指定的注解 下面，让我们来一一举例。首先，我们定义一个类，包含一些必要的数据： 123456789101112public class TestField &#123; // a、是 public 的，b 是 protected 的，c、d 是 private 的。其中 d 是 static 的 public String a = "a"; protected int b = 2; private String c = "c"; private static String d = "d";&#125;public class TestField2 extends TestField &#123; public int e = 1; private int f = 2;&#125; getFields 方法和 getName 方法 然后，让我们来测试下获取字段和打印名字的方法： 12345678910public static void main(String[] args) &#123; TestField testField = new TestField(); Class clazz1 = testField.getClass(); Field[] fields1 = clazz1.getFields(); // 打印属性名 // 结果是 a，说明 getFields 只会获取声明为 public 的属性 for (Field f : fields1) &#123; System.out.print(f.getName() + " "); &#125;&#125; 让我们加入继承关系，将 TestField 类改为 TestField2 类，其余代码保持不变： 1234public static void main(String[] args) &#123; TestField2 testField = new TestField2(); ...&#125; 得到的结果是 e、a，说明** getFields 方法可以获取从父类继承来的公共属性**。 getDeclaredFields 方法 在上面的基础上，我们来看看 getDeclaredFields 方法，我们保持 TestField2 类不变，改变 Field 的获取方式： 12345public static void main(String[] args) &#123; ... Field[] fields1 = clazz1.getDeclaredFields(); ...&#125; 最后打印出来的结果是 e f，说明不管修饰符是什么，属性都可以被获取到，但是从父类继承来的变量不能被获取。 getField(String name) 和 getDeclaredField(String name) 方法 从上面的代码中可以看出，一个类的属性可以不只有一个，所以可以指定名称，获取到特定的变量，参数应该是类中有的属性的名称。这两个方法的作用范围和上面举例的几个方法一样。此处就不再重复举例了。 Field.getType() 和 Field.getGenericType() 方法 默认情况下，这两个的返回值是一样的。但是如果有签名，两者的返回值可能就不一样了。 12345public static void main(String[] args) &#123; ... System.out.print(clazz1.getField("a").getType() + " "); ...&#125; 上面的代码，执行结果会输出 a 属性的类型，为 class java.lang.String Field.getModifiers() 方法 此方法返回的是一个整型值，其代表意义可以查看 Modifier 这个类，该类在 JDK 的反射包下，定义了所有可用整型值代表的意思。此处举几个简单的例子： 12345678910111213141516171819202122232425262728293031public class Modifier &#123; ... // 整型值这么定义是为了方便位运算，在求取修饰符的整型值时，会使用下面的值进行或运算。 // 被 public 修饰，会返回该整型值 public static final int PUBLIC = 0x00000001; // 被 private 修饰，会返回该整型值 public static final int PRIVATE = 0x00000002; // 被 protected 修饰，会返回该整型值 public static final int PROTECTED = 0x00000004; // 被 static 修饰，会返回该整型值 public static final int STATIC = 0x00000008; // 被 final 修饰，会返回该整型值 public static final int FINAL = 0x00000010; // 被 synchronized 修饰，会返回该整型值 public static final int SYNCHRONIZED = 0x00000020; // 被 volatile 修饰，会返回该整型值 public static final int VOLATILE = 0x00000040; // 被 transient 修饰，会返回该整型值 public static final int TRANSIENT = 0x00000080; // 被 native 修饰，会返回该整型值 public static final int NATIVE = 0x00000100; // 被 interface 修饰，会返回该整型值 public static final int INTERFACE = 0x00000200; // 被 abstract 修饰，会返回该整型值 public static final int ABSTRACT = 0x00000400; // 被 strictfp 修饰，会返回该整型值 public static final int STRICT = 0x00000800; ...&#125; 举例说明，在，第一段代码的基础上，获取属性 d 的修饰符。d 是使用 private static 修饰的： 1234public static void main(String[] args) &#123; // 输出结果 10 System.out.println(clazz1.getDeclaredField("d").getModifiers());&#125; 上面的输出结果是 10，而在 Modifier 类中，private 的值是 2(二进制0010)，static 的值是 8(二进制1000)，0010 | 1000 = 1010。二进制换成10进制，刚好等于 10。 Field.get(Object obj) 方法 这个方法会得到某个对象的该属性的值。 在此之前，让我们看段代码： 123456789public static void main(String[] args) &#123; TestField testField1 = new TestField(); TestField testField2 = new TestField(); Class clazz1 = testField1.getClass(); Class clazz2 = testField2.getClass(); // 输出的结果为：true System.out.println(clazz1 == clazz2);&#125; 上面的代码输出的最终结果为 true，说明两个对象拿到的 Class 对象是同一个。可以理解为某一个类的 Class 对象是单例。 现在，让我们讲讲 get 方法。为什么我们要传入实例对象作为参数呢？就是为了明确，是为了得到哪一个对象的此属性值。因为在更多的场景下，同一个类的相同属性可能有不同的值，比如 Student 类有一个 name 属性，张三的 name 是张三，李四的 name 是李四。这样，同样是name，值却不一样。这便是使用 Field.get(Object obj) 时需要传入 obj 的原因。 同样的，set(Object obj, Object value) 方法也是一样的逻辑。 ¶Method Method 代表了一个类所具有的方法，下面是 Method 类中用到的一些常用方法。 方法名 作用 getReturnType() 获取方法的返回类型 getParameterTypes() 获取方法中参数的类型 getParameterCount() 获取方法中参数的数量 getExceptionTypes() 获取方法抛出的异常 invoke(Object obj, Object… args) 执行指定对象的该方法 isDefault() 判断方法是否是被 default 修饰的方法 getModifiers() 以整数形式，返回此对象的 Java 语言修饰符 getName() 获取方法的名字 getDefaultValue(Object obj) 获取声明的默认值 getDeclaredAnnotations() 获取修饰方法的所有注解 同样的，我们根据例子来说明。 首先，我们改造一下 TestField 类，定义几个方法，其中有静态方法，有参无参方法，有无返回值的方法： 123456789public class TestField &#123; public void m1() &#123; &#125; public void m1(int a, int b) &#123; &#125; private int m2(int a, int b) &#123; return a + b; &#125; public static void sm3() &#123; &#125;&#125; getReturnType 和 getParameterTypes 方法 写的测试代码如下： 12345678910111213141516171819202122232425public static void main(String[] args) &#123; TestField testField1 = new TestField(); Class clazz1 = testField1.getClass(); try &#123; Method m1 = clazz1.getMethod("m1", new Class[]&#123;int.class, int.class&#125;); // 获取方法需要传入参数类型 Class[] parameterizedType1 = m1.getParameterTypes(); // 获取返回类 System.out.println(m1.getReturnType()); // 此处不会输出结果，因为是空数组 for(Class c : parameterizedType1) &#123; System.out.println(c.getName()); &#125; Method m2 = clazz1.getMethod("m1", new Class[0]); Class[] parameterizedType2 = m2.getParameterTypes(); System.out.println(m2.getReturnType()); for(Class c : parameterizedType2) &#123; System.out.println(c.getName()); &#125; &#125; catch (NoSuchMethodException e) &#123; e.printStackTrace(); &#125;&#125; 最终的输出结果为：void、int int、void 上面获取 Method 实例时，需要传入参数类型。为什么呢？因为一个类中可能有许多同名方法，需要用参数来进行区分。 更多的方法使用和 Field 的用法一致。此处就不细讲了。 ¶Constructor 常用方法汇总： 方法名 作用 isVarArgs() 判断构造器的参数是否是可变长度的。即构造器的参数一个或所有被…声明 getParameterTypes() 获取方法中参数的类型 getParameterCount() 获取方法中参数的数量 getExceptionTypes() 获取方法抛出的异常 newInstance(Object … initargs) 该方法用于构造新实例 getModifiers() 以整数形式，返回此对象的 Java 语言修饰符 getName() 获取方法的名字 getDeclaredAnnotations() 获取修饰方法的所有注解 现在，让我们讲讲构造器。按照管理，先上代码。此处我们定义了两个不同参数的构造器，一个共有，一个私有： 1234567891011public class TestField &#123; private int a; public TestField() &#123; a = 1; &#125; private TestField(int a) &#123; this.a = a; &#125;&#125; 然后，我们来进行使用。先获取无参的构造器，然后将其当作有参的构造器使用： 123456789101112public static void main(String[] args) &#123; TestField testField1 = new TestField(); Class clazz1 = testField1.getClass(); try &#123; Constructor c1 = clazz1.getConstructor(new Class[0]); c1.newInstance(new Object[]&#123;2&#125;); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 上面的使用便报错了，报的是参数非法错误：IllegalArgumentException。首先，我们知道，一个类可以有很多个构造器，它们以参数区分。上面的例子拿的无参的构造器，却当作有参的使用，肯定报错。这也就是说，拿到的构造器的参数列表，必须和构造新实例时的参数列表完全一致。另外，上面的 newInstance 方法便是构造器类的核心方法，用于创建新的实例。 另外，让我们做下实验，看能否获取到非 public 的构造器，从 private protected public 三者中测试。关键代码改成下面的代码，分别更改上面定义的类的单参构造器的访问级别。 123456try &#123; Constructor c1 = clazz1.getConstructor(new Class[]&#123;int.class&#125;); c1.newInstance(new Object[]&#123;2&#125;);&#125; catch (Exception e) &#123; e.printStackTrace();&#125; 经过测试，发现只能获取 public 级别的构造器，私有的和受保护的都不能。获取私有的和受保护的构造器会报没有此方法错误：NoSuchMethodException。 至此，反射框架中的几个主要类也讲完了。接下来便是各种应用了。 ¶动态工厂 工厂模式就不详讲了。此处讲一个动态工厂模式。采用反射的方式。采用这种方式可以省去很多代码，尤其是像 if、switch 这种分支判断代码。 首先，我们定义一个基础的业务父类(也可以是接口)： 1234567public abstract class BaseService &#123; protected Context context; public BaseService(Context context) &#123; this.context = context; &#125;&#125; 然后，我们定义一个工厂类，用于获取服务类实例。获取的过程是动态的： 123456789101112131415161718192021222324252627282930313233343536373839404142public class ServiceFactory &#123; // 定义一个实例缓存 private final static ConcurrentHashMap&lt;String, BaseService&gt; hashMap = new ConcurrentHashMap&lt;&gt;(); // 定义获取服务的方法 public synchronized static &lt;T&gt; T getService(Context context, Class&lt;? extends BaseService&gt; serviceClass) &#123; // 定义服务类实例 BaseService baseService; baseService = hashMap.get(serviceClass.getName()); if (baseService == null) &#123; try &#123; // 传入对应的参数类型列表，获取构造器，getDeclaredConstructor 可以获取私有的构造器 Constructor&lt;? extends BaseService&gt; constructor = serviceClass.getDeclaredConstructor(Context.class); constructor.setAccessible(true); baseService = constructor.newInstance(context); putService(businessService); &#125; catch (Throwable e) &#123; throw new RuntimeException("get the service failed:" + serviceClass.getSimpleName(), e); &#125; &#125; return (T) baseService; &#125; // 缓存服务类实例 private static void putService(BaseService baseService) &#123; String clsName = baseService.getClass().getName(); if (!hashMap.containsKey(clsName)) &#123; hashMap.put(clsName, baseService); &#125; &#125; // 清除缓存 public static void clear() &#123; hashMap.clear(); System.gc(); Runtime.getRuntime().runFinalization(); &#125;&#125; 然后，我们就可以动态创建自己业务上的服务类了。 首先需要定义构造器，然后定义获取实例的方法。 12345678910111213141516public class TesterviceImpl extends BaseService &#123; private static final String TAG = "TesterviceImpl"; // 只能通过此方法获取实例，构造器是私有的 public static TesterviceImpl getInstance(Context context) &#123; return ServiceFactory.getService(context, TesterviceImpl.class); &#125; // 私有的构造器，防止调用构造器创建新实例 private TesterviceImpl(Context context) &#123; super(context); &#125; // ---------------------------下面便是业务方法------------------------------ public void a() &#123;&#125; ...&#125; 最后便可以通过类似 TesterviceImpl getInstance(context).a() 的代码获取实例并调用类里面的方法了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 枚举]]></title>
    <url>%2FJava%2FJava%20%E6%9E%9A%E4%B8%BE%2F</url>
    <content type="text"><![CDATA[本文主要讲解 Java 枚举相关的基本知识 ¶概念 枚举的作用是定义一个取值范围，在该取值范围内取值，取值方式有以下特点： 取值只能在枚举定义的范围内进行。 范围内的所有值，彼此之间不能重复，每个值都具有唯一性。 取值可以取范围内定义的任意一个值。 Java 中的枚举是在 1.5 中加入，使用关键字 enum 标记，全称是 enumeration，其对应的类是 Enum 类。创建 enum 时，编译器会为你生成一个相关的类，这个类继承自 java.lang.Enum。 ¶定义 枚举的定义是使用关键字 enum 进行定义的。如下： 123456789101112131415public enum Sex &#123; MALE("male"), FEMALE("female"), UNKNOWN("unknown"); /** * 构造方法默认是私有的 * */ Sex(String sexDescription) &#123; this.sexDescription = sexDescription; &#125; @Override public String toString() &#123; return "Sex Array: " + values(); &#125;&#125; 定义的枚举值，枚举值默认为从0开始的有序数值。即上面定义的枚举中，MALE == 0，FEMALE == 1，UNKNOWN == 2。 事实上，enum是一种受限制的类，并且具有自己的方法。让我们先来看看枚举有哪些常用方法： 方法名 返回类型 方法说明 compareTo(E o) int 比较与指定对象的顺序 equals(Object other) boolean 比较与指定对象是否相等 getDeclaringClass() Class&lt;?&gt; 获取枚举常量对应的 Class 对象 name() String 返回此枚举常量的名称。方法被声明为final，不可被重写 toString() String 返回此枚举常量的描述 valueOf(Class enumType, String name) T 静态方法，返回指定类型的枚举常量。 valus() static T[] 静态方法，返回枚举常量中的声明 默认情况下，name 和 toString 方法都可以用来获取枚举常量的声明名字，但是二者的使用还是有所区别，具体的使用形式如下(以下文字摘自StackOverflow)： 这实际上取决于你想要对返回值做什么： 如果您需要获取用于声明枚举常量的确切名称，则应使用 name()，因为 name 方法被声明成了 final，不可被重写。二是因为 toString 方法可能已被覆盖。 如果您想以用户友好的方式打印枚举常量，您应该使用可以被重写的 toString 方法。 如果觉得使用 name 或者 toString 仍然有困惑，则可以自定义一个如 getXXXDescription() 的带有说明性质的方法。 方法 让我们来看看相关方法的使用： 123456789101112131415public class Main &#123; public static void main(String[] args) &#123; Sex male = Sex.MALE; // 比较大小，小于目标，返回负值(不一定为 -1)；大于目标，返回正值；等于目标，返回 0 int sortSubtraction = male.compareTo(Sex.UNKNOWN); // 返回枚举实例的值，像 valueOf、values 等是静态方法，不能用在枚举实例上 int value = male.ordinal(); // 获取枚举实例的名字，此处返回的是：male String name = male.name(); // 获取 Sex 中定义的所有枚举实例 Sex[] sexs = Sex.values(); // 获取女性性别 Sex female = Sex.valueOf("female"); &#125;&#125; 抽象方法 枚举可以继承自 Enum 类，但是 Enum 类中的方法除了 toString 以外，其他的都被声明为了 final。所以即使我们继承了 Enum，也只能重写 toString 方法。但是，在枚举中，我们可以定义抽象方法，自己实现，如下： 123456789101112131415161718public enum EnumDemo &#123; // 实现方法后，必须加分号，故建议在 enum 中还是形成加分号的习惯 FIRST &#123; @Override public String getInfo() &#123; return "first"; &#125; &#125;, SECOND &#123; @Override public String getInfo() &#123; return "second"; &#125; &#125;; /** * 抽象方法，需要被重写 * */ public abstract String getInfo();&#125; 实现接口 上面定义了两个枚举实例都实现了抽象方法。另外，enum 也可以实现接口，如下： 12345678910interface I &#123; void doSth();&#125;public enum EnumDemo2 implements I&#123; ONE; public void doSth() &#123; // 实现接口中的方法 &#125;&#125; 注意：enum 不能继承类，因为所有的类都继承自 Enum 类，Java 不允许多重继承。 使用 switch 语句 12345678910111213public void getTrafficInstruct(Sex sex) &#123; switch (sex) &#123; case MALE: ... break; case FEMALE: ... break; default: ... break; &#125;&#125; ¶EnumSet 枚举集合 EnumSet 是一个专为枚举设计的集合类，EnumSet中的所有元素都必须是指定枚举类型的枚举值。其有以下一些特点： EnumSet 方法是个抽象类，无暴露出来的构造器，不能通过new关键字创建，只能通过其他的方法创建。创建的结果是 EnumSet 的子类。 EnumSet 集合不允许加入 null 元素，如果试图插入 null 元素，EnumSet 将抛出 NullPointerException 异常。 EnumSet 的集合元素是有序的，EnumSet 以枚举值在 Enum 类内的定义顺序来决定集合元素的顺序。 EnumSet 在内部以位向量的形式存储，这种存储形式非常紧凑、高效。因此EnumSet对象占用内存很小，运行效率很好。 EnumSet 中的常用方法介绍： 方法名 返回类型 方法说明 allOf(Class elementType) EnumSet 静态方法，将一个枚举包含的所有枚举值添加到新的集合中 of(E e) EnumSet 静态方法，根据指定的枚举值创建 EnumSet，of 方法有许多同名方法，可以传入不同数量的参数 noneOf(Class elementType) EnumSet 静态方法，创建一个不包含任何枚举值的 EnumSet retainAll(Collection&lt;?&gt; c) boolean 移除当前集合中所有不在 c 中的元素，即求当前 EnumSet 和 c 的交集 containsAll(Collection&lt;?&gt; c) boolean 判断当前 EnumSet 是否包含所有 c 中的元素 下面，让我们实际来用用这些方法。 首先，定义一个枚举类： 1234567891011121314151617// 一周的枚举类public enum Day &#123; MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;&#125;// 工作人员类public class Worker &#123; // 工作人员的姓名 String name; // 工作人员哪几天在上班 Set&lt;Day&gt; availableDays; public Worker(String name, Set&lt;Day&gt; availableDays) &#123; this.name = name; this.availableDays = availableDays; &#125;&#125; 想象一个场景，在一些工作中，比如医生、客服，不是每个工作人员每天都在的。每个人可工作的时间是不一样的，比如张三可能是周一和周三，李四可能是周四和周六。现在，我们有一些问题需要回答： 有没有哪天一个人都不会来？ 有哪些天至少会有一个人来？ 有哪些天至少会有两个人来？ 有哪些天所有人都会来，以便开会？ 哪些人周一和周二都会来？ 现在，我们便来回答上面的问题： 首先，我们需要构建几个工作人员： 1234// of 方法有不同参数数量的重载方法new Worker("张三", EnumSet.of(Day.MONDAY, Day.TUESDAY, Day.WEDNESDAY)),new Worker("李四", EnumSet.of(Day.TUESDAY, Day.THURSDAY, Day.SATURDAY)),new Worker("王五", EnumSet.of(Day.TUESDAY, Day.THURSDAY)) 开始解决问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * 解决问题：哪些天一个人都不会来？ * */private void noneOfPeopleCome() &#123; // 定义一个包含所有日期的集合 Set&lt;Day&gt; days = EnumSet.allOf(Day.class); // 排除掉不来人的日子 for(Worker w : workers)&#123; days.removeAll(w.getAvailableDays()); &#125; System.out.println(days);&#125;/** * 解决问题：有哪些天至少会有一个人来？这是求工作人员工作日子的并集 * */private void atLeastOnePeopleCome() &#123; // 先创建一个空集合 Set&lt;Day&gt; days = EnumSet.noneOf(Day.class); // 开始添加日子，集合的特性保证了不会有重复的元素被添加 for(Worker w : workers)&#123; days.addAll(w.getAvailableDays()); &#125; System.out.println(days);&#125;/** * 解决问题：有哪些天所有人都会来？这是求工作人员工作日子的交集 * */private void allPeopleCome() &#123; // 拿到所有工作日子 Set&lt;Day&gt; days = EnumSet.allOf(Day.class); for(Worker w : workers)&#123; // 求交集，保留所有在 w 中的枚举元素，如果二者不存在交叉，则 days 变为空 days.retainAll(w.getAvailableDays()); &#125; System.out.println(days);&#125;/** * 解决问题：哪些人周一和周二都会来？ * */private void specificDayPeopleCome() &#123; // 对象从日子变成了人 Set&lt;Worker&gt; availableWorkers = new HashSet&lt;&gt;(); for(Worker w : workers)&#123; if(w.getAvailableDays().containsAll(EnumSet.of(Day.MONDAY,Day.TUESDAY)))&#123; availableWorkers.add(w); &#125; &#125; // 输出结果 for(Worker w : availableWorkers)&#123; System.out.println(w.getName()); &#125;&#125; 至此，我想 EnumSet 的大概用法已经讲的差不多了。 ¶EnumMap 枚举字典 EnumMap 类继承自 AbstractMap 抽象类，在 EnumMap 对相应方法做了特别的实现。保证 key 为枚举类型，并且键值对按照枚举类定义的顺序有序。明白了这个区别，剩下的便是常规的 Map 操作了。下面举个例子，接着上面的内容，现在，我要回答一个问题：哪些天至少会有两个人来？ 这就涉及到了每一天来的人数了，需要统计。用上 EnumMap 刚好合适。 1234567891011121314151617181920212223/** * 解决问题：哪些天至少会有两个人来？ * */private void atLeastTwoPeopleCome() &#123; // EnumMap Key 值为枚举类型，先创建一个 Key 为 Day 类型的空的 EnumMap，单参构造器是为了告诉 EnumMap Key 的类型，不含任何元素 Map&lt;Day, Integer&gt; countMap = new EnumMap&lt;&gt;(Day.class); // 先统计出每天的人数 for(Worker w : workers)&#123; for(Day d : w.getAvailableDays())&#123; Integer count = countMap.get(d); countMap.put(d, count==null?1:count+1); &#125; &#125; // 再找出至少有两个人的天，注意 Map.Entry 的用法 Set&lt;Day&gt; days = EnumSet.noneOf(Day.class); for(Map.Entry&lt;Day, Integer&gt; entry : countMap.entrySet())&#123; if(entry.getValue()&gt;=2)&#123; days.add(entry.getKey()); &#125; &#125; System.out.println(days);&#125; 有人说，枚举使用起来占内存，可以使用注解代替。但是我想说： 枚举的使用绝不可能是程序 OOM 的罪魁祸首。与其花心思进行枚举的优化，不如多找找图片的显示、视频的播放、内存泄漏等问题。 如果你觉得枚举降低了性能，那么**这篇文章**可能会让你的信念动摇。 在程序内部，可以使用注解代替枚举，因为编译器会帮你检查。但是如果需要将程序的接口暴露出去，或者是提供 Jar 包、aar 包，建议还是使用枚举。这样可以规范代码，避免使用出错。 至此，枚举的使用介绍便告一段落了。基于以上情况，个人觉得使用枚举还是很 OK 的。一句话，想用就用。Enum 相比于注解，有着很多优秀的特性，可以帮助我们写出更优秀的代码。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 注解]]></title>
    <url>%2FAndroid%2FAndroid%20%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本文主要讲解 Android 开发常用的注解 ¶介绍 注解可以理解成一个标签，是给类、方法、变量、属性等加标签。注解（Annotation） 为我们在代码中添加信息提供了一种形式化的方法，是我们可以在稍后 某个时刻方便地使用这些数据（通过 解析注解 来使用这些数据），常见的作用有以下几种： 提供信息给编译器： 编译器可以利用注解来探测错误和警告信息 编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理 运行时的处理： 某些注解可以在程序运行的时候接受代码的提取 ¶元注解 『元注解』是用于修饰注解的注解，通常用在注解的定义上，例如： JAVA 中有以下几个『元注解』： @Target：注解的作用目标 @Retention：注解的生命周期 @Documented：注解是否应当被包含在 JavaDoc 文档中 @Inherited：是否允许子类继承该注解 ¶@Target @Target 注解指明了注解的使用范围。其包含一个 ElementType 数组类型的属性字段，属性名是 value。 123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Target &#123; ElementType[] value();&#125; ElementType 是一个枚举类型，其包含以下一些值： 12345678910111213141516171819202122public enum ElementType &#123; // 被修饰的注解可以作用在类、接口(包括注解类型)、或者枚举上 TYPE, // 被修饰的注解可以作用在属性上 FIELD, // 被修饰的注解可以作用在方法上 METHOD, // 被修饰的注解可以作用在参数上 PARAMETER, // 被修饰的注解可以作用在构造器上 CONSTRUCTOR, // 被修饰的注解可以作用在本地局部变量上 LOCAL_VARIABLE, // 被修饰的注解可以作用在注解上 ANNOTATION_TYPE, // 被修饰的注解可以作用在包上 PACKAGE, // 1.8新增类型，被修饰的注解可以作用在泛型上 TYPE_PARAMETER, // 1.8新增类型，被修饰的注解可以作用在任何类型上 TYPE_USE&#125; ¶@Retention Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。 Retention 包含一个 RetentionPolicy 数组类型的属性字段，属性名是 value。 123456@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Retention &#123; RetentionPolicy value();&#125; RetentionPolicy 意为保留策略，是一个枚举类型。 12345678public enum RetentionPolicy &#123; // 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 SOURCE, // 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中 CLASS, // 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们 RUNTIME&#125; ¶@Documented 顾名思义，@Documented 是和文档有关。被它标记的元素会被 Javadoc 工具处理，作用是能够将注解中的元素包含到 Javadoc 中去。 ¶@Inherited Inherited 是继承的意思，其表明了注解的继承关系，子类可以继承父类的注解声明。 如果一个类 1 被 @Inherited 注解过，那么用注解 A 去标记类 1，类 2 继承自类 1。不管类 2 有没有注解 A，类 2 都有 A 的注解，其继承自类 1。 ¶@Repeatable Repeatable 是可重复的意思。@Repeatable 是 Java 1.8 才加进来的，所以算是一个新的特性。 1234567@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.ANNOTATION_TYPE)public @interface Repeatable &#123; // 包含一组相同类型的值 Class&lt;? extends Annotation&gt; value();&#125; 从上面的代码可以看出，@Repeatable 注解使用了泛型，其值是注解的 Class 类型，属性名是 value。 该注解的用法可以参考这篇博文，此处就不介绍了，还是很简单的. 123456789101112131415# 注解的属性从上面的代码中，我们知道注解的定义是使用 @interface。其实所有的注解都隐式继承自 Annotation 这个接口。所以我们见到的所有注解的属性，严格意义上讲并不是属性，而是方法。想想接口的方法是怎么定义的？```javapublic interface A &#123; // 接口的方法定义，加括号 String say();&#125;public @interface B &#123; // 注解的属性定义，加括号 String say();&#125; 两者的定义方式是不是出奇的一致！！！所以，注解的属性，念做属性，实为方法。因此，注解中的属性定义时，一定要加上括号。 ¶Java 内置注解 Java 的内置注解，相信我们大家都不陌生。包括 @Deprecated，@Override，@SuppressWarnings，@SafeVarargs，@FunctionalInterface。 ¶@Deprecated 这个元素是用来标记过时的元素，编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量。比较鲜明的特征是，被这个注解标记的元素会被打上删除线。 ¶@Override 这个元素提示子类要复写父类中被 @Override 修饰的方法。表明子类中被这个注解标记的方法均来自父类。该注解只可作用于方法。 ¶@SuppressWarnings 这个注解用来抑制编译器的警告。之前说过调用被 @Deprecated 注解的方法后，编译器会警告提醒。而有时候开发者会忽略这种警告，他们可以在调用的地方通过 @SuppressWarnings 达到目的。 该注解的使用原理：Java 1.5 为 Java 增加了注解。使用时可以为 “javac” 指令增加 -Xlint 参数来控制是否报告这些警告（如@Deprecated）。默认情况下，Sun 编译器以简单的两行的形式输出警告。通过添加 -Xlint:keyword 标记（例如 -Xlint:finally），您可以获得关键字类型错误的完整说明。通过在关键字前面添加一个破折号，写为 -Xlint:-keyword，您可以取消警告。（-Xlint 支持的关键字的完整列表可以在 javac 文档页面上找到。） 下面是使用到的关键字的详细说明： deprecation：使用了不赞成使用的类或方法时的警告 unchecked：执行了未检查的转换时的警告，例如使用集合时没有指定泛型类型 fallthrough：当 Switch 程序块直接通往下一种情况而**没有 Break **时的警告 path：在类路径、源文件路径等中有不存在的路径时的警告 serial：当在可序列化的类上缺少 serialVersionUID 定义时的警告 finally：任何 finally 子句不能正常完成时的警告 all：关于以上所有情况的警告 基于上面的描述，下面是一个使用例子： 12345678910111213public class D1 &#123; @Deprecated public static void foo() &#123; &#125;&#125; public class D2 &#123; // 忽略废弃元素的警告，value中的可指定值在上面列举出来了 @SuppressWarnings(value=&#123;"deprecation"&#125;) public static void main(String[] args) &#123; D1.foo(); &#125;&#125; ¶@SafeVarargs 参数安全类型注解。它的目的是提醒开发者不要用参数做一些不安全的操作。它的存在会阻止编译器产生 unchecked 这样的警告。它是在 Java 1.7 的版本中加入的。 具体的例子此处我就不讲了，可以看看这片博文 ¶@FunctionalInterface 函数式接口注解，这个是 Java 1.8 版本引入的新特性。函数式编程很火，所以 Java 8 也及时添加了这个特性。函数式接口可以很容易转换为 Lambda 表达式。 ¶Android 注解 Android 平台提供了部分注解供我们使用，在使用之前，需要导入相关的包，语句如下： 1compile &apos;com.android.support:support-annotations:VERSION_NUM&apos; 此包提供的注解如下： ¶IntDef 和 StringDef IntDef 和 StringDef 是 Android 提供的两个魔法变量注解，用于取代 enum 和 魔法数字(字符串)等，其有一个数组类型的 value 属性。 假设我们需要定义消息类型，包括语音、文本、表情、图片、视频等，这些消息类型用整数定义。 123public class Msg &#123; int msgType;&#125; 我们并不希望出现其他数字的消息类型，即需要限定类型的范围。此时就有几种方法： 在使用处加上注释，这并不是什么好方法，不建议采用 使用枚举类型代替整型，这种方法是可行的，但是在低端机上可以会存在内存占用大的情况。其使用方法如下： 1234567public class Msg &#123; MsgType msgType;&#125;public enum MsgType &#123; TEXT, VOICE, PHOTO, VIDEO&#125; 第三种方法便是使用注解，可以使用 IntDef 注解。其使用方法如下： 1234567891011121314151617181920// 1、定义消息类型public class MsgType &#123; public static final int TEXT = 1; public static final int VOICE = 2; public static final int PHOTO = 3; public static final int VIDEO = 4;&#125;// 2、自定义注解，指定取值范围，后续增加的消息类型都需要在这里加入// IntDef 有一个属性 value 是一个 int 类型的数组@IntDef(value = &#123;MsgType.TEXT, MsgType.VOICE, MsgType.PHOTO, MsgType.VIDEO&#125;)@Retention(RetentionPolicy.SOURCE)public @interface AMsgType &#123;&#125;// 3、使用注解// 这样就指定了取值范围public class Test &#123; @AMsgType public int msgType;&#125; 就这么简单，StringDef 的用法也差不多。不过需要注意的是，IntDef 注解还有个 boolean 类型的 flag 的属性，默认情况下，IntDef 的所有取值会被当作 enum （枚举类型）处理，而如果设置了 flag = true，那么 IntDef 中设置的取值范围就会被当作 flag （标志位）处理，标志位可以进行位运算。 另外，有一个 IntRange 注解和 IntDef 注解类似，前者可以指定取值范围，包括 from 和 to 两个属性，取值区间是连续的。而后者的取值范围更自由，可以不是连续的取值范围。 ¶Threading 注解 Thread注解是帮助我们设置方法的执行线程，如果和指定的线程不一致，抛出异常。Threading 注解类型： @UiThread：UI线程 @MainThread：主线程 @WorkerThread：工作线程（子线程） @BinderThread：绑定线程 ¶取值限制范围注解 Android 提供了集中取值的范围限制注解供我们使用，其中就包括上面我们提到的 @IntRange 和 @FloatRange 注解，另外还包括一个 @Size 注解。常用的就这三个： @Size @IntRange @FloatRange @Size 使用 min、max，而后两者使用 from、to。@Size 用于定义尺寸，其源码如下： 12345678910111213@Retention(SOURCE)@Target(&#123;PARAMETER,LOCAL_VARIABLE,METHOD,FIELD&#125;)public @interface Size &#123; // 尺寸的默认值 long value() default -1; // 尺寸 n 的取值范围：min &lt;= n &lt;= max // 可取的最小值 long min() default Long.MIN_VALUE; // 可取的最大值 long max() default Long.MAX_VALUE; // 尺寸的缩放倍数 long multiple() default 1;&#125; ¶@CallSuper 注解 @CallSuper 注解主要是用来提示子类在覆盖父类的方法时，需要调用对应的super.***方法。下面的代码是个例子： 12345678910111213141516// 父类public class F &#123; // 提示子类在重写父类的 init 方法时，需要加上 super.init 语句 @CallSuper protected void init()&#123; &#125;&#125;// 子类class T extends F&#123; @Override protected void init() &#123; // 此处不加入这句，编译器会报错 super.init(); &#125;&#125; ¶@CheckResult 注解 此注解主要是提示我们使用到方法定义的返回值。该注解有一个 suggest 的字符串类型的属性，允许我们加上一些提醒，来告诉方法调用者为什么要使用此方法的返回值。 1234567891011@CheckResult(suggest = "这是注解的说明，请使用返回值!!!")public int getInt() &#123; return 1;&#125;public static void main(String[] args) &#123; // 这种调用方式会报错 getInt(); // 这种调用方法是正确的 int result = getInt();&#125; 另外，注解也可以通过反射获取到。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯法-符号三角形问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%9B%9E%E6%BA%AF%E6%B3%95-%E7%AC%A6%E5%8F%B7%E4%B8%89%E8%A7%92%E5%BD%A2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[算法思想：回溯法 实际问题：符号三角形问题 编写语言：Java ¶问题描述 如下图是由 14 个 + 和 14 个 - 组成的符号三角形,两个同号的下面是 +，两个异号的下面是 -。 设符号三角形的第一行有 n 个符号，求对于给定的 n，计算有多少个不同的符号三角形，使其所包含的 + 和 - 的数量相同。 ¶解题思路 设 + 为1，- 为 0，这样可以使用异或运算（相同为 0，不同为 1）表示符号三角形的关系： “+ +” 为 +：1 ^ 1 = 0 “- -” 为 +：0 ^ 0 = 0 “+ -” 为 -：1 ^ 0 = 1 “- +” 为 -：0 ^ 1 = 1。 使用 x[n] 表示第一行的总共 n 个符号的取值，并且定义： x[i] = 0：第一行第 i 个符号的取值为 -。 x[i] = 1：第一行第 i 个符号的取值为 +。 使用递归回溯，不断改变第一行的每个符号，搜索符合条件的解。 剪枝函数（剪枝操作，或者称作递归终止条件）是：当前 + 或者 - 的符号数量大于一半，或者列数达到指定上限（因为解题时是从第一列开始找，一直找到第 n 列截止） ¶代码解疑 此处可以跳过，直接看代码，如果有不懂的地方，可以返回来看这里。 位操作：从效率上讲，一个移位指令占2个机器周期，而乘除法指令占4个机器周期。故在做乘除法时，使用位运算有着更高的效率。在本次博文写的代码中，主要用到了两个技巧：与运算、异或运算与移位操作。 与运算：与运算是一种逻辑运算技巧，它的规则是：真与真=真、假与真=假、真与假=假、假与假=假；即满足两个条件都为真时，结果才为真。在 Java 中，与运算符是 &amp;，&amp; 表示按位与，并且 0 表示假，1 表示真，即 1 &amp; 1 = 1、0 &amp; 1 = 0、1 &amp; 0 = 0、0 &amp; 0 = 0。若两个数相与，如 4 和 3与为 0，就可以表示为 100 &amp; 011 = 0，在计算机中，十进制的数是用二进制表示的，如 4 在计算机中的表示是 100。如需要了解更详细的知识，请自行百度。 扯远了，回归正题。在代码中，我们有判断一个数的奇偶性。使用了这样的技巧：n &amp; 1，在计算机中，奇数的最低位的值必然为 1（其他高位是2的整数倍，相加必然为偶数，最低位如果是0，就无法构成奇数），而 1 是最小的奇数，除了最低位，其他位都为 0。按照与运算的规则，**任何一个数 n 与上 1，除了最低位，其他位都是 0。如果 n 为奇数，与的结果最低位为 1，结果是 1；如果 n 为偶数，与的结果最低位为 0，结果是 0。**我们因而可以形如 n &amp; 1 的式子来判断一个数的奇偶性。 异或运算：逻辑运算的一种，前面解释过，此处不讲了。 移位操作：在 Java 中，移位运算符使用 &gt;&gt;（右移）和 &lt;&lt;（左移）表示的。如 4 右移一位，可以表示为 4 &gt;&gt; 1，从二进制的角度将，100（4） 变成了 010（2），即缩小了一半。如果左移，则是增大一倍，在有大量乘除操作的场景中，使用移位操作可以极大的提升效率。 剪枝操作的使用位置有两处，二选一，但应注意两个位置的判断逻辑有差别。具体的代码注释中有详细说明。 根据符号三角形的构成规则，如果三角形第一行有 n 列，那么符号三角形就有 n 行，即行数和列数相等。并且相邻两行之间的列数差 1，带入等差数列的公式，可以得出符号三角形的符号总数为 n * (n + 1) / 2。 因为 + 和 - 的数量必须相等，所以符号三角形的符号数量是偶数，即 n * (n + 1) / 2 是偶数 统计完一种构造方式后，需要还原已统计符号的数量，才能进行下一次的符号三角形构造。 ¶Java 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public class SymbolicTriangleProblem &#123; // 第一行的符号个数 public static int n; // half 的目标数值为 (n * (n + 1) / 2) / 2，即 n * (n + 1) / 4 public static int half; // 当前"-"的个数 c：count public static int c; // 符号三角形矩阵 public static int[][] p; // 符号数组 s：sign public static String[] s = &#123;"+", "-"&#125;; // 已找到的符号三角形的个数 public static long sum; public static void main(String[] args) &#123; compute(4); System.out.println("符合条件的符号三角形总数： " + sum); &#125; /** * 计算指定列数下的符号三角形 * * @param col 符号三角形第一行的列数， * 其必须满足 (col * (col + 1) &gt;&gt; 1) 是偶数， */ public static void compute(int col) &#123; n = col; c = 0; sum = 0; // &gt;&gt; 右移一位，表示当前数除以 2 // 当前的符号总个数，为 1 + 2 + ... + n 的数量 half = n * (n + 1) &gt;&gt; 1; // 符号数量为单数，返回 if((half &amp; 1) == 1) &#123; return; &#125; half &gt;&gt;= 1; p = new int[n+1][n+1]; // 从第1行的第1个列开始查找 backtrack(1); &#125; /** * 回溯函数 * * @param col 当前正在查找的位置：第 col 列 */ public static void backtrack(int col) &#123; /** * 如果将剪枝操作移动到这里，总数就不能算 * (col * (col + 1) &gt;&gt; 1，而应该算 (col * (col - 1) &gt;&gt; 1， * 即算少一列的情况，因为可能会出现 col &gt; n 的情况，导致结果出错 */ /* if(c &gt; half || ((col * (col - 1) &gt;&gt; 1) - c &gt; half)) &#123; return; &#125; */ // 当前的列数超过规定的列数 if(col &gt; n) &#123; sum++; // 打印符号 System.out.println("第 " + sum + " 个符号三角形："); for(int i = 1; i &lt;= n; i++) &#123; // 打印符号三角形中每一行开始的空白 for(int j = 1; j &lt; i; j++) &#123; System.out.print(" "); &#125; for(int j = 1; j &lt;= (n - i + 1); j++) &#123; System.out.print(s[p[i][j]] + " "); &#125; System.out.println(); &#125; System.out.println(); &#125; else &#123; // 将"+"设为0，"-"设为1 for(int i = 0; i &lt; 2; i++) &#123; p[1][col] = i; // 统计"-"的个数 c += i; // 判断接下来的 n - 1 行 // 符号三角形问题中，行的总数等于列的总数 for(int j = 2; j &lt;= col; j++) &#123; // 通过异或运算求其余行数的放置方式 p[j][col - j + 1] = p[j - 1][col - j + 1] ^ p[j - 1][col - j + 2]; c += p[j][col - j + 1]; &#125; // + 或者 - 的数量未超过一半 // 此处使用 col * (col + 1) &gt;&gt; 1，是因为不会出现 col &gt; n的情况 if(c &lt;= half &amp;&amp; ((col * (col + 1) &gt;&gt; 1) - c &lt;= half)) &#123; backtrack(col + 1); &#125; // 还原 - 的数量 for(int j = 2; j &lt;= col; j++) &#123; c -= p[j][col - j + 1]; &#125; c -= i; &#125; &#125; &#125; &#125; ¶运行结果 下图为列数为 4 的结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯法-N皇后问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%9B%9E%E6%BA%AF%E6%B3%95-N%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[算法思想：回溯法 实际问题：N皇后问题 编写语言：Java ¶问题描述 N 皇后问题要求求解在 N × N 的棋盘上放置 N 个皇后，并使各皇后彼此不受攻击的所有可能的棋盘布局。皇后彼此不受攻击的约束条件是：任何两个皇后均不能在棋盘上同一行、同一列或者同一对角线上出现。 ¶解题思路 由于N皇后问题不允许两个皇后在同一行，所以，可用一维数组 column 表示 N 皇后问题的解，column[i] 表示第 i 行的皇后所在的列号。由上述 column 数组求解 N 皇后问题，保证了任意两个皇后不在同一行上，我们只需判定皇后彼此不受攻击的其他条件，具体描述如下： 若 column[i] = column[j]，则第 i 行与第 j 行皇后在同一列上。包含 (i, column[i])，(j, column[j]) 的解不可行。 第 i 行的皇后在第 j 列，第 s 行皇后在第 t 列，即 column[i] = j 和 column[s] = t，若 |i - s| = |j - t|，则皇后在同一对角线上。因为棋盘为正方形，对角线的斜率为 1。包含这种放置方式的解不可行。 ¶Java 代码 有了上述的约束条件（即剪枝函数），则可以编写 Java 代码了。下面的 Java 代码采用的是递归回溯的方法（另有迭代回溯的方法）。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.util.Scanner; public class NQueenProblem &#123; private static int result; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.print("请输入皇后的数量："); int number = input.nextInt(); // column[i] 表示第 i 行的皇后(也是第 i 个皇后)放在第 column[i] 列 int[] column = new int[number]; backtrack(column, 0, number); System.out.println("\n可行的结果数量为：" + result); &#125; /** * 求取 N 皇后问题的解，输出所有可行的答案 * * @param column 存储列数据的数组 * @param row 当前求解的行数，，即从第 row 行开始求解放置方案 * @param number 皇后的数量，即总行数 */ private static void backtrack(int[] column, int row, int number) &#123; // 行数达标，输出结果 if(row &gt;= number) &#123; System.out.println(); for(int i = 0; i &lt; number; i++) &#123; for(int j = 0; j &lt; number; j++) &#123; // 输出第 i 个皇后的位置 if(j == column[i]) &#123; System.out.print((i + 1) + " "); &#125; else &#123; System.out.print(0 + " "); &#125; &#125; System.out.println(); &#125; result++; &#125; else &#123; for(int i = 0; i &lt; number; i++) &#123; column[row] = i; // 如果当前位置可以放皇后，则进行下一行的位置 if(place(row, column)) &#123; backtrack(column, row + 1, number); &#125; &#125; &#125; &#125; /** * 判断当前位置是否可以放皇后 * 1、行相同或者列相同，不能放皇后 * 2、|row1 - row2| = |column1 - column2|，即两个皇后不能处于 * 对角线上(斜率为 1) * * @param row 当前位置所在的行数 * @param column 列数组，用以通过行确定列。 */ private static boolean place(int row, int[] column) &#123; for(int i = 0; i &lt; row; i++) &#123; if((column[i] == column[row]) || (Math.abs(i - row) == Math.abs(column[i] - column[row]))) &#123; return false; &#125; &#125; return true; &#125;&#125; ¶实验结果 下图为皇后为 6 的结果： 下图为皇后为 4 的结果： 上面的实验结果可以验证代码的正确性。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯法-总览]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%9B%9E%E6%BA%AF%E6%B3%95-%E6%80%BB%E8%A7%88%2F</url>
    <content type="text"><![CDATA[¶概念思想 回溯法有“通用的解题法”之称，用它可以系统地搜索一个问题的所有解或任一解。回溯法是一个既带有系统性又带有跳跃性的搜索算法，它在问题的解空间中，按深度优先策略，从根结点出发搜索解空间树。算法搜索至解空间树的任一结点时，先判断该结点是否包含问题的解。如果肯定不包含，则跳过对以该结点为根的子树的搜索，转而逐层向其祖先结点回溯。否则，进入该子树，继续按深度优先策略搜索。回溯法求问题的所有解时，要回溯到根，且根结点的所有子树都已被搜索遍历才结束。回溯法求问题的一个解时，只要搜索到问题的一个解就可结束。这种以深度优先方式系统地搜索问题解的算法称为回溯法，它适用于解组合数较大的问题。 ¶算法框架 知道了什么叫回溯法，了解了回溯法的基本思想之后，我们就可以定义一个通用的回溯法算法框架，使我们更加方便透彻的在程序中实现它。它包含以下几个必要的步骤： **定义问题的解空间：**用回溯法解决问题时，应该明确定义问题的解空间。问题的解空间中应该至少包含问题一种（最优）解。 **确定解空间结构：**确定易于搜索的解空间结构，使得能用回溯法方便地搜索整个解空间 。通常将解空间组织成树或者图的形式。 **搜索解空间：**以深度优先方式搜索解空间，并在搜索过程中使用剪枝函数，避免无效搜索。剪枝函数的作用是终止当前结点搜索其子树，转而回溯到父节点。 ¶博文导航 回溯法-N皇后问题]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>总览</tag>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F%E8%AF%AD%E6%B3%95%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[¶Markdown 简介 Markdown 是一种纯文本格式的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作，提高效率。 ¶语法讲解 ¶标题 在想要设置为标题的文字前面加 # 来表示，# 和文字之间需要空格隔开。 一个 # 是一级标题，二个 # 是二级标题，以此类推。最多支持六级标题。 12345678# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题注意：符号与内容之间有空格。 效果如下： ¶字体 要加粗的文字左右分别用两个 * 号包起来，要倾斜的文字左右分别用一个 * 号包起来，要倾斜和加粗的文字左右分别用三个 * 号包起来，要加删除线的文字左右分别用两个 ~ 号包起来。 123456**这是加粗的字体***这是倾斜的字体****这是加粗+倾斜的字体***~~这是加了删除线的字体~~注意：符号与内容之间无空格。 效果如下： 这是加粗的字体 这是倾斜的字体 这是加粗+倾斜的字体 这是加了删除线的字体 ¶分割线 三个或者三个以上的 - 或者 * 都可以。 1234-------******** 效果如下： ¶引用 在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;，直到 n 个，可以无限加下去。 12345&gt;这是引用的内容 1&gt;&gt;这是引用的内容 2&gt;&gt;&gt;&gt;这是引用的内容 3注意：符号与内容之间无空格。 效果如下： 这是引用的内容 1 这是引用的内容 2 这是引用的内容 3 ¶图片 12345678格式： ![图片 alt](图片地址 &apos;&apos;图片 title &apos;&apos;)说明： 图片 alt 就是显示在图片下面的文字，相当于对图片内容的解释。 图片 title 是图片的标题，当鼠标移到图片上时显示的内容。title 可加可不加。 图片地址与图片标题之间有个空格，前者不加双引号，后者要加双引号。举例： ![最小生成树](/images/prim/最小生成树.png &quot;原始连通图&quot;) 效果如下： ¶超链接 1234567格式： [超链接名](链接地址 &apos;&apos;链接 title &apos;&apos;)说明： 链接 title 是超链接的标题，当鼠标移到超链接上时显示的内容。title 可加可不加。 链接地址与链接标题之间有个空格，前者不加双引号，后者要加双引号。举例： [访问百度](https://www.baidu.com &quot;跳转百度主页&quot;) 效果如下： 访问百度 ¶列表 无序列表 无序列表用 - + * 任何一种都可以。 12345- 无序列表 1+ 无序列表 2* 无序列表 3注意：符号与内容之间要有空格，列表之间不空行。 效果如下： 无序列表 1 无序列表 2 无序列表 3 有序列表 有序列表用数字加点表示。 123451. 有序列表 12. 有序列表 23. 有序列表 3注意：点号与内容之间要有空格，列表之间不空行。 效果如下： 有序列表 1 有序列表 2 有序列表 3 列表嵌套 上一级和下一级之间敲三个空格即可。 效果如下： 上一级无序列表 下一级有序列表 1 下一级有序列表 2 上一级无序列表 下一级无序列表 1 下一级无序列表 2 上一级有序列表 下一级无序列表 1 下一级无序列表 2 上一级有序列表 下一级有序列表 1 下一级有序列表 2 ¶表格 123456789101112| 左对齐 | 居中 | 右对齐 || :--- | :---: | ---: || 内容 | 内容 | 内容 || 内容 | 内容 | 内容 |注： 第二行分割表头和内容。 - 有一个就行，为了对齐，可以多加几个 - 左边加 ：表示文字居左 - 两边加 ：表示文字居中 - 右边加 ：表示文字居右 - 两边都不加 : 使用默认格式，文字默认居左 效果如下： 左对齐 居中 右对齐 内容1 内容2 内容3 内容3 内容4 内容5 ¶代码 单行代码 单行代码用两个 ` 包括着即可。 1`int a = 2;` 效果如下： int a = 2; 多行代码 多行代码用六个 ` 包括着即可，开头的三个符号后还可以指定编程语言的类型，多行代码又叫代码块。 1234567&apos;```javapublic class A &#123; public static main(String[] args) &#123; System.out.println(&quot;Hello world!&quot;); &#125;&#125;```&apos; 效果如下： 12345public class A &#123; public static main(String[] args) &#123; System.out.println("Hello world!"); &#125;&#125; Markdown 代码块中支持的常用高亮语言类型如下： 语言 Markdown 关键字 Bash bash CMake cmake C++ cpp C# cs CSS asciidoc DOS.bat dos Dust dust ERB(Embedded Ruby) erb G-code(ISO 6983) gcode Go bash Gradle gradle Groovy groovy HTML html HTTP http Ini file ini Java java JavaScript javascript JSON json Makefile makefile Mathematica mathematica Matlab matlab Objective C objectivec PHP php Protocol Buffers protobuf Python python Q q R r Ruby ruby Rust rust Scheme scheme SQL sql Swift swift text text/plain TypeScript typescript Vim Script vim XML xml YAML yml ¶HTML 标签 Markdown 是支持 HTML 标签的，因为 Markdown 标记语言的内容最终会被解析陈伟 HTML 标签，供浏览器显示。此处举几个用的较多的标签： 页内跳转 页内跳转可以实现从本页的 a 处跳转到 b 处。其采用 HTML 中的 a 标签，分两部分定义，下面通过个例子演示。 例子：在 a 处显示一个超链接样式，点击可以跳转到 b 处。 在 b 处设置一个锚点(定位点)，使用样式 &lt;a name=&quot;b&quot;&gt;定位点&lt;/a&gt;。 在 a 处设置跳转目标，跳转至 b 处，使用样式 &lt;a href=&quot;#b&quot;&gt;点击跳转&lt;/a&gt;。 点击 a 处即可跳转到 b 处，点击浏览器的回退按钮，即可返回到 a 处。 效果如下： 定位点 点击跳转 上下标 上标：采用 &lt;sup&gt;&lt;/sup&gt; 标签。 下标：采用 &lt;sub&gt;&lt;/sub&gt; 标签。 12H&lt;sub&gt;2&lt;/sub&gt;O2&lt;sup&gt;4&lt;/sup&gt; = 16 效果如下： H2O 24 = 16 更多的标签可以自行查找资料，如果担心过多的 HTML 代码会出现解析错误，可以使用 [html][/html] 包裹着 HTML 的源码。]]></content>
      <categories>
        <category>语法</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法-总览]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%80%BB%E8%A7%88%2F</url>
    <content type="text"><![CDATA[¶思想描述 贪心算法（贪婪算法）是指在对问题进行求解时，在每一步都做出在当前看来是最好的选择，从而希望能够导致结果是最好或者最优的算法。贪心算法所得到的结果往往不是整体的最优解，而是局部的最优解。 贪心算法有两个基本性质，即贪心选择性质和最优子结构性质。贪心选择性质是贪心算法与动态规划算法的主要区别，其采用从顶向下、以迭代的方法做出相继选择。每做一次贪心选择，就将所求问题简化为一个规模更小的子问题。对于一个具体问题，要确定它是否具有贪心选择的性质，我们需要证明每一步所作的贪心选择能最终得到问题的最优解。首先可以证明问题的一个整体最优解是从贪心选择开始的，而且作了贪心选择后，原问题简化为一个规模更小的类似子问题。然后，用数学归纳法证明，通过每一步贪心选择，最终可得到问题的一个整体最优解。最优子结构性质是指一个问题的最优解包含其子问题的最优解。运用贪心策略在每一次转化时都取得了最优解。问题的最优子结构性质是该问题可用贪心算法或动态规划算法求解的关键特征。贪心算法的每一次操作都对结果产生直接影响，而动态规划则不是。贪心算法对每个子问题的解决方案都做出选择，不能回退；动态规划则会根据以前的选择结果对当前进行选择，有回退功能。动态规划主要运用于二维或三维问题，而贪心一般是一维问题。 ¶算法特征 贪心算法和动态规划算法有着很多类似的地方，将两者进行比较，可以更加深刻的理解贪心算法具有的特征。 最优解 贪心算法：每一步的最优解一定包含上一步的最优解，上一步之前的最优解则不作保留； 动态规划：全局最优解中一定包含某个局部最优解，但不一定包含前一个局部最优解，因此需要记录之前的所有的局部最优解 构造过程： 贪心算法：如果把所有的子问题看成一棵树的话，贪心从根出发，每次向下（自顶向下）遍历最优子树即可（通常这个“最优”都是基于当前情况下显而易见的“最优”）；这样的话，就不需要知道一个节点的所有子树情况，于是构不成一棵完整的树； 动态规划：动态规划则自底向上，从叶子向根，构造子问题的解，对每一个子树的根，求出下面每一个叶子的值，最后得到一棵完整的树，并且最终选择其中的最优值作为自身的值，得到答案 复杂度： 贪心算法：根据以上两条可以知道，贪心算法不能保证求得的最后解是最佳的，一般复杂度低； 动态规划：动态规划本质是穷举法，可以保证结果是最佳的，复杂度高。 ¶博文导航 贪心算法-活动安排问题 贪心算法-一般背包问题 贪心算法-哈夫曼编码 贪心算法-单源最短路径 贪心算法-最小生成树]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>总览</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法-最小生成树]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%2F</url>
    <content type="text"><![CDATA[算法思想：贪心算法 实际问题：最小生成树 编写语言：Java 图的最小生成树指的是图的一个极小连通子图（同时一棵树），其包含图中的所有 n 个结点，并且有保持图连通的最少的边。设最小生成树中边的数量为 m，顶点的数量为 n，则 m 和 n 满足的数学关系如下：m = n -1。值得注意的是，一个图的最小生成树可能并不唯一。 ¶Prim 算法 ¶问题描述 Prim 算法，又叫普里姆算法，是图论中的一种算法，可在加权连通图里搜索最小生成树。 连通图：在一个无向图 G 中，若从顶点 i 到顶点 j 有路径相连（当然从 j 到 i 也一定有路径），则称 i 和 j 是连通的。如果图中任意两点都是连通的，那么图被称作连通图。如果 G 是有向图，那么连接 i 和 j 的路径中所有的边都必须同向。例如，在一个有向图中，E(i, j) 表示点 i 到 j 的边，则 E(j, i) 表示与 E(i, j) 反向的边，E(j, k) 表示与 E(i, j) 同向的边(k 点是 i，j 之外的其它点)。 ¶MST 生成过程 MST，全称 Minimum Spanning Tree，中文名最小生成树。使用 Prim 算法构造最小生成树的过程如下： 图片 描述 可选点 已加入点 原始图中有 7 个点，11 条边 A B C D E F G ----- 任选点A，将点 A 加入到观测域中，边(A, D)是最短的边。 B D A 将点 D 加入到观测域中，边(D, F)是最短的边。 B E F G A D 将点 F 加入到观测域中，边(A, B)是最短的边。 B E G A D F 将点 B 加入到观测域中，边(B, E)是最短的边。 C E G A B D F 将点 E 加入到观测域中，边(C, E)是最短的边。 C G A B D E F 将点 C 加入到观测域中，边(E, G)是最短的边。 G A B C D E F ----- 将点 G 加入到观测域中，MST 构造完成。 ----- A B C D E F G ¶算法构造 **本算法基于无向图构造。**对于 i ∈ S(S 中存放着已经加入最小生成树的顶点), j ∈ V - S(V 是存放所有点的集合), 且权值 c[i][j] 最小的边(i, j)，实现 prim 算法比较简单的方法是设置两个数组 closest 和 lowcost, 对于每一个 j ∈ V - S, closest[j] 是 j 在 S 中的邻接顶点，它与 j 在 S 中的其他邻接顶点 k 相比较，有 c[j][closest[j]] &lt;= c[j][k]。lowcost[j] 的值就是 c[j][closest[j]]。在 Prim 算法的执行过程中，首先找出 V - S 中使 lowcost 值最小的顶点 j，然后根据数组 closest 选取边(j, closest[j])，最后将 j 添加到 S 中，并对 closest 和 lowcost 做必要的修改。 初始化点集 S。任意选择一个点加入到 S 中； 寻找最短路径，将点 j 加入到 S 中。点 j 满足：j ∈ V - S, i ∈ S，并且 c[j][i] 最小，即 j 是与 i 相邻的顶点中权值最小的点（贪心性质的具体体现）； 将 i 加入到 closest[j] 中，将 c[i][j] 加入到 lowcost[j] 中(无向图中，c[i][j] = c[j][i])。 不断重复第二步和第三步，直到节点全部压入 S 中为止。 ¶Java 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * 测试用例： * 请输入图的顶点和边的个数(格式：顶点个数 边个数)：7 11 * * 请输入图的路径长度(格式：起点 终点 长度)： * 1 2 7 * 1 4 5 * 2 3 8 * 2 4 9 * 2 5 7 * 3 5 5 * 4 5 15 * 4 6 6 * 5 6 8 * 5 7 9 * 6 7 11 * * 结果： * 第 1 步: 加入边 (1, 4) 权重为 5 * 第 2 步: 加入边 (4, 6) 权重为 6 * 第 3 步: 加入边 (1, 2) 权重为 7 * 第 4 步: 加入边 (2, 5) 权重为 7 * 第 5 步: 加入边 (5, 3) 权重为 5 * 第 6 步: 加入边 (5, 7) 权重为 9 * 总权值为：39 */ import java.util.Scanner; public class PrimMST &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.print("请输入图的顶点和边的个数(格式：顶点个数 边个数)："); int n = input.nextInt(); //顶点的个数 int m = input.nextInt(); //边的个数 System.out.println(); int[][] a = new int[n + 1][n + 1]; //初始化邻接矩阵 for(int i = 0; i &lt; a.length; i++) &#123; for(int j = 0; j &lt; a.length; j++) &#123; a[i][j] = -1; //初始化没有边 &#125; &#125; System.out.println("请输入图的路径长度(格式：起点 终点 长度)："); //总共m条边 for(int i = 0; i &lt; m; i++) &#123; //起点，范围1到n int s = input.nextInt(); //终点，范围1到n int e = input.nextInt(); //长度 int l = input.nextInt(); if(s &gt;= 1 &amp;&amp; s &lt;= n &amp;&amp; e &gt;= 1 &amp;&amp; e &lt;= n) &#123; //无向有权图 a[s][e] = l; a[e][s] = l; &#125; &#125; System.out.println(); prim(a); &#125; /** * prim算法求解最小生成树 * * @param c 图的邻接矩阵 */ public static void prim(int[][] c) &#123; int n = c.length; //判断节点是否放入的矩阵 boolean[] s = new boolean[n]; int[] lowcost = new int[n]; int[] closest = new int[n+1]; int totalWeight = 0; //放入顶点1 s[1] = true; // 初始化 for(int j = 2; j &lt; n; j++) &#123; lowcost[j] = c[1][j]; closest[j] = 1; s[j] = false; &#125; //共扫描n-2次，v到v自己不用扫 for(int i = 1; i &lt; n - 1; i++) &#123; int min = Integer.MAX_VALUE; int j = 1; //找寻最短路径，记录点j和距离lowcost[j] for(int k = 2; k &lt; n; k++) &#123; if(lowcost[k] != -1 &amp;&amp; lowcost[k] &lt; min &amp;&amp; !s[k]) &#123; min = lowcost[k]; j = k; &#125; &#125; System.out.println("第 " + i + " 步: 加入边 (" + closest[j] + ", " + j + ") 权重为 " + min); totalWeight += min; //将j添加到S中 s[j] = true; //遍历整个图，用j更新lowcost数组 //判断在新的点加入的情况下，是否有更短的路径 for(int k = 1; k &lt; n; k++) &#123; if(!s[k] &amp;&amp; c[j][k] != -1) &#123; if(c[j][k] &lt; lowcost[k] || lowcost[k] == -1) &#123; lowcost[k] = c[j][k]; closest[k] = j; &#125; &#125; &#125; &#125; System.out.println("\n总权值为：" + totalWeight); &#125;&#125; ¶运行结果 ¶Kruskal 算法 Kruskal 算法，又叫克鲁斯卡尔算法，和 Prim 算法一样，是用来求一个连通图的最小生成树的。但是它的思路和 Prim 算法不一样，Prim 算法从顶点的角度出发，而 Kruskal 算法却是从边的角度出发。区别可以看下面的 MST 生成过程。 连通分量 无向图 G 的极大连通子图称为 G 的连通分量( Connected Component)。任何连通图的连通分量只有一个，即是其自身，非连通的无向图有多个连通分量。如下图。 图片 描述 连通图的连通分量只有一个，就是它自身 该非连通图的连通分量有三个，分别是 (A B D)，(C E)，(F G) ¶MST 生成过程 图片 描述 已加入点 原始图中有 7 个点，11 条边 ----- 加入边 (A, D) A D 加入边 (C, E) A C D E 加入边 (D, F) A C D E F 加入边 (A, B) A B C D E F 加入边 (B, E)，将两个不同的连通分量合并为一个连通分量 A B C D E F 图 1 加入边 (E, G) A B C D E F G ¶算法构造 构造边 Edge 类，用于存储原图中边的信息；构造并查集 DSU(Disjoint Set Union) 类，用于连通两个不同的分量(并操作)，并判断两个顶点是否处于一个连通分量中(检查操作)； 将图看作一个森林，即每个节点一开始都是一棵树。根节点是其自身； 对原图中的边按照权值从小到大排序。每次选择权值最小的边(贪心性质的具体体现)，对边的两个顶点进行并查操作，已经选过的边就不选了。 重复第 3 步，知道加入最小生成树中的边数量为 m，顶点的数量 n，其满足：m = n - 1。 ¶Java 代码 说明 该算法中采用了路径压缩的策略，即每个节点只存储其根节点，不存储中间的父节点。每个节点的根节点存储在 root[] 数组中。 合并两颗不同的树时，遵循着将小树合并到大树的原则。其尺寸存储在 size 数组中。 对于 size，最初的时候每棵树只有一个节点，故合并时 size ++，就不会出错。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166import java.util.Scanner;import java.util.ArrayList;import java.util.Arrays;import java.util.Comparator;public class KruskalMST &#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.print("请输入图的顶点和边的个数(格式：顶点个数 边个数)："); int n = input.nextInt(); // 顶点的个数 int m = input.nextInt(); // 边的个数 Edge[] edges = new Edge[m]; System.out.println("请输入图的路径长度(格式：起点 终点 长度)："); // 总共m条边 for(int i = 0; i &lt; m; i++) &#123; Edge edge = new Edge(); //起点，范围1到n edge.u = input.nextInt(); //终点，范围1到n edge.v = input.nextInt(); //权重 edge.weight = input.nextInt(); edges[i] = edge; &#125; System.out.println(); // 对数组进行排序 Arrays.sort(edges, new Comparator&lt;Edge&gt;() &#123; @Override public int compare(Edge e1, Edge e2) &#123; // 返回值为int类型，大于0表示正序，小于0表示逆序 return e1.weight - e2.weight; &#125; &#125;); kruskal(n, edges); &#125; /** * kruskal算法求解最小生成树 * * @param n 顶点的个数 * @param edges 存储边信息的集合 */ public static void kruskal(int n, Edge[] edges) &#123; DSU dsu = new DSU(n); // 最小生成树的总权值 int totalWeight = 0; // 已加入边的数量，比顶点的数量小1. int m = 0; for(Edge e : edges) &#123; if(m == (n - 1)) &#123; break; &#125; int u = e.u; int v = e.v; int w = e.weight; // 两个节点不属于一个连通分量 if(dsu.findRoot(u) != dsu.findRoot(v)) &#123; totalWeight += e.weight; dsu.union(u, v, w); m++; &#125; &#125; System.out.println("总权值为：" + totalWeight); &#125;&#125;/** * 存储边信息的类 */class Edge &#123; public int u, v; public int weight;&#125;/** * 并查集(Disjoint Set Union)类 */class DSU &#123; /** * 记录每个节点根节点的数组 */ int[] root; /** * 记录图的连通分量 */ int[] size; /** * 构造函数 * * @param n 图的顶点的数量 */ public DSU(int n) &#123; /** * 存储每个节点的根节点 */ root = new int[n + 1]; /** * 存储图的每个连通分量的尺寸 */ size = new int[n + 1]; // 将图当作森林，每个节点一开始都是一棵树。根节点是其自身 for(int i = 0; i &lt; root.length; i++) &#123; root[i] = i; &#125; // 将图当作森林，每个节点一开始都是一棵树，尺寸为 1 Arrays.fill(size, 1); &#125; /** * 寻找目标节点的根节点 * * @param x 目标节点 */ public int findRoot(int x) &#123; // 如果节点有根节点，即该节点已经加入了其它树中 if(root[x] != x) &#123; // 路径压缩，即只存储了根节点的信息，并未存储父节点的信息 root[x] = findRoot(root[x]); &#125; return root[x]; &#125; /** * 合并两棵树 * * @param x 待合并的树1 * @param y 待合并的树2 * @param w 边的权值 */ public void union(int x, int y, int w) &#123; int rootX = findRoot(x); int rootY = findRoot(y); // x 和 y 的根节点相同，即两者处于同一棵树中，联通分量相同 if(rootX == rootY) &#123; return; &#125; // 如果 rootX 代表的树数量小于 rootY 所代表的树，那么就将 // rootX 的树并到 rootY 的那棵树 if(size[rootX] &lt; size[rootY]) &#123; root[rootX] = rootY; size[rootY]++; &#125; else &#123; root[rootY] = rootX; size[rootX]++; &#125; System.out.println("加入边 (" + x + ", " + y + ")，其权值为：" + w); &#125;&#125; ¶运行结果 ¶总结 对比一下 Dijkstra 算法、Prim 算法、Kruskal 算法，发现三者有着很多相似之处，也有着不同之处。三者的区别其实主要体现在思想上： Dijkstra 算法，又叫单源最短路径算法，其目的是找出从一个点到其它点的最短路径，是一对多的关系；而 Prim 算法，是寻找最小生成树，对于无向图，其最小生成树可以有多个。如图 1，因为没有方向性，树的根节点可以是 A - G 的任意一个节点。并且构造最小生成树的时候，也不拘泥于单点，而是基于观测域中的所有点构造，故 Prim 算法是多对多的关系。 Prim 算法与 Kruskal 算法都能得到连通图的最小生成树，二者的主要区别在于前者是从顶点的角度出发构造最小生成树，而后者是基于边构造最小生成树；并且前者的贪心性质主要是局部贪心，是在观测域范围内找最小的边，而后者就是整体贪心，是在整个图中寻找最短的边。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法-单源最短路径]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%8D%95%E6%BA%90%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[算法思想：贪心算法 实际问题：单源最短路径 编程语言：Java ¶问题描述 单源最短路径算法，又称迪杰斯特拉算法。其目的是寻找从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。 ¶算法构造 相关解释 观测域：假设起点为v点，观测域便为v点的四周，即v的所有邻接点； 点集 V：图中所有点的集合； 点集 S：已经找到最短路径的终点集合； 数组 D：存储观测域内能观测到的最短路径，算上起点一共 n 个数值。比如 D[k] 对应在观测域中能观测到的，到顶点 k 的最短路径； 邻接矩阵 a：存储着有权图中的边的信息，是一个二维数组。比如 a[1][2] = 5 表示在有权图中，点 1 和点 2 之间有边，且边的权值为 5。如果两点之间没边，则用负数或则无穷大(∞)表示。 算法步骤 第一步：初始化点集 S，将起点 v 收入 S 中。初始化数组 D：D[k] = a[v][k]； 第二步：找寻次短路径。即查找数组 D，找出观测域中最短路径(v, j)：D[j] = min(D[k] | k 不属于 S)。将点 j 加入点集 S 中； 第三步：将 j 的邻接点并入观测域，即用 j 的邻接点更新数组 D； 第四步：不断重复第二步和第三步，直到节点全部压入 S 中为止。 注：贪心算法的思想主要就体现在第二步和第三步之中。 ¶Java 代码 本代码求解的是无向有权图的最短路径，如果想求有向有权图的最短路径，则只需要将无向图的邻接矩阵改为有向图的邻接矩阵即可。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142import java.util.Scanner;public class SSSP&#123; public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); System.out.print("请输入图的顶点和边的个数(格式：顶点个数 边个数)："); int n = input.nextInt(); //顶点的个数 int m = input.nextInt(); //边的个数 System.out.println(); int[][] a = new int[n + 1][n + 1]; //初始化邻接矩阵 for(int i = 0; i &lt; a.length; i++) &#123; for(int j = 0; j &lt; a.length; j++) &#123; a[i][j] = -1; //初始化没有边 &#125; &#125; System.out.println("请输入图的路径长度(格式：起点 终点 长度)："); //总共m条边 for(int i = 0; i &lt; m; i++) &#123; //起点，范围1到n int s = input.nextInt(); //终点，范围1到n int e = input.nextInt(); //长度 int l = input.nextInt(); if(s &gt;= 1 &amp;&amp; s &lt;= n &amp;&amp; e &gt;= 1 &amp;&amp; e &lt;= n) &#123; //无向有权图 a[s][e] = l; a[e][s] = l; &#125; &#125; System.out.println(); //距离数组 int[] dist = new int[n+1]; //前驱节点数组 int[] prev = new int[n+1]; int v =1 ;//顶点，从1开始 dijkstra(v, a, dist, prev); &#125; /** * 单源最短路径算法(迪杰斯特拉算法) * @param v 顶点 * @param a 邻接矩阵表示图 * @param dist 从顶点v到每个点的距离 * @param prev 前驱节点数组 */ public static void dijkstra(int v, int[][] a, int[] dist, int[] prev) &#123; int n = dist.length; /** * 顶点从1开始，到n结束，一共n个结点 */ if(v &gt; 0 &amp;&amp; v &lt;= n) &#123; //顶点是否放入的标志 boolean[] s = new boolean[n]; //初始化 for(int i = 1; i &lt; n; i++) &#123; //初始化为 v 到 i 的距离 dist[i] = a[v][i]; //初始化顶点未放入 s[i] = false; //v到i无路，i的前驱节点置空 if(dist[i] == -1) &#123; prev[i] = 0; &#125; else &#123; prev[i] = v; &#125; &#125; //v到v的距离是0 dist[v] = 0; //顶点放入 s[v] = true; //共扫描n-2次，v到v自己不用扫 for(int i = 1; i &lt; n - 1; i++) &#123; int temp = Integer.MAX_VALUE; //u为下一个被放入的节点 int u = v; //这个for循环为第二步，观测域为v的观测域 //遍历所有顶点找到下一个距离最短的点 for(int j = 1; j &lt; n; j++) &#123; //j未放入，且v到j有路，且v到当前节点路径更小 if(!s[j] &amp;&amp; dist[j] != -1 &amp;&amp; dist[j] &lt; temp) &#123; u = j; //temp始终为最小的路径长度 temp = dist[j]; &#125; &#125; //将得到的下一节点放入 s[u] = true; //这个for循环为第三步，用u更新观测域 for(int k = 1; k &lt; n; k++) &#123; if(!s[k] &amp;&amp; a[u][k] != -1) &#123; int newdist=dist[u] + a[u][k]; if(newdist &lt; dist[k] || dist[k] == -1) &#123; dist[k] = newdist; prev[k] = u; &#125; &#125; &#125; &#125; &#125; for(int i = 2; i &lt; n; i++) &#123; System.out.println(i + "节点的最短距离是：" + dist[i] + "；前驱点是：" + prev[i]); &#125; &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法-活动安排问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E6%B4%BB%E5%8A%A8%E5%AE%89%E6%8E%92%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[算法思想：贪心算法 实际问题：活动安排问题 编写语言：Java ¶问题描述 设有n个活动的集合 E = {1,2,…,n}，其中每个活动都要求使用同一资源，如演讲会场等，而在同一时间内只有一个活动能使用这一资源。每个活动 i 都有一个要求使用该资源的起始时间 si 和一个结束时间 fi，且 si &lt; fi。如果选择了活动 i，则它在半开时间区间 [si, fi) 内占用资源。若区间 [si, fi) 与区间 [sj, fj) 不相交,则称活动 i 与活动 j 是相容的。也就是说，当 si ≥ fj 或 sj ≥ fi 时，活动 i 与活动 j 相容。活动安排问题就是要在所给的活动集合中选出最大的相容活动子集合。 将活动按照结束时间进行从小到大排序。然后用 i 代表第 i 个活动，s[i] 代表第 i 个活动开始时间，f[i] 代表第 i 个活动的结束时间。挑选出结束时间尽量早的活动（活动结束时间最早的活动），并且满足后一个活动的起始时间晚于前一个活动的结束时间，全部找出这些活动就是最大的相容活动子集合。即有活动 i，j 为 i 的下一个活动。f[i]最小，s[j] &gt;= f[i]。 ¶想法证明 上述思路的第一步是在最大相容活动子集合中加入最早结束的活动（以下称第一个活动）。实际上，总存在一个最优安排，其包含第一个活动。 证明如下： 设 E =｛0，1，2，…，n-1｝为所给的活动集合。由于 E 中活动安排安结束时间的非减序排列，所以活动 1 具有最早完成时间。首先证明活动安排问题有一个最优解以贪心选择开始（选择了活动 1）。设 A 是所给的活动安排问题的一个最优解，且 B 中活动也按结束时间非减序排列，A 中的第一个活动是活动 k。若 k = 1，则 A 就是一个以贪心选择开始的最优解。若 k &gt; 1，则我们设 B = A -｛k｝∪｛1｝。由于 end[1] ≤ end[k]（非减序排列），且 A 中活动是互为相容的，故 B 中的活动也是互为相容的。又由于 B 中的活动个数与 A 中活动个数相同，且 A 是最优的，故 B 也是最优的。也就是说 B 是一个以贪心选择活动 1 开始的最优活动安排。因此，证明了总存在一个以贪心选择开始的最优活动安排方案，也就是算法具有贪心选择性质。 ¶Java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;public class ActivityArrangement &#123; public static void main(String[] args) &#123; ArrayList&lt;Time&gt; list = new ArrayList&lt;&gt;(); list.add(new Time(3, 5)); list.add(new Time(1, 4)); list.add(new Time(5, 7)); list.add(new Time(0, 6)); list.add(new Time(6, 10)); list.add(new Time(3, 8)); list.add(new Time(5, 9)); list.add(new Time(8, 12)); list.add(new Time(8, 11)); list.add(new Time(2, 13)); list.add(new Time(12, 14)); //将数组按照结束时间排序 Collections.sort(list, new Comparator&lt;Time&gt;()&#123; @Override public int compare(Time t1, Time t2) &#123; return t1.end - t2.end; &#125; &#125;); //选出局部最优解，返回结果数组 boolean[] r = greedySelector(list); System.out.print("被安排上的活动为："); for(int i = 0; i &lt; list.size(); i++) &#123; if(r[i] == true) System.out.print("[" + list.get(i).start + ", " + list.get(i).end + "] "); &#125; System.out.println(); &#125; /** * 利用贪心性质选出活动安排的最优解 * @param list 存储活动的列表 * @return r 最终返回的结果数组 */ public static boolean[] greedySelector(ArrayList&lt;Time&gt; list) &#123; int n = list.size(); //存储结果的数组 boolean[] r = new boolean[n]; //将第一个活动放入活动表中 r[0] = true; //记录最近一次加入到r中的活动 int j = 0; //依次检查活动i是否与当前已选择的活动相容 for(int i = 1; i &lt; n; i++) &#123; if(list.get(i).start &gt;= list.get(j).end) &#123; r[i] = true; j = i; &#125; else r[i] = false; &#125; return r; &#125;&#125;class Time &#123; public int start; public int end; public Time(int start, int end) &#123; this.start = start; this.end = end; &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法-哈夫曼编码]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[算法思想：贪心算法 实际问题：活动安排问题 编写语言：Java ¶问题描述 哈夫曼编码(Huffman Coding)：又称霍夫曼编码，是由 Huffman 于1952年提出一种编码方法，是可变字长编码的一种。哈夫曼编码完全依据字符出现概率来构造异字头的平均长度最短的码字，有时被称为最佳编码，一般就叫做 Huffman 编码。通俗的讲，哈夫曼编码就是出现得越多的内容编码越短 ，出现频率越少的内容编码越长。 哈夫曼树(Huffman Tree)：给定作为 n 个叶子结点，其各带 1 个权值（共 n 个），构造一棵二叉树，若该树的带权路径长度达到最小，则称这样的二叉树为最优二叉树，也称为哈夫曼树。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。哈夫曼树的构造方式为自底向上构造，即先构造叶子节点，在构造父节点，最后构造根节点。 ¶算法构造 对待编码的内容按照权值大小从小到大排序。 从已排序的内容列表中选取两个权值最小的内容。组成子节点。并将两者的权值想加，构成新的节点，但此节点无内容。 重复 1-2 步，有内容的组成叶子节点，无内容的不构成叶子节点。 对于最终构成的哈夫曼树，根节点不算入编码，左节点编码为 0，右节点编码为 1。 哈夫曼编码的解码过程是按照哈夫曼树遍历，完成一个内容解码就重新遍历哈夫曼树。 ¶Java 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import java.util.Scanner;import java.util.LinkedList;import java.util.Collections;public class HuffmanCode &#123; /** * 存放节点的容器 */ private static LinkedList&lt;HuffmanNode&gt; huffmanList = new LinkedList&lt;&gt;(); public static void main(String[] args) &#123; Scanner input = new Scanner(System.in); //待编码元素个数 System.out.print("请输入待编码的节点个数："); int n = input.nextInt(); System.out.println("请输入节点的内容及其频数："); for(int i = 0; i &lt; n; i++) &#123; String s = input.next(); int v = input.nextInt(); huffmanList.add(new HuffmanNode(v, s)); &#125; huffCode(); decode(huffmanList.get(0), ""); &#125; /** * 哈夫曼编码 */ public static void huffCode() &#123; if(huffmanList.size() == 1) &#123; return; &#125; while(huffmanList.size() &gt; 1) &#123; /** * 贪心算法核心，排序后每次取最小的两个数 * 每取两个数之后就得重新排序，直到只剩下一个元素 */ Collections.sort(huffmanList); /** * 这一步中隐含着一个规则，较小的为左子树，较大的为右子树。 * 手画哈夫曼树时注意一下，构造的树和最后输出的结果就完全一致了。 */ HuffmanNode node = new HuffmanNode(huffmanList.get(0), huffmanList.get(1)); //去掉两个子节点，加入父节点。 //子节点虽然不在列表中，但并为被回收，因为在父节点中有引用 huffmanList.remove(); huffmanList.remove(); huffmanList.add(node); &#125; &#125; /** * 解码算法 * 打印顺序是从左到右打印哈夫曼树中的叶子节点 */ public static void decode(HuffmanNode h, String code) &#123; //如果是叶子节点，就输出，只有叶子节点中存储着文本内容，父节点中没有 if(h.lChild == null &amp;&amp; h.rChild == null) &#123; System.out.println("元素 " + h.name + "的编码为：" + code); return; &#125; //如果是父节点，就遍历左右子树(编码遵循左0右1)，直到搜寻到叶子节点 //根据哈夫曼树的构造方式，父节点一定同时有左右子树，无须增加if判断 decode(h.lChild, code + "0"); decode(h.rChild, code + "1"); &#125;&#125;/** * 哈夫曼节点 */class HuffmanNode implements Comparable&lt;HuffmanNode&gt; &#123; int value; String name; HuffmanNode lChild = null; HuffmanNode rChild = null; public HuffmanNode() &#123; &#125; public HuffmanNode(int v,String s) &#123; value = v; name = s; &#125; /** * 这里是浅复制，lChild和l都指向一个内存区域， * rChild和r都指向同一个内存区域 */ public HuffmanNode(HuffmanNode l,HuffmanNode r) &#123; lChild = l; rChild = r; value = lChild.value + rChild.value; &#125; @Override public int compareTo(HuffmanNode node1) &#123; if (value&lt;node1.value) &#123; return -1; &#125; else if (value == node1.value) &#123; return 0; &#125; else &#123; return 1; &#125; &#125;&#125; ¶结果示例]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贪心算法-一般背包问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95-%E4%B8%80%E8%88%AC%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[算法思想：贪心算法 实际问题：一般背包问题 编写语言：Java ¶问题描述 给定n种物品和一个背包，物品i的重量是wi，其价值是vi，背包的容量为C，问应该如何选择装入背包的物品，使得装入背包中物品的总价值最大。物品可以不装入，可以全部装入，也可以部分装入。 思路：首先计算每种物品单位重量的价值 valPer = vi / wi，然后依据贪心选择策略，将 valPer 尽量大的物品装入背包。直到背包装满为止。 ¶Java 代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import java.util.ArrayList;import java.util.Comparator;import java.util.Collections;public class Knapsack &#123; public static void main(String[] args) &#123; //存储物品的列表 ArrayList&lt;Goods&gt; list = new ArrayList&lt;&gt;(); list.add(new Goods(1, 10, 35)); list.add(new Goods(2, 40, 30)); list.add(new Goods(3, 30, 60)); list.add(new Goods(4, 50, 50)); list.add(new Goods(5, 35, 40)); list.add(new Goods(6, 40, 10)); list.add(new Goods(7, 30, 25)); //背包容量 int c = 150; double[] r = select(c, list); System.out.print("第一个数代表最大价值，后续数代表装入背包的物品，" + "最后一个物品为部分装入，其它物品为全部装入："); for(int i = 0; i &lt; r.length; i++) &#123; System.out.print(r[i] + " "); &#125; System.out.println(); &#125; /** * 根据贪心策略算出最优解 * @param c 背包的容量 * @param list 存储物品的列表 * @return r 最终求得的结果数组，第一位为最大价值，最后一位为部分装入的 * 物品序号 */ public static double[] select(int c, ArrayList&lt;Goods&gt; list) &#123; //对list按照单位重量的价值排序 Collections.sort(list, new Comparator&lt;Goods&gt;() &#123; @Override public int compare(Goods g1, Goods g2) &#123; if(g2.v / g2.w - g1.v / g1.w &gt; 0) return 1; else if(g2.v / g2.w - g1.v / g1.w &lt; 0) return -1; else return 0; &#125; &#125;); for(int j = 0; j &lt; list.size(); j++) System.out.print(list.get(j).id + " "); System.out.println(); double[] r = new double[list.size() + 1]; //初始化最大价值 r[0] = 0; //物品值等于-1表示未放入物品 for(int j = 1; j &lt; r.length; j++) r[j] = -1; int i; for(i = 0; i &lt; list.size(); i++) &#123; if(list.get(i).w &gt; c) break; r[i + 1] = list.get(i).id; r[0] += list.get(i).v; c -= list.get(i).w; &#125; //将最后一件物品加入背包中(最后一件物品不能全部加入，因为它的重量已经比 //背包的剩余容量大了) r[i + 1] = list.get(i).id; r[0] += c * (list.get(i).v / list.get(i).w); return r; &#125;&#125;class Goods &#123; //物品id public int id; //物品价值 public double v; //物品重量 public int w; public Goods(int id, int v, int w) &#123; this.id = id; this.v = v; this.w = w; &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-最优二叉搜索树]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%2F</url>
    <content type="text"><![CDATA[算法思想：动态规划 实际问题：最优二叉搜索树 编写语言：Java ¶问题描述 二叉搜索树的定义： 满足以下任意两个条件的一个，就可称这棵树为二叉搜索树： 它是一棵空树 该树是一颗二叉树，非空，且满足下列两个条件： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值 即当该二叉树非空时，使用中序遍历可以得到一个递增的有序序列 值得注意的是： 二叉搜索树的左右子树也是二叉搜索树，我们因此可以使用递归手段来构造二叉搜索树 一个有序序列的二叉搜索树不只一棵，这就为我们寻找最优二叉搜索树提供了可能 最优二叉搜索树指的是在一个序列的所有二叉搜索树中花费代价最小的那棵。 ¶递归结构 用C[i , j]表示从 i 到 j 的最优二叉查找树的代价，假设有n个顶点，那么我们的目标是要求C[1 , n]从 i 到 j 的一个最优二叉查找树是怎么得到的？它是从 i 到 j 之间的顶点中选出一个顶点来做root，假设选出的这个做root的顶点是 k （i &lt;= k &lt;= j）, 那么显然有： C[i , j] = min(C[i, k - 1] + C[k + 1, j]) + Sum(pi, pj)，其中：1 &lt;= i &lt;= j &lt;= n，i &lt;= k &lt;= j，pi表示遍历第i个结点的代价，Sum(pi, pj)表示求第i个结点到第j个结点的代价总和 上述求和公式最后为什么还要加一个求和结果呢？因为可以理解为公式前半部分只是找出最短路径，最后求和才是加上权重(网上有更详细更严谨的推导过程，可自行百度) ¶Java代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class OptBST&#123; public static void main(String[] args) &#123; double[] p = new double[]&#123;0.1, 0.15, 0.2, 0.35, 0.2&#125;; Result r = getOptBST(p); for(int i = 0; i &lt; r.result.length; i++) &#123; for(int j = 0; j &lt; r.result.length; j++) System.out.print(r.root[i][j] + " "); System.out.println(); &#125; &#125; /** * 构造最优二叉搜索树的方法 * param p: 中序序列的点的查找概率数组，返回最优的二叉查找树的代价 */ public static Result getOptBST(double[] p) &#123; int n = p.length; //序列长度 Result r = new Result(n); for(int i = 0; i &lt; n; i++) &#123; //从i到i的最小代价(找到的概率)就是找到i的代价(概率) r.result[i][i] = p[i]; r.root[i][i] = i; //只有一个结点时，最优二叉搜索树就是它本身 &#125; for(int m = 1; m &lt; n; m++) //m代表二叉树的长度(所有结点的个数) &#123; for(int i = 0; i &lt; n - m; i++) //i为二叉树左起点 &#123; int j = i + m; //j为二叉树的右终点 double min = 1000000; //该变量存储最小代价 int tr = 0; //tr: temp root，临时变量，表示根节点 //求取最小值并记录根所在位置 for(int k = i; k &lt;= j; k++) &#123; //用r1表示result[i,k-1]，r2表示result[k+1,j] double r1 = 0, r2 = 0; if(i &lt; k) r1 = r.result[i][k - 1]; if(k &lt; j) r2 = r.result[k + 1][j]; if(min &gt; r1 + r2) &#123; min = r1 + r2; tr = k; &#125; &#125; r.root[i][j] = tr; double sum = 0; for(int s = i; s &lt;= j; s++) sum += p[s]; r.result[i][j] = min + sum; //递推公式体现在这里 &#125; &#125; return r; &#125;&#125;class Result //存储结果的类&#123; public double[][] result; //存储代价 public int[][] root; //存储构造路径 public Result(int n) &#123; result = new double[n][n]; root = new int[n][n]; &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-最长公共子序列]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[算法思想：动态规划 实际问题：最长公共子序列 编写语言：Java ¶问题描述 子序列：是一个给定序列的子序列是在该序列中删去若干元素后得到的序列。如X={A, B, C, D}, {A, C}是X的子序列，{A, B, D}是X的子序列。 问题描述：给定两个序列X和Y，当另一序列Z既是X的子序列又是Y的子序列时，称Z是序列X和Y的公共子序列，X和Y的所有公共子序列中长度最长的即是X和Y的最长公共子序列。 值得一提的是，最长公共子序列不只一个，但构造的时候只能构造出一个。 ¶关键特征 设序列X={x1, x2, x3, …, xm}和Y={y1, y2, y3, …, yn}的最长公共子序列为Z={z1, z2, z3, …, zk}，则： 若xm=yn, 则zk=xm=yn, 且Zk-1是Xm-1和Yn-1的最长公共子序列 若xm!=yn, 且zk!=xm, 则Z是Xm-1和Y的最长公共子序列 若xm!=yn, 且zk!=yn, 则Z是X和Yn-1的最长公共子序列 其中：Xm-1={x1, x2, …, xm-1}，Yn-1={y1, y2, …, yn-1}，Zk-1={z1, z2, …, zk-1}。 ¶递归结构 用c[i][j]记录序列Xi和Yj的最长公共子序列长度，那么： 当i=0, j=0时，c[i][j]=0 当i&gt;0, j&gt;0, xi=yj时，c[i][j] = c[i-1][j-1]+1 当i&gt;0, j&gt;0,xi!=yj时，c[i][j] = max{c[i][j-1], c[i-1][j]} 其中，第3点是说当xm!=yn时，求取Xm-1, Y和X, Yn-1两者的最长公共子序列的较长者作为整体的最长公共子序列 ¶Java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public class LongestCommonSubsequence&#123; public static void main(String[] args) &#123; //第一个字符留空，可以省去后续很多麻烦 char[] x = new char[]&#123;' ', 'A', 'B', 'C', 'B', 'D', 'A', 'B'&#125;; char[] y = new char[]&#123;' ', 'B', 'D', 'C', 'A', 'B', 'A'&#125;; int m = x.length; int n = y.length; int[][] c = new int[m][n]; int[][] b = new int[m][n]; lcsLength(m - 1, n - 1, x, y, c, b); lcs(m - 1, n - 1, x, b); //从m-1，n-1开始往下面找 System.out.println(); &#125; /** * 参数含义： * m: X序列的长度 * n: Y序列的长度 * x, y: 待求最长公共子序列的原始序列 * c: 记录Xi和Yj的最长公共子序列长度 * b: 记录得到c[i][j]的是哪个子问题 */ public static void lcsLength(int m, int n, char[] x, char[] y, int[][] c, int[][] b) &#123; for(int i = 0; i &lt; m; i++) c[i][0] = 0; for(int i = 0; i &lt; n; i++) c[0][i] = 0; for(int i = 1; i &lt;= m; i++) &#123; for(int j = 1; j &lt;= n; j++) &#123; if(x[i] == y[j]) &#123; c[i][j] = c[i - 1][j - 1] + 1; b[i][j] = 1; &#125; else if(c[i-1][j] &gt; c[i][j - 1]) &#123; c[i][j] = c[i - 1][j]; b[i][j] = 2; &#125; else &#123; c[i][j] = c[i][j - 1]; b[i][j] = 3; &#125; &#125; &#125; &#125; /** * 该方法构造一个X，Y的最长公共子序列 * 参数含义： * i, j: 序列X, Y的下标 * x: 原始序列，因为构造的是X, Y的最长公共子序列。 * 此处用Y也行，因为x有的y也有。 * 但是序列应全程保持一致(一开始用X，整个函数都用X) * b: 用于构造子序列的二维数组 */ public static void lcs(int i, int j, char[] x, int[][] b) &#123; if(i == 0 || j == 0) return; if(b[i][j] == 1) &#123; lcs(i - 1, j - 1, x, b); System.out.print(x[i] + " "); &#125; else if(b[i][j] == 2) lcs(i - 1, j, x, b); else lcs(i, j - 1, x, b); &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-01背包问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[算法思想：动态规划 实际问题：01背包问题 编写语言：Java ¶问题描述 给定n种物品和一个背包，物品i的重量为wi，其价值是vi，背包的容量为c，问应如何向背包装入物品，使得背包中的物品价值最大。每个物品拿取或者不拿两种选择。不能选择装入某物品的一部分，也不能装入同一物品多次。 ¶递归结构 声明一个大小为m[n][c]的二维数组，m[i][j]表示在面对第i件物品，且背包容量为j时所能获得的最大价值。则： m[i][j]=m[i-1][j]，j&lt;w[i]。其表示：背包容量不足以放下第i件物品，只能选择不拿。 m[i][j]=max{m[i-1][j], m[i-1][j-wi]+vi}，j&gt;=w[i]。其表示：这时背包容量可以放下第i件物品，我们就要考虑拿这件物品是否能获取更大的价值。前者表示不装第i件物品的最大价值，后者表示装了第i件物品的最大价值，并为第i件物品预留了wi的容量。 ¶Java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102public class OneZeroKnapsackProblem&#123; public static void main(String[] args) &#123; //以下数组第0位(第0行，第0列)都不存储数据 int[] v = new int[]&#123;0, 8, 10, 6, 3, 7, 2&#125;; //每件物品的价值 int[] w = new int[]&#123;0, 4, 6, 2, 2, 5, 1&#125;; //每件物品的重量 int c = 12; //背包的容量 int n = v.length - 1; //物品的数量 int[][] m = new int[n + 1][c + 1]; //总价值数组 int[] r = new int[n + 1]; //构造最优解的数组 for(int i = 0; i &lt;= n; i++) &#123; for(int j = 0; j &lt;= c; j++) m[i][j] = 0; r[i] = 0; &#125; knapsack(v, w, c, n, m); traceback(m, w, c, n, r); System.out.println("物品数量为 " + n + " ，背包容量为 " + c); System.out.print("各个物品的价值为："); for(int i = 1; i &lt;= n; i++) &#123; System.out.print(v[i] + " "); &#125; System.out.println(); System.out.print("各个物品的重量为："); for(int i = 1; i &lt;= n; i++) &#123; System.out.print(w[i] + " "); &#125; System.out.println(); System.out.println("最多价值为：" + m[n][c]); System.out.print("放入的物品为："); for(int i = 1; i &lt;= n; i++) System.out.print(r[i] + " "); System.out.println(); &#125; /** * 该方法计算最优解： * @param v 存储每个物品的价值 * @param w 存储每个物品的重量 * @param c 存储背包容量 * @param n 物品数量 * @param m 存储构造的最优解 */ public static void knapsack(int[] v, int[] w, int c, int n, int[][] m) &#123; //物品从第1件物品开始计算 for(int i = 1; i &lt;= n; i++) &#123; for(int j = 1; j &lt;= c; j++) &#123; if(j &gt;= w[i]) &#123; m[i][j] = max(m[i - 1][j], m[i - 1][j - w[i]] + v[i]); &#125; else &#123; m[i][j] = m[i - 1][j]; &#125; &#125; &#125; &#125; /** * 该方法构造最优解的生成过程： * @param m 存储最优解的数组 * @param w 存储每个物品的重量 * @param c 存储背包容量 * @param n 物品数量 * @param x 存储最优解生成过程的数组 */ public static void traceback(int[][] m, int[] w, int c, int n, int[] x) &#123; for(int i = 1; i &lt;= n; i++) &#123; if(m[i][c] == m[i - 1][c]) //第i件物品为未放入 &#123; x[i] = 0; &#125; else //第i件放入 &#123; x[i] = 1; c -= w[i]; &#125; &#125; &#125; public static int max(int a, int b) &#123; return a &gt; b ? a : b; &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-多边形游戏]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%A4%9A%E8%BE%B9%E5%BD%A2%E6%B8%B8%E6%88%8F%2F</url>
    <content type="text"><![CDATA[算法思想：动态规划 实际问题：多边形游戏 编写语言：Java ¶前言 多边形游戏问题是矩阵连乘的最优计算次序问题与凸多边形最优三角剖分问题的推广。我在解决凸多边形最优三角剖分问题时偶然间看到了这个结论，便跳过了该问题，直接解决其推广的问题，即多边形游戏问题。对于凸多边形最优三角剖分问题有兴趣的读者，可以自行百度。 ¶问题描述 有一个由n个顶点构成的多边形。每个顶点被赋予一个整数值，每条边被赋予一个运算符。每条边被赋予一个运算符+或*。所有边依次用整数1到n编号。 游戏规则： 删去一条边 后续步骤按以下方式操作： 选择一条边E及边E的两个顶点v1和v2 用一个新的顶点v取代边E及由E连接着的2个顶点，将2个顶点上的数值由E上的运算符获得结果，病赋值给新的顶点v。最后，所有的边都被删除，游戏结束，得到游戏分数(最后顶点上的整数值) 问题：对于给定的多边形，计算最高得分 ¶关键特征 设给定的多边形的顶点和边的顺时针序列为 op[1], v[1], op[2], v[2], …, op[n], v[n]。其中 op[i] 表示第 i 边所对应的运算符，v[i] 表示第 i 个顶点上的数值，1 &lt;= i &lt;= n。 在所给定的多边形中，从顶点 i 开始，长度为 j(链中有 j 个顶点) 的顺时针链 p(i, j) 可表示为 v[i], op[i + 1], …, v[i + j - 1]。如果这条链的最后一次合并运算发生在 op[i + s] 处，则可在 op[i + s] 处将链分为两个子链 p(i, s) 和 p(i + s, j - s)。 设 m1 是子链 p(i, s) 内部合并得到的值，设 a 和 b 是子链 p(i, s) 内部合并可能得到的最小值和最大值；设 m2 是子链 p(i + s, j - s) 内部合并得到的值，设 c 和 d 是子链 p(i + s, j - s) 内部合并可能得到的最小值和最大值。则有：a &lt;= m1 &lt;= b, c &lt;= m2 &lt;= d。而两个子链合并得到的结果 m = (m1)opi + s。分析运算符的情况可得： 当op[i + s] = '+'时，显然有 a + c &lt;= m &lt;= b + d。即链 p(i, j) 合并的最优性可由子链 p(i, s) 和 p(i + s, j - s) 的最优性推出。且最大值对应子链的最大值，最小值对应子链的最小值。 当op[i + s] = '*'时，考虑到 v[i] 可以取负整数，显然有 min{ac, ad, bc, bd} &lt;= m &lt;= max{ac, ad, bc, bd}，亦可由子链的最有性推出原链的最优性。 综上，可得多边形游戏问题满足最优子结构性质 ¶递归结构 设 m[i, j, 0] 是链 p(i, j) 合并的最小值，m[i, j, 1] 是链 p(i, j) 合并的最大值，并设最优合并在 op[i+s] 处，为方便起见，记：a=m[i, i+s, 0], b=m[i, i+s, 1], c=m[i+s, j-s, 0], d=[i+s, j-s, 1]，则关系式满足： 当 op[i+s]=’+’, min(i, j, s) = a+c, max(i, j, s) = b+d 当 op[i+s]=’*’, min(i, j, s) = min(ac, ad, bc, bd), max(i, j, s) = max(ac, ad, bc, bd) 由此可知 m[i, j, 0]=min(min(i, j, s)), m[i, j, 1]=max(max(i, j, s))，其中 1 &lt;= s &lt;= j - 1，这是个循环求值的过程。 ¶Java代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//本代码所用示例为：+ -7 + 4 * 2 * 5public class PolygonGame&#123; static int n; //边和点个数 static int minf, maxf; static int[] v; //点集 static char[] op; //边集 static int[][][] m; //存储最终计算结果 public static void main(String[] args) &#123; n = 4; //以下所有数组下标为0的都不使用 //构造出的多边形的最终结果：+ -7 + 4 * 2 * 5 v = new int[]&#123;Integer.MIN_VALUE, -7, 4, 2, 5&#125;; op = new char[] &#123;' ', '+', '+', '*', '*'&#125;; m = new int[n + 1][n + 1][2]; for(int i = 1; i &lt;= n; i++) &#123; //m[i][j][0]：表示链的起点为i，长度为j时的结果最小值 m[i][1][0] = v[i]; //m[i][j][1]：表示链的起点为i，长度为j时的结果最大值 m[i][1][1] = v[i]; &#125; int result = polyMax(); System.out.println(result); &#125; /** * 参数含义： * i：链的起点 * s：断开位置 * j：链长度 * */ public static void minMax(int i,int s,int j) &#123; int[] e = new int[n + 1]; int a = m[i][s][0], b = m[i][s][1], r = (i + s - 1) % n + 1, //多边形是封闭的，不能出现下标溢出 c = m[r][j - s][0], d = m[r][j - s][1]; if(op[r] == '+') &#123; minf = a + c; maxf = b + d; &#125; else &#123; e[1] = a * c; e[2] = a * d; e[3] = b * c; e[4] = b * d; minf = e[1]; maxf = e[1]; for(int k = 2; k &lt; 5; k++) &#123; if(minf &gt; e[k]) minf = e[k]; if(maxf &lt; e[k]) maxf = e[k]; &#125; &#125; &#125; public static int polyMax() &#123; for(int j = 2; j &lt;= n; j++) //链的长度 //链的起点，多边形是封闭的，不会存在什么问题 for(int i = 1; i &lt;= n; i++) for(int s = 1; s &lt; j; s++) //断开的位置 &#123; minMax(i, s, j); if(m[i][j][0] &gt; minf) m[i][j][0] = minf; if(m[i][j][1] &lt; maxf) m[i][j][1] = maxf; &#125; int temp = m[1][n][1]; for(int i = 1; i &lt;= n; i++) if(temp &lt; m[i][n][1]) &#123; temp = m[i][n][1]; &#125; return temp; &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-最大子段和]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%2F</url>
    <content type="text"><![CDATA[算法思想：动态规划 实际问题：最大子段和 编写语言：Java ¶前言 最大子段和有多种解法，暴力破解法是最简单的，但时间复杂度较高，最少需要 O(n^2)，未改进的算法为 O(n^3)；而且暴力破解这种思路对学习算法是没有帮助的。因此个人并未实现。仅对分治法和动态规划两种思路进行了实现。分治法的解决思路详见**分治法-最大子段和**，分治法解决最大子段和问题需要的时间复杂度为 O(nlogn)，而本篇博文是采用动态规划的思路，动态规划解决最大子段和问题需要的时间复杂度为 O(n)。是最好的一种解决办法。 ¶问题描述 给定n个整数（可能为负数）组成的序列 a[1],a[2],a[3],…,a[n], 求该序列如 a[i]+a[i+1]+…+a[j] 的子段和的最大值。当所给的整数均为负数时定义子段和为0，依此定义，所求的最优值为： Max{0,a[i]+a[i+1]+…+a[j]}, 1&lt;=i&lt;=j&lt;=n 例如，当（a[1],a[2],a[3],a[4],a[5],a[6]）=(-2,11,-4,13,-5,-2) 时，最大子段和为20。 ¶递归结构 设 b[j] 存储的是 A[i:j] 的最大字段和，其中 1 &lt;= i &lt;= j，再定义一个 sum 存储最终结果，那么： 当 b[j - 1] &lt;= 0，b[j] = a[j]，即当目前子序列 A[i:j - 1] 的和为负数时，给和不停的赋新值，直到和为正。 当 b[j - 1] &gt; 0，b[j] = b[j - 1] + a[j]，即当目前子序列 A[i:j - 1] 的和为正时，加上子序列中的下一个数，得到一个新的和 b[j]。 将 b[j] 和 sum 比较，若 b[j] &gt; sum，那么给 sum 赋新值 b[j]；若 b[j] &lt; sum，俺么保持 sum 值不变。通过这种方式来保持 sum 为子序列的最大值。 ¶Java代码 12345678910111213141516171819202122232425public class MaxSubsequenceSum&#123; public static void main(String[] args) &#123; int[] a = new int[]&#123;-2, 11, -4, 13, -5, -2&#125;; int result = maxSubSum(a); System.out.println("maxSubSum(a) = " + result); &#125; public static int maxSubSum(int[] a) &#123; int sum = 0, b = 0; for(int i = 0; i &lt; a.length; i++) &#123; if(b &gt; 0) b += a[i]; //当 b &lt;= 0 时，不断赋新值，相当于跳过了负数 else b = a[i]; if(b &gt; sum) sum = b; &#125; return sum; &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-硬币问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%A1%AC%E5%B8%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[算法思想：动态规划 实际问题：硬币问题 编写语言：Java ¶问题描述 假设有 1 元，3 元，5 元的硬币若干（无限），现在需要凑出 n 元。问如何组合才能使硬币的数量最少？ ¶关键特征 要推出问题的关键特征与递归关系，必要的例子是少不了的。 我们先假设一个函数 d(i) 来表示需要凑出 i 的总价值需要的最少硬币数量，那么： 当 i = 0 时，很显然我们可以知道 d(0) = 0。因为不要凑钱了嘛，当然也不需要任何硬币了。注意这是很重要的一步，其后所有的结果都从这一步延伸开来。 当 i = 1 时，因为我们有 1 元的硬币，所以直接在第 1 步的基础上，加上 1 个 1 元硬币，得出 d(1) = 1。 当 i = 2 时，因为我们并没有 2 元的硬币，所以只能拿 1 元的硬币来凑。在第 2 步的基础上，加上 1 个 1 元硬币，得出 d(2) = 2。 当 i = 3 时，我们可以在第 3 步的基础上加上 1 个 1 元硬币，得到 3 这个结果。但其实我们有 3 元硬币，所以这一步的最优结果不是建立在第 3 步的结果上得来的，而是应该建立在第 1 步上，加上 1 个 3 元硬币，得到 d(3) = 1。 接着就不再举例了，推导过程和上面一样。 ¶递归结构 我们来分析一下上述过程。可以看出，除了第 1 步这个看似基本的公理外，其他往后的结果都是建立在它之前得到的某一步的最优解上，加上 1 个硬币得到。即：d(i) = d(j) + 1，此处 j &lt; i，但是在上述例子中我们发现 i = 3 时，有两个解，但我们选择了第二个解，即：** d(i) = min(d(j) + 1) ** 有了结构，思路就清晰了，代码写起来也就很方便了。 ¶Java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253//以下例子中 n 的数值取 11public class CoinProblem&#123; public static void main(String[] args) &#123; int[] coins = new int[]&#123;1, 3, 5&#125;; //硬币的面值 int money = 11; //待求取的目标数额 int[] result = getLeastCoins(coins, money); System.out.print("硬币的面值为："); for(int i = 0; i &lt; coins.length; i++) &#123; System.out.print(coins[i] + " "); &#125; System.out.println(); for(int i = 0; i &lt; result.length; i++) &#123; System.out.println("要凑齐数额 " + i + " 最少需要 " + result[i] + " 个硬币"); &#125; &#125; /** * param coins 存储硬币面值的数组 * param money 待求取的目标数额 * return result 存储各个数额所需最少硬币的数组 */ public static int[] getLeastCoins(int[] coins, int money) &#123; int[] result = new int[money + 1]; result[0] = 0; //数额0只需0个便可凑齐 for(int i = 1; i &lt; result.length; i++) result[i] = 10000; //初始化时各个数额需要最大上限个硬币 for(int i = 1; i &lt;= money; i++) &#123; for(int coin : coins) &#123; if(coin &lt;= i) &#123; int min = 10000; //存储中间结果的变量，初始化为最大硬币上限 min = result[i - coin] + 1; if(result[i] &gt; min) result[i] = min; &#125; &#125; &#125; return result; &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-矩阵连乘]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98%2F</url>
    <content type="text"><![CDATA[算法思想：动态规划 实际问题：矩阵连乘 编写语言：Java ¶问题描述 给定 n 个矩阵{A1, A2, A3, …, An}，其中Ai 与 Aj 是可乘的，j = i + 1, i = 1, 2, 3, …, n - 1。考察这 n 个矩阵的连乘积所需的最少乘法次数。 举例：数组：A(2, 3), B(3, 5), C(5, 7), 其中A(n, m) 表示 n 行 m 列的矩阵。若按照(A * B) * C 的顺序计算，那么有 2 * 3 * 5 + 2 * 5 * 7 = 30 + 70 = 100 次乘法计算，而如果按照 A * (B * C) 的次序计算，那么有 2 * 3 * 7 + 3 * 5 * 7 = 42 + 105 = 147 次乘法计算，可以看出，两个计算方法的结果是有差异的。那么寻找最少乘法次数(最优解)是确实有必要的。 ¶关键特征 计算 A[1:n] 的最优次序所包含的计算矩阵子链 A[1:k] 和 A[k+1:n] 的次序也是最优的。事实上，若假设 A[1:k] 的计算次序不是最优的，在 A[k+1:n] 的计算次序不变的情况下，总次序会更少，此时就需要替换原次序。A[1:n] 的最优次序 k 的位置不变，只是 A[1:k] 的计算次序变了。综上，原问题包含了其子问题的解，这就是矩阵连乘的最优子结构性质。 ¶递归关系 设计算 A[i:j] 所需的最少乘积次数为m[i][j]，则原问题的最优解为m[1][n]。其中 1 &lt;= i &lt;= j &lt;= n，并且有： 当 i = j 时，A[i:j] = A 为单一矩阵，无须计算，因此 m[i][i] = 0; 当 i &lt; j 时，可利用最优子结构性质来计算m[i][j]，m[i][j] = min{m[i][k] + m[k+1][j] + pi-1 * pk * pj}，其中 i &lt;=k &lt; j，pi-1 * pk * pj 表示左右两个子链相乘，即它们分别表示左行、左列、右列。 另外，将 m[i][j] 的断开位置记为 s[i][j]，方便后续构造相应的最优解 ¶Java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166public class MatrixSuccessiveMultiplication&#123; /** * 全局变量含义： * p：表示矩阵链，其中矩阵 Ai 的维度为 p[i][0] * p[i][1] * m：m[i][j] 存储 A[i:j] 所需的最少乘积次数为m * s：s[i][j] 存储 m[i][j] 的断开位置 k */ private static int[][] p; private static int[][] m; private static int[][] s; public static void main(String[] args) &#123; //matrix[i] 表示第 i 个矩阵 /** * 下面 6 个矩阵：A1: 30 * 35; A2: 35 * 15; A3: 15 * 5 * A4: 5 * 10; A5: 10 * 20; A6 20 * 25 */ p = new int[][] &#123;&#123;30, 35&#125;, &#123;35, 15&#125;, &#123;15, 5&#125;, &#123;5, 10&#125;, &#123;10, 20&#125;, &#123;20, 25&#125; &#125;; int l = p.length; m = new int[l][l]; // 6 = matrix.length s = new int[l][l]; matrixChain(l); /* * 输出 result 和 place 数组查看结果，start 到 end 段代码可以不要 */ //start for(int i = 0; i &lt; l; i++) &#123; for(int j = i; j &lt; l; j++) System.out.print(m[i][j] + " "); System.out.println(); &#125; for(int i = 0; i &lt; l; i++) &#123; for(int j = i; j &lt; l; j++) System.out.print(s[i][j] + " "); System.out.println(); &#125; //end //输出最优解 traceback(0, l - 1); System.out.println("\n" + memoizedMatrixChain(l - 1)); &#125; /** * 参数含义： * p：表示矩阵链，其中矩阵 Ai 的维度为 p[i][0] * p[i][1] * n：表示矩阵链中矩阵的个数 * m：m[i][j] 存储 A[i:j] 所需的最少乘积次数为m * s：s[i][j] 存储 m[i][j] 的断开位置 k */ public static void matrixChain(int n) &#123; //m[i][i] 不需要计算，结果为0 for(int i = 0; i &lt; n; i++) m[i][i] = 0; //mcLength: matrixChainLength: 矩阵链长度，最小为2 for(int mcLength = 2; mcLength &lt;= n; mcLength++) &#123; //l: left为矩阵链左起点 for(int l = 0; l &lt; n - mcLength + 1; l++) &#123; //r: right为矩阵链右终点 int r = l + mcLength - 1; //先算整条链从左到右的计算次数，不切割 /* * 计算方法为最左边的矩阵乘上右终点矩阵结果的列， * 再加上右边矩阵链的乘积 */ m[l][r] = m[l + 1][r] + p[l][0] * p[l][1] * p[r][1]; s[l][r] = l; //断开位置为矩阵l //b: break为中间断开位置 for(int b = l + 1; b &lt; r; b++) &#123; /* * 矩阵l的行为左边矩阵链的行 * 矩阵b的列为左边矩阵链的列 * 矩阵r的列为右边矩阵链的列 */ int t = m[l][b] + m[b + 1][r] + p[l][0] * p[b][1] * p[r][1]; if(t &lt; m[l][r]) &#123; m[l][r] = t; s[l][r] = b; &#125; &#125; &#125; &#125; &#125; /* * 动态规划的备忘录方法，自顶而下的递归，参数含义与上面的函数相同 * 备忘录方法是给记录项存入一个初始值，表示问题尚未解决。每次求解子问题时， * 先查看该值，若是初始值，表示该子问题尚未计算，计算值。若不是初始值， * 表示该子问题已计算过，直接返回即可。 */ public static int memoizedMatrixChain(int n) &#123; for(int i = 0; i &lt; n; i++) for(int j = i; j &lt; n; j++) m[i][j] = 0; return lookupChain(0, n); &#125; /** * 检查整条链的最优计算次序和断开位置，此方法使用于备忘录方法中 * 参数含义： * l: left为矩阵链左起点 * r: right为矩阵链右终点 * 返回值是矩阵链l到r的计算次序 */ public static int lookupChain(int l, int r) &#123; if(m[l][r] &gt; 0) return m[l][r]; if(l == r) return 0; int u = lookupChain(l + 1, r) + p[l][0] * p[l][1] * p[r][1]; s[l][r] = l; for(int k = l + 1; k &lt; r; k++) &#123; int t = lookupChain(l, k) + lookupChain(k + 1, r) + p[l][0] * p[k][1] * p[r][1]; if(t &lt; u) &#123; u = t; s[l][r] = k; &#125; &#125; m[l][r] = u; return u; &#125; /** * 函数求矩阵链最少乘积结果的断开位置，使用了递归方法，自底而上 * 参数说明： * i: 矩阵链左起点 * j: 矩阵链右终点 * s: 断开位置的存储矩阵 */ public static void traceback(int i, int j) &#123; if(i == j) return; //s[i][j]是断开位置，s[i][j] + 1是断开位置的下一个矩阵 traceback(i, s[i][j]); traceback(s[i][j] + 1, j); System.out.print("A[" + i + ", " + j + "] = "); System.out.println("A[" + i + ", " + s[i][j] + "] + A[" + (s[i][j] + 1) + ", " + j + "]"); &#125;&#125; ¶运行结果 说明：第一个结果为 m[i][j] 的值，第二个结果为 s[i][j] 的值，第三个结果为矩阵连乘中的计算次序，第四个结果为最少所需的计算次数]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划-总览]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%80%BB%E8%A7%88%2F</url>
    <content type="text"><![CDATA[¶思想描述 动态规划问题是面试题中的热门话题，动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。 动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。 ¶算法特征 求一个问题的最优解 大问题可以分解为子问题，子问题还有重叠的更小的子问题 整体问题最优解取决于子问题的最优解（状态转移方程） 从上往下分析问题，从下往上解决问题 讨论底层的边界问题 ¶博文导航 动态规划-矩阵连乘 动态规划-硬币问题 动态规划-最大子段和 动态规划-多边形游戏 动态规划-01背包问题 动态规划-最长公共子序列 动态规划-最优二叉搜索树]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>总览</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-最大子段和]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E6%9C%80%E5%A4%A7%E5%AD%90%E6%AE%B5%E5%92%8C%2F</url>
    <content type="text"><![CDATA[算法思想：分治法 实际问题：最大子段和 编写语言：Java ¶问题描述 此篇博文是分治法解决最大子段和问题的实现。 问题描述：给定由n个整数(可能为负数)组成的序列A={a1, a2, …, an}，求该序列形如sum(A, i, j)的子段和的最大值。当所有整数均为负整数时，定义其最大子段和为0，依次定义，所求的最大值为：max{0, sum(A, i, j)}， 例如：(a1, a2, a3, a4, a5, a6)=(-2, 11, -4, 13, -5, -2)时，最大子段和为sum(A, 2, 4)=20 算法思想： 1. sum(A, 1, n)==sum(A, 1, n/2) 2. sum(A, 1, n)==sum(A, n/2+1, n) 3. sum(A, 1, n)==sum(A, i, j), 其中 1&lt;=i&lt;=n/2, n/2+1&lt;=j&lt;=n 解释：即序列A的最大子段和可能在A的左半部分，也可能在A的右半部分，还可能跨越了A的左右两个部分 ¶Java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class MaxSubsequenceSum&#123; public static void main(String[] args) &#123; int[] a = new int[]&#123;-2, 11, -4, 13, -5, -2&#125;; int result = maxSubSum(a, 0, a.length - 1); System.out.println("maxSubSum(a) = " + result); &#125; /** * 使用分治思想求取最大子段和 * 参数含义： * a: 待求取最大子段和的数组 * left：子段起点 * right：子段终点 */ public static int maxSubSum(int[] a, int left, int right) &#123; int sum = 0; //sum为总的最大子段和 if(left == right) sum = a[left] &gt; 0 ? a[left] : 0; else &#123; int mid = (left + right) / 2; /* * 分治求解 */ //求左子段的和 int leftSum = maxSubSum(a, left, mid); //求右子段的和 int rightSum = maxSubSum(a, mid + 1, right); //求跨越左右两段的子段和：开始 int maxLefts = 0; int lefts = 0; /* * 子段是连续的，从中间向两边扩散 * 若是从左半部分从左边开始计算子段和，可能会导致整体的 * 左右子段不连续，故左半部分子段和从右边往左边运算， * 右半部分子段和从左边往右边运算，保证整体的子段连续 */ for(int i = mid; i &gt;= left; i--) &#123; lefts += a[i]; if(lefts &gt; maxLefts) maxLefts = lefts; &#125; int maxRights = 0; int rights = 0; for(int i = mid + 1; i &lt; right; i++) &#123; rights += a[i]; if(rights &gt; maxRights) maxRights = rights; &#125; sum = maxLefts + maxRights; //求跨越左右两段的子段和：结束 //判断得到最大子段和 if(sum &lt; leftSum) sum = leftSum; if(sum &lt; rightSum) sum = rightSum; &#125; return sum; &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-总览]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E6%80%BB%E8%A7%88%2F</url>
    <content type="text"><![CDATA[¶思想描述 分治法是一种算法思想，其设计思想为：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，这些子问题相互独立且与原问题相同。从而达到各个击破，分而治之的目的。在实际应用中，分治法往往会和递归算法结合在一起。 递归的概念：直接或者间接地调用自身的算法称为递归算法，用函数自身给出定义的函数称为递归函数。如下面的就是递归函数的一个简单例子： 12345678//此递归函数用来求斐波那契数列第n项的值public static int getSum(int n)&#123; if(n &lt;= 1) return 1; else return getSum(n - 1) + getSum(n - 2);&#125; ¶博文导航 分治法-排列问题 分治法-归并排序 分治法-快速排序 分治法-棋盘覆盖 分治法-最大子段和 分治法-线性时间选择 分治法-循环赛日程表 分治法-Strassen矩阵乘法]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
        <tag>总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法总览]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88%2F</url>
    <content type="text"><![CDATA[算法的重要性我不陈述了。 这是一篇算法部分的总览导航文。 参考书籍：《计算机算法设计与分析第4版》（王晓东著，电子工业出版社） 分治法-总览 动态规划-总览 贪心算法-总览 回溯法-总览]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>总览</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-循环赛日程表]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E5%BE%AA%E7%8E%AF%E8%B5%9B%E6%97%A5%E7%A8%8B%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[算法思想：分治法 实际问题：循环赛日程表 编写语言：Java ¶问题描述 假设有 n = 2^k 个运动员进行循环赛，要根据以下限制生成一个日程表： 1. 每个选手必须与其他 n - 1 个选手各赛一次 2. 每个选手一天只能赛一次 3. 循环赛一共进行 n - 1 天 生成内容：n行，n - 1列的表b，b(i)(j)表示选手i在j天遇到的对手 ¶Java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class RoundRobinSchedule&#123; public static void main(String[] args) &#123; int[][] table = getTable(3); for(int i = 0; i &lt; table.length; i++) &#123; for(int j = 0; j &lt; table[0].length; j++) System.out.print(table[i][j] + " "); System.out.println(); &#125; &#125; public static int[][] getTable(int k) &#123; int n = 1 &lt;&lt; k; //n = 2^k //构造第一行数作为初始数据 int[][] a = new int[n][n]; for(int i = 0; i &lt; n; i++) a[0][i] = i + 1; /** * 将整个赛程表分为四个部分： * 左上角1：(0, i), 右上角2：(0, r + i) * 左下角3：(r, i), 右下角4：(r, r + i) * r为跨度，思想是将内容 1 复制到内容 4，将内容 2 复制到内容 3 */ //r是跨度，长度每次扩大一倍，跨度最小为1 for(int r = 1; r &lt; n; r &lt;&lt;= 1) for(int i = 0; i &lt; n; i += r &lt;&lt; 1) //起点每次跨越两倍长度 &#123; copy(a, r, r + i, 0, i, r); //左上角换到右下角 copy(a, r, i, 0, r + i, r); //右上角换到左下角 &#125; return a; &#125; public static void copy(int[][] a, int tox, int toy, int fromx, int fromy, int r) &#123; for(int i = 0; i &lt; r; i++) for(int j = 0; j &lt; r; j++) a[tox + i][toy + j] = a[fromx + i][fromy + j]; //System.out.println(); &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-棋盘覆盖]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E6%A3%8B%E7%9B%98%E8%A6%86%E7%9B%96%2F</url>
    <content type="text"><![CDATA[算法思想：分治法 实际问题：棋盘覆盖 编写语言：Java ¶问题描述 在一个 2k×2k 个方格组成的棋盘中，恰有一个方格与其他方格不同，称该方格为一特殊方格，且称该棋盘为一特殊棋盘。在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。 ¶Java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import java.util.Scanner;public class BoardCover&#123; private static int[][] board; private static int num; //String[] 和 String... 的区别：一个是固定参数，一个是参数长度可变 public static void main(String... args) &#123; Scanner input = new Scanner(System.in); System.out.println("提示：棋盘大小必须为2的幂次方。" + "\n 输入的格式为：棋盘大小，特殊方格横坐标，特殊方格纵坐标" + "\n 分隔符为：英文逗号 + 空格，即 \", \"\n"); System.out.print("请输入数据："); String aryStr = input.nextLine(); String[] temp = aryStr.split(", "); int[] msg = new int[3]; for(int i = 0; i &lt; 3; i++) msg[i] = Integer.parseInt(temp[i]); board = new int[msg[0]][msg[0]]; cover(msg[0], msg[1], msg[2], 0, 0); //给特殊点赋值 board[msg[1]][msg[2]] = 0; for(int i = 0; i &lt; msg[0]; i++) &#123; for(int j = 0; j &lt; msg[0]; j++) System.out.print(board[i][j] + " "); System.out.println(); &#125; &#125; //参数含义：size为棋盘大小，x，y为特殊点坐标, sx，sy为棋盘起点坐标 public static void cover(int size, int x, int y, int sx, int sy) &#123; if(size == 1) return; int t = ++num; //函数递归的层数 int halfSize = size / 2; if(x &lt; sx + halfSize &amp;&amp; y &lt; sy + halfSize) //特殊点在左上角棋盘 &#123; cover(halfSize, x, y, sx, sy); &#125; else //特殊点不在左上角棋盘 &#123; //填充右下角为特殊点 int tx = sx + halfSize - 1; int ty = sy + halfSize - 1; board[tx][ty] = t; //填充剩余棋盘 cover(halfSize, tx, ty, sx, sy); &#125; if(x &gt;= sx + halfSize &amp;&amp; y &lt; sy + halfSize) //特殊点在右上角棋盘 &#123; cover(halfSize, x, y, sx + halfSize, sy); &#125; else //特殊点不在右上角棋盘 &#123; //填充左下角为特殊点 int tx = sx + halfSize; int ty = sy + halfSize - 1; board[tx][ty] = t; //填充剩余棋盘 cover(halfSize, tx, ty, sx + halfSize, sy); &#125; if(x &lt; sx + halfSize &amp;&amp; y &gt;= sy + halfSize) //特殊点在左下角棋盘 &#123; cover(halfSize, x, y, sx, sy + halfSize); &#125; else //特殊点不在左下角棋盘 &#123; //填充右上角为特殊点 int tx = sx + halfSize - 1; int ty = sy + halfSize; board[tx][ty] = t; //填充剩余棋盘 cover(halfSize, tx, ty, sx, sy + halfSize); &#125; if(x &gt;= sx + halfSize &amp;&amp; y &gt;= sy + halfSize) //特殊点在右下角棋盘 &#123; cover(halfSize, x, y, sx + halfSize, sy + halfSize); &#125; else //特殊点不在右下角棋盘 &#123; //填充左上角为特殊点 int tx = sx + halfSize; int ty = sy + halfSize; board[tx][ty] = t; //填充剩余棋盘 cover(halfSize, tx, ty, sx + halfSize, sy + halfSize); &#125; &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-Strassen矩阵乘法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-Strassen%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法思想：分治法 实际问题：Strassen 矩阵乘法 编写语言：Java ¶问题描述 我们知道，两个大小为 2 * 2 的矩阵相乘，一般需要进行 8 次乘法。而Strassen矩阵乘法可以减少一次乘法，只需要 7 次，看似很少，但当数据量很大时，效率就会有显著提升。不过使用 Strassen矩阵乘法需要满足 矩阵边长为 2 的幂次方。因为该算法会用到分治，如果分治后矩阵两边边长不等，结果会出错。 使用下面的方法计算结果矩阵，假设两个长度为 2 的矩阵是 A，B，相乘后的结果矩阵为 C： 1234567M1 = A11(B12 - B22) 注：Anm 表示 A 矩阵第 n 行 k 列的值，Bnm，Cnm 同理M2 = (A11 + A12)B22M3 = (A21 + A22)B11 M4 = A22(B21 - B11)M5 = (A11 + A22)(B11 + B22)M6 = (A12 - A22)(B21 + B22)M7 = (A11 - A21)(B11 + B12) 可得结果为： 1234C11 = M5 + M4 - M2 + M6C12 = M1 + M2C21 = M3 + M4C22 = M5 + M1 - M3 - M7 ¶Java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172public class StrassenMatrixMultiply&#123; public static void main(String[] args) &#123; int[] a = new int[] &#123; 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4 &#125;; int[] b = new int[] &#123; 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4 &#125;; int length = 4; int[] c = sMM(a, b, length); for(int i = 0; i &lt; c.length; i++) &#123; System.out.print(c[i] + " "); if((i + 1) % length == 0) //换行 System.out.println(); &#125; &#125; public static int[] sMM(int[] a, int[] b, int length) &#123; if(length == 2) &#123; return getResult(a, b); &#125; else &#123; int tlength = length / 2; //把a数组分为四部分，进行分治递归 int[] aa = new int[tlength * tlength]; int[] ab = new int[tlength * tlength]; int[] ac = new int[tlength * tlength]; int[] ad = new int[tlength * tlength]; //把b数组分为四部分，进行分治递归 int[] ba = new int[tlength * tlength]; int[] bb = new int[tlength * tlength]; int[] bc = new int[tlength * tlength]; int[] bd = new int[tlength * tlength]; //划分子矩阵 for(int i = 0; i &lt; length; i++) &#123; for(int j = 0; j &lt; length; j++) &#123; /* * 划分矩阵： * 例子：将 4 * 4 的矩阵，变为 2 * 2 的矩阵， * 那么原矩阵左上、右上、左下、右下的四个元素分别归为新矩阵 */ if(i &lt; tlength) &#123; if(j &lt; tlength) &#123; aa[i * tlength + j] = a[i * length + j]; ba[i * tlength + j] = b[i * length + j]; &#125; else &#123; ab[i * tlength + (j - tlength)] = a[i * length + j]; bb[i * tlength + (j - tlength)] = b[i * length + j]; &#125; &#125; else &#123; if(j &lt; tlength) &#123; //i 大于 tlength 时，需要减去 tlength，j同理 //因为 b，c，d三个子矩阵有对应了父矩阵的后半部分 ac[(i - tlength) * tlength + j] = a[i * length + j]; bc[(i - tlength) * tlength + j] = b[i * length + j]; &#125; else &#123; ad[(i - tlength) * tlength + (j - tlength)] = a[i * length + j]; bd[(i - tlength) * tlength + (j - tlength)] = b[i * length + j]; &#125; &#125; &#125; &#125; //分治递归 int[] result = new int[length * length]; //temp：4个临时矩阵 int[] t1 = add(sMM(aa, ba, tlength), sMM(ab, bc, tlength)); int[] t2 = add(sMM(aa, bb, tlength), sMM(ab, bd, tlength)); int[] t3 = add(sMM(ac, ba, tlength), sMM(ad, bc, tlength)); int[] t4 = add(sMM(ac, bb, tlength), sMM(ad, bd, tlength)); //归并结果 for(int i = 0; i &lt; length; i++) &#123; for(int j = 0; j &lt; length; j++) &#123; if(i &lt; tlength) &#123; if(j &lt; tlength) result[i * length + j] = t1[i * tlength + j]; else result[i * length + j] = t2[i * tlength + (j - tlength)]; &#125; else &#123; if(j &lt; tlength) result[i * length + j] = t3[(i - tlength) * tlength + j]; else result[i * length + j] = t4[(i - tlength) * tlength + (j - tlength)]; &#125; &#125; &#125; return result; &#125; &#125; public static int[] getResult(int[] a, int[] b) &#123; int p1 = a[0] * (b[1] - b[3]); int p2 = (a[0] + a[1]) * b[3]; int p3 = (a[2] + a[3]) * b[0]; int p4 = a[3] * (b[2] - b[0]); int p5 = (a[0] + a[3]) * (b[0] + b[3]); int p6 = (a[1] - a[3]) * (b[2] + b[3]); int p7 = (a[0] - a[2]) * (b[0] + b[1]); int c00 = p5 + p4 - p2 + p6; int c01 = p1 + p2; int c10 = p3 + p4; int c11 = p5 + p1 -p3 - p7; return new int[] &#123;c00, c01, c10, c11&#125;; &#125; public static int[] add(int[] a, int[] b) &#123; int[] c = new int[a.length]; for(int i = 0; i &lt; a.length; i++) c[i] = a[i] + b[i]; return c; &#125; //返回一个数是不是2的幂次方 public static boolean adjust(int num) &#123; return (num &amp; (num - 1)) == 0; &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-线性时间选择]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%2F</url>
    <content type="text"><![CDATA[算法思想：分治法 实际问题：线性时间选择 编写语言：Java ¶问题描述 给定线性序集中 n 个元素和一个整数 k, 1 &lt;= k &lt;= n, 要求找出这 n 个元素中第 k 小的元素。即如果将这 n 个元素依其线性序排列时，排在第 k 个位置的元素即为要找的元素。 本篇博文代码会用到 分治法-快速排序 博文中用到的基准选择方法。 方法使用位置：代码第 25 行 方法实现位置：代码第 37 - 68 行 ¶Java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import java.util.Random;public class RandomizedSelect&#123; public static void main(String[] args) &#123; int[] a = new int[] &#123;1, 3, 2, 6, 5, 8, 4, 9, 7, 0&#125;; int t = select(a, 0, a.length - 1, 4); //选出第四大的数 System.out.println(t); &#125; //参数含义：a为待查询的数组，low为起点，high为终点，target为带查询的目标 public static int select(int[] a, int low, int high, int target) &#123; if(low == high) return a[low]; //将数组以i为基准分为两部分，左边的都小于i，右边的都大于i //此处会用到快速排序算法中的划分方法来找基准 int i = randPart(a, low, high); int length = i - low + 1; //数组左半部分的长度 //如果第target小的数小于等于左半部分的长度，则这个数在此部分内 if(target &lt;= length) return select(a, low, i, target); //如果第target小的数大于左半部分的长度，则这个数在右半部分内， //且左半部分的数都小于第target小的数 else return select(a, i + 1, high, target - length); &#125; //划分寻找基准-随机化优化 public static int randPart(int[] a, int low, int high) &#123; Random r = new Random(); //随机产生一个 low 到 high 的整数 int flag = low + r.nextInt(high - low + 1); int pivot = a[flag]; //实际还是相当于以a[0]为基准 a[flag] = a[low]; a[low] = pivot; while(low &lt; high) &#123; //1、从右往左找比基准小的数 while(low &lt; high &amp;&amp; a[high] &gt; pivot) high--; if(low &lt; high) a[low] = a[high]; //2、从左往右找比基准大的数 while(low &lt; high &amp;&amp; a[low] &lt;= pivot) low++; if(low &lt; high) a[high] = a[low]; &#125; //将pivot放到low和high相遇的地方 a[high] = pivot; return high; &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-归并排序]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想：分治法 实际问题：归并排序 编写语言：Java ¶Java代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667//本篇博文代码是递归方式归并排序算法的实现public class MergeSort&#123; public static void main(String[] args) &#123; int[] ary = new int[] &#123;1, 3, 4, 5, 2, 7, 0, 6, 9, 8&#125;; System.out.print("排序前的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); sort(ary); System.out.print("排序后的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); &#125; public static int[] sort(int[] a) &#123; return sort(a, 0, a.length - 1); &#125; public static int[] sort(int[] a, int low, int high) &#123; //low == high 说明两者相遇，即数组大小为1 if(low &lt; high) //当数组尺寸不为1的时候进行递归排序操作 &#123; int mid = (low + high) / 2; sort(a, low, mid); //对左半部分排序 sort(a, mid + 1, high); //对右半部分排序 //对左右两半部分排序后，两者都有序， //但左半部分的值不一定小于右半部分，所以需要归并整理 merge(a, low, mid, high); //归并 &#125; return a; &#125; public static int[] merge(int[] a, int low, int mid, int high) &#123; int[] r = new int[high - low + 1]; //下表从零开始，数组大小多1 //i为待返回结果数组起点，j为左半部分数组起点，k为右半部分数组起点 int i = 0, j = low, k = mid + 1; while(j &lt;= mid &amp;&amp; k &lt;= high) &#123; if(a[j] &lt; a[k]) r[i++] = a[j++]; else r[i++] = a[k++]; &#125; //若有左半部分一个元素未加入 result 数组，此处可解决这个问题 while(j &lt;= mid) r[i++] = a[j++]; //若有由半部分一个元素未加入 result 数组，此处可解决这个问题 while(k &lt;= high) r[i++] = a[k++]; //将result数组拷入原数组对应位置 System.arraycopy(r, 0, a, low, r.length); return a; &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-排列问题]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[算法思想：分治法 实际问题：排列问题 编写语言：Java ¶问题描述 显示列表list(a, b, c, d…) 的全排列，显示的条目数为：n! 例如(1, 2, 3)的全排列为(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1) ¶Java代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//下面的例子将以 A B C 为例public class ArrayProblem&#123; public static void main(String[] args) &#123; char[] list = new char[] &#123;'A', 'B', 'C'&#125;; System.out.println("序列(A, B, C)的全排列为：\n"); array(list); &#125; //全排列的产生函数 public static void array(char[] list) &#123; array(list, 0, list.length); &#125; //产生 start 到 end 的全排列 public static void array(char[] list, int start, int end) &#123; if(start == end) &#123; for(int i = 0; i &lt; end; i++) System.out.print(list[i] + " "); System.out.println(); &#125; else &#123; for(int i = start; i &lt; end; i++) &#123; //交换 list[i] 和 list[k] 的位置(例：i = 1 时，start = 0， //交换 A B 的位置，此时为 B A C) char temp = list[i]; list[i] = list[start]; list[start] = temp; //第一个交换位置后，产生剩下的全排列序列(第一个为 B， //产生 A C 的全排列) array(list, start + 1, end); //将一个有序序列全排列后，恢复原状，防止出现重复的结果 //(会出现两个完全相同的序列，即一次排列输出两次, //可以注释掉下面三行代码，运行观察效果，然后分析原因) temp = list[i]; list[i] = list[start]; list[start] = temp; &#125; &#125; &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-快速排序]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想：分治法 实际问题：快速排序 编写语言：Java ¶Java代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//本篇博文代码主要有两种基准选择方式：基准=低下标处的值，基准=随机值import java.util.Random;public class QuickSort&#123; public static void main(String[] args) &#123; int[] ary = new int[] &#123;1, 3, 4, 5, 2, 7, 0, 6, 9, 8&#125;; System.out.print("排序前的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); sort(ary); System.out.print("排序后的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); &#125; public static void sort(int[] a) &#123; sort(a, 0, a.length - 1); &#125; public static void sort(int[] a, int low, int high) &#123; //当low == high时就返回 //确保数组元素为1时就停止划分，防止数组下标越界 if(low &lt; high) &#123; int pivot = randPart(a, low, high); sort(a, low, pivot - 1); sort(a, pivot + 1, high); &#125; &#125; //划分寻找基准 public static int part(int[] a, int low, int high) &#123; int pivot = a[low]; while(low &lt; high) &#123; //1、从右往左找比基准小的数 while(low &lt; high &amp;&amp; a[high] &gt; pivot) high--; //a处赋值 if(low &lt; high) a[low] = a[high]; //此时是 a[high] &lt; pivot, a[low] &lt; pivot //2、从左往右找比基准大的数 while(low &lt; high &amp;&amp; a[low] &lt;= pivot) low++; //3、一次寻找结束，交换两个值 //b处赋值 if(low &lt; high) a[high] = a[low]; //此时是 a[high] &gt; pivot, a[low] &lt; pivot //a、b两处赋值，相当于一次交换，只是分开了 &#125; //将pivot放到left和right相遇的地方 a[high] = pivot; return high; &#125; //划分寻找基准-随机化优化 public static int randPart(int[] a, int low, int high) &#123; Random r = new Random(); //随机产生一个 low 到 high 的整数 int flag = low + r.nextInt(high - low + 1); int pivot = a[flag]; //此处交换保证 1 处的赋值不出错， //因为只要原 a[low] &lt; pivot，那么这个交换算法就失败了 a[flag] = a[low]; a[low] = pivot; while(low &lt; high) &#123; //1、从右往左找比基准小的数 while(low &lt; high &amp;&amp; a[high] &gt; pivot) high--; if(low &lt; high) a[low] = a[high]; //2、从左往右找比基准大的数 while(low &lt; high &amp;&amp; a[low] &lt;= pivot) low++; if(low &lt; high) a[high] = a[low]; &#125; //将pivot放到low和high相遇的地方 a[high] = pivot; return high; &#125;&#125; ¶运行结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
