<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[分治法-排列问题]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：全排列问题编写语言：Java 问题描述：显示 列表list(a, b, c, d……) 的全排列，显示的条目数为：n!代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//下面的例子将以 A B C 为例 public class ArrayProblem &#123; public static void main(String[] args) &#123; char[] list = new char[]&#123;'A', 'B', 'C'&#125;; System.out.println("序列(A, B, C)的全排列为：\n"); array(list); &#125; //全排列的产生函数 public static void array(char[] list) &#123; array(list, 0, list.length); &#125; //产生 start 到 end 的全排列 public static void array(char[] list, int start, int end) &#123; if(start == end) &#123; for(int i = 0; i &lt; end; i++) System.out.print(list[i] + " "); System.out.println(); &#125; else &#123; for(int i = start; i &lt; end; i++) &#123; //交换 list[start] 和 list[i] 的位置(例：i = 1 时，start = 0，交换 A B 的位置， //此时为 B A C) char temp = list[i]; list[i] = list[start]; list[start] = temp; //第一个交换位置后，产生剩下的全排列序列(第一个为 B，产生 A C 的全排列) array(list, start + 1, end); //将一个有序序列全排列后，恢复原状，防止出现重复的结果(会出现两个完全相同的序列， //即一次排列输出两次, 有兴趣可以注释掉下面三行代码，运行观察效果，然后分析原因) temp = list[i]; list[i] = list[start]; list[start] = temp; &#125; &#125; &#125; &#125; 运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分治法-快速排序]]></title>
    <url>%2F2018%2F08%2F13%2F%E5%88%86%E6%B2%BB%E6%B3%95-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[算法思想：分治法实际问题：快速排序编写语言：Java 本篇博文代码主要有两种基准选择方式：基准=低下标处的值，基准=随机值代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798public class QuickSort&#123; public static void main(String[] args) &#123; int[] ary = new int[]&#123;1, 3, 4, 5, 2, 7, 0, 6, 9, 8&#125;; System.out.print("排序前的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); sort(ary); System.out.print("排序后的数组："); for(int i = 0; i &lt; ary.length; i++) System.out.print(ary[i] + " "); System.out.println(); &#125; public static void sort(int[] a) &#123; sort(a, 0, a.length - 1); &#125; public static void sort(int[] a, int low, int high) &#123; //当low == high时就返回 //确保数组元素为1时就停止划分，防止数组下标越界 if(low &lt; high) &#123; int pivot = randPart(a, low, high); sort(a, low, pivot - 1); sort(a, pivot + 1, high); &#125; &#125; //划分寻找基准 public static int part(int[] a, int low, int high) &#123; int pivot = a[low]; while(low &lt; high) &#123; //1、从右往左找比基准小的数 while(low &lt; high &amp;&amp; a[high] &gt; pivot) high--; //a处赋值 if(low &lt; high) a[low] = a[high]; //此时是 a[high] &lt; pivot, a[low] &lt; pivot //2、从左往右找比基准大的数 while(low &lt; high &amp;&amp; a[low] &lt;= pivot) low++; //3、一次寻找结束，交换两个值 //b处赋值 if(low &lt; high) a[high] = a[low]; //此时是 a[high] &gt; pivot, a[low] &lt; pivot //a、b两处赋值，相当于一次交换，只是分开了 &#125; //将pivot放到left和right相遇的地方 a[high] = pivot; return high; &#125; //划分寻找基准-随机化优化：需要导入 Random 包(import java.util.Random) public static int randPart(int[] a, int low, int high) &#123; Random r = new Random(); int flag = low + r.nextInt(high - low + 1); //随机产生一个 low 到 high 的整数 int pivot = a[flag]; //此处交换保证 1 处的赋值不出错，因为只要原 a[low] &lt; pivot，那么这个交换算法就失败了 a[flag] = a[low]; a[low] = pivot; while(low &lt; high) &#123; //1、从右往左找比基准小的数 while(low &lt; high &amp;&amp; a[high] &gt; pivot) high--; if(low &lt; high) a[low] = a[high]; //2、从左往右找比基准大的数 while(low &lt; high &amp;&amp; a[low] &lt;= pivot) low++; if(low &lt; high) a[high] = a[low]; &#125; //将pivot放到low和high相遇的地方 a[high] = pivot; return high; &#125;&#125; 运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
</search>
